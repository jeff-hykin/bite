#!/usr/bin/env node
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};

// https://esm.sh/v135/esbuild@0.24.0/denonext/esbuild.mjs
import __Process$ from "node:process";
import { Buffer as __Buffer$ } from "node:buffer";
import * as __0$ from "node:fs";
import * as __1$ from "node:os";
import * as __2$ from "node:path";
import * as __3$ from "node:child_process";
import * as __4$ from "node:crypto";
import * as __5$ from "node:tty";
import * as __6$ from "node:worker_threads";
var __rResolve$, require2, Et, Ae, kt, St, At, Pt, le, jt, Mt, We, Se, ue, qe, Ot, Ye, Dt, Ve, ze, se, bt, xr, $r, Er, kr, Sr, Ar, Pr, jr, Mr, Or, Dr, Cr, yt, Lr, Tr;
var init_esbuild = __esm({
  "https://esm.sh/v135/esbuild@0.24.0/denonext/esbuild.mjs"() {
    __rResolve$ = (p20) => p20;
    require2 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "fs":
          return e2(__0$);
        case "os":
          return e2(__1$);
        case "path":
          return e2(__2$);
        case "child_process":
          return e2(__3$);
        case "crypto":
          return e2(__4$);
        case "tty":
          return e2(__5$);
        case "worker_threads":
          return e2(__6$);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    Et = Object.create;
    Ae = Object.defineProperty;
    kt = Object.getOwnPropertyDescriptor;
    St = Object.getOwnPropertyNames;
    At = Object.getPrototypeOf;
    Pt = Object.prototype.hasOwnProperty;
    le = ((e2) => typeof require2 < "u" ? require2 : typeof Proxy < "u" ? new Proxy(e2, { get: (t, r9) => (typeof require2 < "u" ? require2 : t)[r9] }) : e2)(function(e2) {
      if (typeof require2 < "u") return require2.apply(this, arguments);
      throw Error('Dynamic require of "' + e2 + '" is not supported');
    });
    jt = (e2, t) => () => (e2 && (t = e2(e2 = 0)), t);
    Mt = (e2, t) => () => (t || e2((t = { exports: {} }).exports, t), t.exports);
    We = (e2, t) => {
      for (var r9 in t) Ae(e2, r9, { get: t[r9], enumerable: true });
    };
    Se = (e2, t, r9, n14) => {
      if (t && typeof t == "object" || typeof t == "function") for (let l10 of St(t)) !Pt.call(e2, l10) && l10 !== r9 && Ae(e2, l10, { get: () => t[l10], enumerable: !(n14 = kt(t, l10)) || n14.enumerable });
      return e2;
    };
    ue = (e2, t, r9) => (Se(e2, t, "default"), r9 && Se(r9, t, "default"));
    qe = (e2, t, r9) => (r9 = e2 != null ? Et(At(e2)) : {}, Se(t || !e2 || !e2.__esModule ? Ae(r9, "default", { value: e2, enumerable: true }) : r9, e2));
    Ot = (e2) => Se(Ae({}, "__esModule", { value: true }), e2);
    Ye = {};
    We(Ye, { default: () => Dt });
    Ve = jt(() => {
      Dt = {};
    });
    ze = Mt((_r2, wt) => {
      "use strict";
      var Ue2 = Object.defineProperty, Ct = Object.getOwnPropertyDescriptor, Lt = Object.getOwnPropertyNames, Tt = Object.prototype.hasOwnProperty, Ft = (e2, t) => {
        for (var r9 in t) Ue2(e2, r9, { get: t[r9], enumerable: true });
      }, _t = (e2, t, r9, n14) => {
        if (t && typeof t == "object" || typeof t == "function") for (let l10 of Lt(t)) !Tt.call(e2, l10) && l10 !== r9 && Ue2(e2, l10, { get: () => t[l10], enumerable: !(n14 = Ct(t, l10)) || n14.enumerable });
        return e2;
      }, Bt = (e2) => _t(Ue2({}, "__esModule", { value: true }), e2), Ee2 = {};
      Ft(Ee2, { analyzeMetafile: () => dr, analyzeMetafileSync: () => gr, build: () => sr, buildSync: () => hr, context: () => ur, default: () => vr2, formatMessages: () => cr2, formatMessagesSync: () => pr2, initialize: () => yr, stop: () => wr, transform: () => fr, transformSync: () => mr2, version: () => or });
      wt.exports = Bt(Ee2);
      function Je(e2) {
        let t = (n14) => {
          if (n14 === null) r9.write8(0);
          else if (typeof n14 == "boolean") r9.write8(1), r9.write8(+n14);
          else if (typeof n14 == "number") r9.write8(2), r9.write32(n14 | 0);
          else if (typeof n14 == "string") r9.write8(3), r9.write(ne3(n14));
          else if (n14 instanceof Uint8Array) r9.write8(4), r9.write(n14);
          else if (n14 instanceof Array) {
            r9.write8(5), r9.write32(n14.length);
            for (let l10 of n14) t(l10);
          } else {
            let l10 = Object.keys(n14);
            r9.write8(6), r9.write32(l10.length);
            for (let s12 of l10) r9.write(ne3(s12)), t(n14[s12]);
          }
        }, r9 = new it();
        return r9.write32(0), r9.write32(e2.id << 1 | +!e2.isRequest), t(e2.value), Ie(r9.buf, r9.len - 4, 0), r9.buf.subarray(0, r9.len);
      }
      function It(e2) {
        let t = () => {
          switch (r9.read8()) {
            case 0:
              return null;
            case 1:
              return !!r9.read8();
            case 2:
              return r9.read32();
            case 3:
              return we2(r9.read());
            case 4:
              return r9.read();
            case 5: {
              let a20 = r9.read32(), h20 = [];
              for (let o10 = 0; o10 < a20; o10++) h20.push(t());
              return h20;
            }
            case 6: {
              let a20 = r9.read32(), h20 = {};
              for (let o10 = 0; o10 < a20; o10++) h20[we2(r9.read())] = t();
              return h20;
            }
            default:
              throw new Error("Invalid packet");
          }
        }, r9 = new it(e2), n14 = r9.read32(), l10 = (n14 & 1) === 0;
        n14 >>>= 1;
        let s12 = t();
        if (r9.ptr !== e2.length) throw new Error("Invalid packet");
        return { id: n14, isRequest: l10, value: s12 };
      }
      var it = class {
        constructor(e2 = new Uint8Array(1024)) {
          this.buf = e2, this.len = 0, this.ptr = 0;
        }
        _write(e2) {
          if (this.len + e2 > this.buf.length) {
            let t = new Uint8Array((this.len + e2) * 2);
            t.set(this.buf), this.buf = t;
          }
          return this.len += e2, this.len - e2;
        }
        write8(e2) {
          let t = this._write(1);
          this.buf[t] = e2;
        }
        write32(e2) {
          let t = this._write(4);
          Ie(this.buf, e2, t);
        }
        write(e2) {
          let t = this._write(4 + e2.length);
          Ie(this.buf, e2.length, t), this.buf.set(e2, t + 4);
        }
        _read(e2) {
          if (this.ptr + e2 > this.buf.length) throw new Error("Invalid packet");
          return this.ptr += e2, this.ptr - e2;
        }
        read8() {
          return this.buf[this._read(1)];
        }
        read32() {
          return lt(this.buf, this._read(4));
        }
        read() {
          let e2 = this.read32(), t = new Uint8Array(e2), r9 = this._read(t.length);
          return t.set(this.buf.subarray(r9, r9 + e2)), t;
        }
      }, ne3, we2, Be3;
      if (typeof TextEncoder < "u" && typeof TextDecoder < "u") {
        let e2 = new TextEncoder(), t = new TextDecoder();
        ne3 = (r9) => e2.encode(r9), we2 = (r9) => t.decode(r9), Be3 = 'new TextEncoder().encode("")';
      } else if (typeof __Buffer$ < "u") ne3 = (e2) => __Buffer$.from(e2), we2 = (e2) => {
        let { buffer: t, byteOffset: r9, byteLength: n14 } = e2;
        return __Buffer$.from(t, r9, n14).toString();
      }, Be3 = 'Buffer.from("")';
      else throw new Error("No UTF-8 codec found");
      if (!(ne3("") instanceof Uint8Array)) throw new Error(`Invariant violation: "${Be3} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
      function lt(e2, t) {
        return e2[t++] | e2[t++] << 8 | e2[t++] << 16 | e2[t++] << 24;
      }
      function Ie(e2, t, r9) {
        e2[r9++] = t, e2[r9++] = t >> 8, e2[r9++] = t >> 16, e2[r9++] = t >> 24;
      }
      var J7 = JSON.stringify, He = "warning", Ke = "silent";
      function Qe2(e2) {
        if (K4(e2, "target"), e2.indexOf(",") >= 0) throw new Error(`Invalid target: ${e2}`);
        return e2;
      }
      var Me = () => null, z11 = (e2) => typeof e2 == "boolean" ? null : "a boolean", y20 = (e2) => typeof e2 == "string" ? null : "a string", Oe = (e2) => e2 instanceof RegExp ? null : "a RegExp object", ce3 = (e2) => typeof e2 == "number" && e2 === (e2 | 0) ? null : "an integer", at2 = (e2) => typeof e2 == "function" ? null : "a function", Y5 = (e2) => Array.isArray(e2) ? null : "an array", te4 = (e2) => typeof e2 == "object" && e2 !== null && !Array.isArray(e2) ? null : "an object", Nt = (e2) => typeof e2 == "object" && e2 !== null ? null : "an array or an object", Rt = (e2) => e2 instanceof WebAssembly.Module ? null : "a WebAssembly.Module", Xe = (e2) => typeof e2 == "object" && !Array.isArray(e2) ? null : "an object or null", ot = (e2) => typeof e2 == "string" || typeof e2 == "boolean" ? null : "a string or a boolean", Ut = (e2) => typeof e2 == "string" || typeof e2 == "object" && e2 !== null && !Array.isArray(e2) ? null : "a string or an object", zt = (e2) => typeof e2 == "string" || Array.isArray(e2) ? null : "a string or an array", st = (e2) => typeof e2 == "string" || e2 instanceof Uint8Array ? null : "a string or a Uint8Array", Wt = (e2) => typeof e2 == "string" || e2 instanceof URL ? null : "a string or a URL";
      function i14(e2, t, r9, n14) {
        let l10 = e2[r9];
        if (t[r9 + ""] = true, l10 === void 0) return;
        let s12 = n14(l10);
        if (s12 !== null) throw new Error(`${J7(r9)} must be ${s12}`);
        return l10;
      }
      function H5(e2, t, r9) {
        for (let n14 in e2) if (!(n14 in t)) throw new Error(`Invalid option ${r9}: ${J7(n14)}`);
      }
      function qt(e2) {
        let t = /* @__PURE__ */ Object.create(null), r9 = i14(e2, t, "wasmURL", Wt), n14 = i14(e2, t, "wasmModule", Rt), l10 = i14(e2, t, "worker", z11);
        return H5(e2, t, "in initialize() call"), { wasmURL: r9, wasmModule: n14, worker: l10 };
      }
      function ut(e2) {
        let t;
        if (e2 !== void 0) {
          t = /* @__PURE__ */ Object.create(null);
          for (let r9 in e2) {
            let n14 = e2[r9];
            if (typeof n14 == "string" || n14 === false) t[r9] = n14;
            else throw new Error(`Expected ${J7(r9)} in mangle cache to map to either a string or false`);
          }
        }
        return t;
      }
      function Te(e2, t, r9, n14, l10) {
        let s12 = i14(t, r9, "color", z11), a20 = i14(t, r9, "logLevel", y20), h20 = i14(t, r9, "logLimit", ce3);
        s12 !== void 0 ? e2.push(`--color=${s12}`) : n14 && e2.push("--color=true"), e2.push(`--log-level=${a20 || l10}`), e2.push(`--log-limit=${h20 || 0}`);
      }
      function K4(e2, t, r9) {
        if (typeof e2 != "string") throw new Error(`Expected value for ${t}${r9 !== void 0 ? " " + J7(r9) : ""} to be a string, got ${typeof e2} instead`);
        return e2;
      }
      function ft(e2, t, r9) {
        let n14 = i14(t, r9, "legalComments", y20), l10 = i14(t, r9, "sourceRoot", y20), s12 = i14(t, r9, "sourcesContent", z11), a20 = i14(t, r9, "target", zt), h20 = i14(t, r9, "format", y20), o10 = i14(t, r9, "globalName", y20), w13 = i14(t, r9, "mangleProps", Oe), m23 = i14(t, r9, "reserveProps", Oe), x22 = i14(t, r9, "mangleQuoted", z11), N12 = i14(t, r9, "minify", z11), _22 = i14(t, r9, "minifySyntax", z11), I12 = i14(t, r9, "minifyWhitespace", z11), R8 = i14(t, r9, "minifyIdentifiers", z11), L8 = i14(t, r9, "lineLimit", ce3), W9 = i14(t, r9, "drop", Y5), q16 = i14(t, r9, "dropLabels", Y5), v15 = i14(t, r9, "charset", y20), g16 = i14(t, r9, "treeShaking", z11), d20 = i14(t, r9, "ignoreAnnotations", z11), u17 = i14(t, r9, "jsx", y20), $6 = i14(t, r9, "jsxFactory", y20), A15 = i14(t, r9, "jsxFragment", y20), D8 = i14(t, r9, "jsxImportSource", y20), P11 = i14(t, r9, "jsxDev", z11), f15 = i14(t, r9, "jsxSideEffects", z11), c16 = i14(t, r9, "define", te4), b18 = i14(t, r9, "logOverride", te4), M6 = i14(t, r9, "supported", te4), C19 = i14(t, r9, "pure", Y5), j16 = i14(t, r9, "keepNames", z11), S16 = i14(t, r9, "platform", y20), O11 = i14(t, r9, "tsconfigRaw", Ut);
        if (n14 && e2.push(`--legal-comments=${n14}`), l10 !== void 0 && e2.push(`--source-root=${l10}`), s12 !== void 0 && e2.push(`--sources-content=${s12}`), a20 && (Array.isArray(a20) ? e2.push(`--target=${Array.from(a20).map(Qe2).join(",")}`) : e2.push(`--target=${Qe2(a20)}`)), h20 && e2.push(`--format=${h20}`), o10 && e2.push(`--global-name=${o10}`), S16 && e2.push(`--platform=${S16}`), O11 && e2.push(`--tsconfig-raw=${typeof O11 == "string" ? O11 : JSON.stringify(O11)}`), N12 && e2.push("--minify"), _22 && e2.push("--minify-syntax"), I12 && e2.push("--minify-whitespace"), R8 && e2.push("--minify-identifiers"), L8 && e2.push(`--line-limit=${L8}`), v15 && e2.push(`--charset=${v15}`), g16 !== void 0 && e2.push(`--tree-shaking=${g16}`), d20 && e2.push("--ignore-annotations"), W9) for (let k13 of W9) e2.push(`--drop:${K4(k13, "drop")}`);
        if (q16 && e2.push(`--drop-labels=${Array.from(q16).map((k13) => K4(k13, "dropLabels")).join(",")}`), w13 && e2.push(`--mangle-props=${w13.source}`), m23 && e2.push(`--reserve-props=${m23.source}`), x22 !== void 0 && e2.push(`--mangle-quoted=${x22}`), u17 && e2.push(`--jsx=${u17}`), $6 && e2.push(`--jsx-factory=${$6}`), A15 && e2.push(`--jsx-fragment=${A15}`), D8 && e2.push(`--jsx-import-source=${D8}`), P11 && e2.push("--jsx-dev"), f15 && e2.push("--jsx-side-effects"), c16) for (let k13 in c16) {
          if (k13.indexOf("=") >= 0) throw new Error(`Invalid define: ${k13}`);
          e2.push(`--define:${k13}=${K4(c16[k13], "define", k13)}`);
        }
        if (b18) for (let k13 in b18) {
          if (k13.indexOf("=") >= 0) throw new Error(`Invalid log override: ${k13}`);
          e2.push(`--log-override:${k13}=${K4(b18[k13], "log override", k13)}`);
        }
        if (M6) for (let k13 in M6) {
          if (k13.indexOf("=") >= 0) throw new Error(`Invalid supported: ${k13}`);
          let E11 = M6[k13];
          if (typeof E11 != "boolean") throw new Error(`Expected value for supported ${J7(k13)} to be a boolean, got ${typeof E11} instead`);
          e2.push(`--supported:${k13}=${E11}`);
        }
        if (C19) for (let k13 of C19) e2.push(`--pure:${K4(k13, "pure")}`);
        j16 && e2.push("--keep-names");
      }
      function Yt(e2, t, r9, n14, l10) {
        var s12;
        let a20 = [], h20 = [], o10 = /* @__PURE__ */ Object.create(null), w13 = null, m23 = null;
        Te(a20, t, o10, r9, n14), ft(a20, t, o10);
        let x22 = i14(t, o10, "sourcemap", ot), N12 = i14(t, o10, "bundle", z11), _22 = i14(t, o10, "splitting", z11), I12 = i14(t, o10, "preserveSymlinks", z11), R8 = i14(t, o10, "metafile", z11), L8 = i14(t, o10, "outfile", y20), W9 = i14(t, o10, "outdir", y20), q16 = i14(t, o10, "outbase", y20), v15 = i14(t, o10, "tsconfig", y20), g16 = i14(t, o10, "resolveExtensions", Y5), d20 = i14(t, o10, "nodePaths", Y5), u17 = i14(t, o10, "mainFields", Y5), $6 = i14(t, o10, "conditions", Y5), A15 = i14(t, o10, "external", Y5), D8 = i14(t, o10, "packages", y20), P11 = i14(t, o10, "alias", te4), f15 = i14(t, o10, "loader", te4), c16 = i14(t, o10, "outExtension", te4), b18 = i14(t, o10, "publicPath", y20), M6 = i14(t, o10, "entryNames", y20), C19 = i14(t, o10, "chunkNames", y20), j16 = i14(t, o10, "assetNames", y20), S16 = i14(t, o10, "inject", Y5), O11 = i14(t, o10, "banner", te4), k13 = i14(t, o10, "footer", te4), E11 = i14(t, o10, "entryPoints", Nt), B10 = i14(t, o10, "absWorkingDir", y20), T9 = i14(t, o10, "stdin", te4), F5 = (s12 = i14(t, o10, "write", z11)) != null ? s12 : l10, Z3 = i14(t, o10, "allowOverwrite", z11), V2 = i14(t, o10, "mangleCache", te4);
        if (o10.plugins = true, H5(t, o10, `in ${e2}() call`), x22 && a20.push(`--sourcemap${x22 === true ? "" : `=${x22}`}`), N12 && a20.push("--bundle"), Z3 && a20.push("--allow-overwrite"), _22 && a20.push("--splitting"), I12 && a20.push("--preserve-symlinks"), R8 && a20.push("--metafile"), L8 && a20.push(`--outfile=${L8}`), W9 && a20.push(`--outdir=${W9}`), q16 && a20.push(`--outbase=${q16}`), v15 && a20.push(`--tsconfig=${v15}`), D8 && a20.push(`--packages=${D8}`), g16) {
          let p20 = [];
          for (let U6 of g16) {
            if (K4(U6, "resolve extension"), U6.indexOf(",") >= 0) throw new Error(`Invalid resolve extension: ${U6}`);
            p20.push(U6);
          }
          a20.push(`--resolve-extensions=${p20.join(",")}`);
        }
        if (b18 && a20.push(`--public-path=${b18}`), M6 && a20.push(`--entry-names=${M6}`), C19 && a20.push(`--chunk-names=${C19}`), j16 && a20.push(`--asset-names=${j16}`), u17) {
          let p20 = [];
          for (let U6 of u17) {
            if (K4(U6, "main field"), U6.indexOf(",") >= 0) throw new Error(`Invalid main field: ${U6}`);
            p20.push(U6);
          }
          a20.push(`--main-fields=${p20.join(",")}`);
        }
        if ($6) {
          let p20 = [];
          for (let U6 of $6) {
            if (K4(U6, "condition"), U6.indexOf(",") >= 0) throw new Error(`Invalid condition: ${U6}`);
            p20.push(U6);
          }
          a20.push(`--conditions=${p20.join(",")}`);
        }
        if (A15) for (let p20 of A15) a20.push(`--external:${K4(p20, "external")}`);
        if (P11) for (let p20 in P11) {
          if (p20.indexOf("=") >= 0) throw new Error(`Invalid package name in alias: ${p20}`);
          a20.push(`--alias:${p20}=${K4(P11[p20], "alias", p20)}`);
        }
        if (O11) for (let p20 in O11) {
          if (p20.indexOf("=") >= 0) throw new Error(`Invalid banner file type: ${p20}`);
          a20.push(`--banner:${p20}=${K4(O11[p20], "banner", p20)}`);
        }
        if (k13) for (let p20 in k13) {
          if (p20.indexOf("=") >= 0) throw new Error(`Invalid footer file type: ${p20}`);
          a20.push(`--footer:${p20}=${K4(k13[p20], "footer", p20)}`);
        }
        if (S16) for (let p20 of S16) a20.push(`--inject:${K4(p20, "inject")}`);
        if (f15) for (let p20 in f15) {
          if (p20.indexOf("=") >= 0) throw new Error(`Invalid loader extension: ${p20}`);
          a20.push(`--loader:${p20}=${K4(f15[p20], "loader", p20)}`);
        }
        if (c16) for (let p20 in c16) {
          if (p20.indexOf("=") >= 0) throw new Error(`Invalid out extension: ${p20}`);
          a20.push(`--out-extension:${p20}=${K4(c16[p20], "out extension", p20)}`);
        }
        if (E11) if (Array.isArray(E11)) for (let p20 = 0, U6 = E11.length; p20 < U6; p20++) {
          let ee3 = E11[p20];
          if (typeof ee3 == "object" && ee3 !== null) {
            let ie3 = /* @__PURE__ */ Object.create(null), G4 = i14(ee3, ie3, "in", y20), be2 = i14(ee3, ie3, "out", y20);
            if (H5(ee3, ie3, "in entry point at index " + p20), G4 === void 0) throw new Error('Missing property "in" for entry point at index ' + p20);
            if (be2 === void 0) throw new Error('Missing property "out" for entry point at index ' + p20);
            h20.push([be2, G4]);
          } else h20.push(["", K4(ee3, "entry point at index " + p20)]);
        }
        else for (let p20 in E11) h20.push([p20, K4(E11[p20], "entry point", p20)]);
        if (T9) {
          let p20 = /* @__PURE__ */ Object.create(null), U6 = i14(T9, p20, "contents", st), ee3 = i14(T9, p20, "resolveDir", y20), ie3 = i14(T9, p20, "sourcefile", y20), G4 = i14(T9, p20, "loader", y20);
          H5(T9, p20, 'in "stdin" object'), ie3 && a20.push(`--sourcefile=${ie3}`), G4 && a20.push(`--loader=${G4}`), ee3 && (m23 = ee3), typeof U6 == "string" ? w13 = ne3(U6) : U6 instanceof Uint8Array && (w13 = U6);
        }
        let pe2 = [];
        if (d20) for (let p20 of d20) p20 += "", pe2.push(p20);
        return { entries: h20, flags: a20, write: F5, stdinContents: w13, stdinResolveDir: m23, absWorkingDir: B10, nodePaths: pe2, mangleCache: ut(V2) };
      }
      function Vt(e2, t, r9, n14) {
        let l10 = [], s12 = /* @__PURE__ */ Object.create(null);
        Te(l10, t, s12, r9, n14), ft(l10, t, s12);
        let a20 = i14(t, s12, "sourcemap", ot), h20 = i14(t, s12, "sourcefile", y20), o10 = i14(t, s12, "loader", y20), w13 = i14(t, s12, "banner", y20), m23 = i14(t, s12, "footer", y20), x22 = i14(t, s12, "mangleCache", te4);
        return H5(t, s12, `in ${e2}() call`), a20 && l10.push(`--sourcemap=${a20 === true ? "external" : a20}`), h20 && l10.push(`--sourcefile=${h20}`), o10 && l10.push(`--loader=${o10}`), w13 && l10.push(`--banner=${w13}`), m23 && l10.push(`--footer=${m23}`), { flags: l10, mangleCache: ut(x22) };
      }
      function ct(e2) {
        let t = {}, r9 = { didClose: false, reason: "" }, n14 = {}, l10 = 0, s12 = 0, a20 = new Uint8Array(16 * 1024), h20 = 0, o10 = (v15) => {
          let g16 = h20 + v15.length;
          if (g16 > a20.length) {
            let u17 = new Uint8Array(g16 * 2);
            u17.set(a20), a20 = u17;
          }
          a20.set(v15, h20), h20 += v15.length;
          let d20 = 0;
          for (; d20 + 4 <= h20; ) {
            let u17 = lt(a20, d20);
            if (d20 + 4 + u17 > h20) break;
            d20 += 4, I12(a20.subarray(d20, d20 + u17)), d20 += u17;
          }
          d20 > 0 && (a20.copyWithin(0, d20, h20), h20 -= d20);
        }, w13 = (v15) => {
          r9.didClose = true, v15 && (r9.reason = ": " + (v15.message || v15));
          let g16 = "The service was stopped" + r9.reason;
          for (let d20 in n14) n14[d20](g16, null);
          n14 = {};
        }, m23 = (v15, g16, d20) => {
          if (r9.didClose) return d20("The service is no longer running" + r9.reason, null);
          let u17 = l10++;
          n14[u17] = ($6, A15) => {
            try {
              d20($6, A15);
            } finally {
              v15 && v15.unref();
            }
          }, v15 && v15.ref(), e2.writeToStdin(Je({ id: u17, isRequest: true, value: g16 }));
        }, x22 = (v15, g16) => {
          if (r9.didClose) throw new Error("The service is no longer running" + r9.reason);
          e2.writeToStdin(Je({ id: v15, isRequest: false, value: g16 }));
        }, N12 = async (v15, g16) => {
          try {
            if (g16.command === "ping") {
              x22(v15, {});
              return;
            }
            if (typeof g16.key == "number") {
              let d20 = t[g16.key];
              if (!d20) return;
              let u17 = d20[g16.command];
              if (u17) {
                await u17(v15, g16);
                return;
              }
            }
            throw new Error("Invalid command: " + g16.command);
          } catch (d20) {
            let u17 = [fe2(d20, e2, null, void 0, "")];
            try {
              x22(v15, { errors: u17 });
            } catch {
            }
          }
        }, _22 = true, I12 = (v15) => {
          if (_22) {
            _22 = false;
            let d20 = String.fromCharCode(...v15);
            if (d20 !== "0.24.0") throw new Error(`Cannot start service: Host version "0.24.0" does not match binary version ${J7(d20)}`);
            return;
          }
          let g16 = It(v15);
          if (g16.isRequest) N12(g16.id, g16.value);
          else {
            let d20 = n14[g16.id];
            delete n14[g16.id], g16.value.error ? d20(g16.value.error, {}) : d20(null, g16.value);
          }
        };
        return { readFromStdout: o10, afterClose: w13, service: { buildOrContext: ({ callName: v15, refs: g16, options: d20, isTTY: u17, defaultWD: $6, callback: A15 }) => {
          let D8 = 0, P11 = s12++, f15 = {}, c16 = { ref() {
            ++D8 === 1 && g16 && g16.ref();
          }, unref() {
            --D8 === 0 && (delete t[P11], g16 && g16.unref());
          } };
          t[P11] = f15, c16.ref(), Jt(v15, P11, m23, x22, c16, e2, f15, d20, u17, $6, (b18, M6) => {
            try {
              A15(b18, M6);
            } finally {
              c16.unref();
            }
          });
        }, transform: ({ callName: v15, refs: g16, input: d20, options: u17, isTTY: $6, fs: A15, callback: D8 }) => {
          let P11 = dt(), f15 = (c16) => {
            try {
              if (typeof d20 != "string" && !(d20 instanceof Uint8Array)) throw new Error('The input to "transform" must be a string or a Uint8Array');
              let { flags: b18, mangleCache: M6 } = Vt(v15, u17, $6, Ke), C19 = { command: "transform", flags: b18, inputFS: c16 !== null, input: c16 !== null ? ne3(c16) : typeof d20 == "string" ? ne3(d20) : d20 };
              M6 && (C19.mangleCache = M6), m23(g16, C19, (j16, S16) => {
                if (j16) return D8(new Error(j16), null);
                let O11 = ye2(S16.errors, P11), k13 = ye2(S16.warnings, P11), E11 = 1, B10 = () => {
                  if (--E11 === 0) {
                    let T9 = { warnings: k13, code: S16.code, map: S16.map, mangleCache: void 0, legalComments: void 0 };
                    "legalComments" in S16 && (T9.legalComments = S16?.legalComments), S16.mangleCache && (T9.mangleCache = S16?.mangleCache), D8(null, T9);
                  }
                };
                if (O11.length > 0) return D8(xe3("Transform failed", O11, k13), null);
                S16.codeFS && (E11++, A15.readFile(S16.code, (T9, F5) => {
                  T9 !== null ? D8(T9, null) : (S16.code = F5, B10());
                })), S16.mapFS && (E11++, A15.readFile(S16.map, (T9, F5) => {
                  T9 !== null ? D8(T9, null) : (S16.map = F5, B10());
                })), B10();
              });
            } catch (b18) {
              let M6 = [];
              try {
                Te(M6, u17, {}, $6, Ke);
              } catch {
              }
              let C19 = fe2(b18, e2, P11, void 0, "");
              m23(g16, { command: "error", flags: M6, error: C19 }, () => {
                C19.detail = P11.load(C19.detail), D8(xe3("Transform failed", [C19], []), null);
              });
            }
          };
          if ((typeof d20 == "string" || d20 instanceof Uint8Array) && d20.length > 1024 * 1024) {
            let c16 = f15;
            f15 = () => A15.writeFile(d20, c16);
          }
          f15(null);
        }, formatMessages: ({ callName: v15, refs: g16, messages: d20, options: u17, callback: $6 }) => {
          if (!u17) throw new Error(`Missing second argument in ${v15}() call`);
          let A15 = {}, D8 = i14(u17, A15, "kind", y20), P11 = i14(u17, A15, "color", z11), f15 = i14(u17, A15, "terminalWidth", ce3);
          if (H5(u17, A15, `in ${v15}() call`), D8 === void 0) throw new Error(`Missing "kind" in ${v15}() call`);
          if (D8 !== "error" && D8 !== "warning") throw new Error(`Expected "kind" to be "error" or "warning" in ${v15}() call`);
          let c16 = { command: "format-msgs", messages: ae3(d20, "messages", null, "", f15), isWarning: D8 === "warning" };
          P11 !== void 0 && (c16.color = P11), f15 !== void 0 && (c16.terminalWidth = f15), m23(g16, c16, (b18, M6) => {
            if (b18) return $6(new Error(b18), null);
            $6(null, M6.messages);
          });
        }, analyzeMetafile: ({ callName: v15, refs: g16, metafile: d20, options: u17, callback: $6 }) => {
          u17 === void 0 && (u17 = {});
          let A15 = {}, D8 = i14(u17, A15, "color", z11), P11 = i14(u17, A15, "verbose", z11);
          H5(u17, A15, `in ${v15}() call`);
          let f15 = { command: "analyze-metafile", metafile: d20 };
          D8 !== void 0 && (f15.color = D8), P11 !== void 0 && (f15.verbose = P11), m23(g16, f15, (c16, b18) => {
            if (c16) return $6(new Error(c16), null);
            $6(null, b18.result);
          });
        } } };
      }
      function Jt(e2, t, r9, n14, l10, s12, a20, h20, o10, w13, m23) {
        let x22 = dt(), N12 = e2 === "context", _22 = (L8, W9) => {
          let q16 = [];
          try {
            Te(q16, h20, {}, o10, He);
          } catch {
          }
          let v15 = fe2(L8, s12, x22, void 0, W9);
          r9(l10, { command: "error", flags: q16, error: v15 }, () => {
            v15.detail = x22.load(v15.detail), m23(xe3(N12 ? "Context failed" : "Build failed", [v15], []), null);
          });
        }, I12;
        if (typeof h20 == "object") {
          let L8 = h20.plugins;
          if (L8 !== void 0) {
            if (!Array.isArray(L8)) return _22(new Error('"plugins" must be an array'), "");
            I12 = L8;
          }
        }
        if (I12 && I12.length > 0) {
          if (s12.isSync) return _22(new Error("Cannot use plugins in synchronous API calls"), "");
          Ht(t, r9, n14, l10, s12, a20, h20, I12, x22).then((L8) => {
            if (!L8.ok) return _22(L8.error, L8.pluginName);
            try {
              R8(L8.requestPlugins, L8.runOnEndCallbacks, L8.scheduleOnDisposeCallbacks);
            } catch (W9) {
              _22(W9, "");
            }
          }, (L8) => _22(L8, ""));
          return;
        }
        try {
          R8(null, (L8, W9) => W9([], []), () => {
          });
        } catch (L8) {
          _22(L8, "");
        }
        function R8(L8, W9, q16) {
          let v15 = s12.hasFS, { entries: g16, flags: d20, write: u17, stdinContents: $6, stdinResolveDir: A15, absWorkingDir: D8, nodePaths: P11, mangleCache: f15 } = Yt(e2, h20, o10, He, v15);
          if (u17 && !s12.hasFS) throw new Error('The "write" option is unavailable in this environment');
          let c16 = { command: "build", key: t, entries: g16, flags: d20, write: u17, stdinContents: $6, stdinResolveDir: A15, absWorkingDir: D8 || w13, nodePaths: P11, context: N12 };
          L8 && (c16.plugins = L8), f15 && (c16.mangleCache = f15);
          let b18 = (j16, S16) => {
            let O11 = { errors: ye2(j16.errors, x22), warnings: ye2(j16.warnings, x22), outputFiles: void 0, metafile: void 0, mangleCache: void 0 }, k13 = O11.errors.slice(), E11 = O11.warnings.slice();
            j16.outputFiles && (O11.outputFiles = j16.outputFiles.map(Qt)), j16.metafile && (O11.metafile = JSON.parse(j16.metafile)), j16.mangleCache && (O11.mangleCache = j16.mangleCache), j16.writeToStdout !== void 0 && console.log(we2(j16.writeToStdout).replace(/\n$/, "")), W9(O11, (B10, T9) => {
              if (k13.length > 0 || B10.length > 0) {
                let F5 = xe3("Build failed", k13.concat(B10), E11.concat(T9));
                return S16(F5, null, B10, T9);
              }
              S16(null, O11, B10, T9);
            });
          }, M6, C19;
          N12 && (a20["on-end"] = (j16, S16) => new Promise((O11) => {
            b18(S16, (k13, E11, B10, T9) => {
              let F5 = { errors: B10, warnings: T9 };
              C19 && C19(k13, E11), M6 = void 0, C19 = void 0, n14(j16, F5), O11();
            });
          })), r9(l10, c16, (j16, S16) => {
            if (j16) return m23(new Error(j16), null);
            if (!N12) return b18(S16, (E11, B10) => (q16(), m23(E11, B10)));
            if (S16.errors.length > 0) return m23(xe3("Context failed", S16.errors, S16.warnings), null);
            let O11 = false, k13 = { rebuild: () => (M6 || (M6 = new Promise((E11, B10) => {
              let T9;
              C19 = (Z3, V2) => {
                T9 || (T9 = () => Z3 ? B10(Z3) : E11(V2));
              };
              let F5 = () => {
                r9(l10, { command: "rebuild", key: t }, (V2, pe2) => {
                  V2 ? B10(new Error(V2)) : T9 ? T9() : F5();
                });
              };
              F5();
            })), M6), watch: (E11 = {}) => new Promise((B10, T9) => {
              if (!s12.hasFS) throw new Error('Cannot use the "watch" API in this environment');
              H5(E11, {}, "in watch() call"), r9(l10, { command: "watch", key: t }, (V2) => {
                V2 ? T9(new Error(V2)) : B10(void 0);
              });
            }), serve: (E11 = {}) => new Promise((B10, T9) => {
              if (!s12.hasFS) throw new Error('Cannot use the "serve" API in this environment');
              let F5 = {}, Z3 = i14(E11, F5, "port", ce3), V2 = i14(E11, F5, "host", y20), pe2 = i14(E11, F5, "servedir", y20), p20 = i14(E11, F5, "keyfile", y20), U6 = i14(E11, F5, "certfile", y20), ee3 = i14(E11, F5, "fallback", y20), ie3 = i14(E11, F5, "onRequest", at2);
              H5(E11, F5, "in serve() call");
              let G4 = { command: "serve", key: t, onRequest: !!ie3 };
              Z3 !== void 0 && (G4.port = Z3), V2 !== void 0 && (G4.host = V2), pe2 !== void 0 && (G4.servedir = pe2), p20 !== void 0 && (G4.keyfile = p20), U6 !== void 0 && (G4.certfile = U6), ee3 !== void 0 && (G4.fallback = ee3), r9(l10, G4, (be2, vt) => {
                if (be2) return T9(new Error(be2));
                ie3 && (a20["serve-request"] = (xt, $t) => {
                  ie3($t.args), n14(xt, {});
                }), B10(vt);
              });
            }), cancel: () => new Promise((E11) => {
              if (O11) return E11();
              r9(l10, { command: "cancel", key: t }, () => {
                E11();
              });
            }), dispose: () => new Promise((E11) => {
              if (O11) return E11();
              O11 = true, r9(l10, { command: "dispose", key: t }, () => {
                E11(), q16(), l10.unref();
              });
            }) };
            l10.ref(), m23(null, k13);
          });
        }
      }
      var Ht = async (e2, t, r9, n14, l10, s12, a20, h20, o10) => {
        let w13 = [], m23 = [], x22 = {}, N12 = {}, _22 = [], I12 = 0, R8 = 0, L8 = [], W9 = false;
        h20 = [...h20];
        for (let g16 of h20) {
          let d20 = {};
          if (typeof g16 != "object") throw new Error(`Plugin at index ${R8} must be an object`);
          let u17 = i14(g16, d20, "name", y20);
          if (typeof u17 != "string" || u17 === "") throw new Error(`Plugin at index ${R8} is missing a name`);
          try {
            let $6 = i14(g16, d20, "setup", at2);
            if (typeof $6 != "function") throw new Error("Plugin is missing a setup function");
            H5(g16, d20, `on plugin ${J7(u17)}`);
            let A15 = { name: u17, onStart: false, onEnd: false, onResolve: [], onLoad: [] };
            R8++;
            let P11 = $6({ initialOptions: a20, resolve: (f15, c16 = {}) => {
              if (!W9) throw new Error('Cannot call "resolve" before plugin setup has completed');
              if (typeof f15 != "string") throw new Error("The path to resolve must be a string");
              let b18 = /* @__PURE__ */ Object.create(null), M6 = i14(c16, b18, "pluginName", y20), C19 = i14(c16, b18, "importer", y20), j16 = i14(c16, b18, "namespace", y20), S16 = i14(c16, b18, "resolveDir", y20), O11 = i14(c16, b18, "kind", y20), k13 = i14(c16, b18, "pluginData", Me), E11 = i14(c16, b18, "with", te4);
              return H5(c16, b18, "in resolve() call"), new Promise((B10, T9) => {
                let F5 = { command: "resolve", path: f15, key: e2, pluginName: u17 };
                if (M6 != null && (F5.pluginName = M6), C19 != null && (F5.importer = C19), j16 != null && (F5.namespace = j16), S16 != null && (F5.resolveDir = S16), O11 != null) F5.kind = O11;
                else throw new Error('Must specify "kind" when calling "resolve"');
                k13 != null && (F5.pluginData = o10.store(k13)), E11 != null && (F5.with = Kt(E11, "with")), t(n14, F5, (Z3, V2) => {
                  Z3 !== null ? T9(new Error(Z3)) : B10({ errors: ye2(V2.errors, o10), warnings: ye2(V2.warnings, o10), path: V2.path, external: V2.external, sideEffects: V2.sideEffects, namespace: V2.namespace, suffix: V2.suffix, pluginData: o10.load(V2.pluginData) });
                });
              });
            }, onStart(f15) {
              let c16 = 'This error came from the "onStart" callback registered here:', b18 = Pe2(new Error(c16), l10, "onStart");
              w13.push({ name: u17, callback: f15, note: b18 }), A15.onStart = true;
            }, onEnd(f15) {
              let c16 = 'This error came from the "onEnd" callback registered here:', b18 = Pe2(new Error(c16), l10, "onEnd");
              m23.push({ name: u17, callback: f15, note: b18 }), A15.onEnd = true;
            }, onResolve(f15, c16) {
              let b18 = 'This error came from the "onResolve" callback registered here:', M6 = Pe2(new Error(b18), l10, "onResolve"), C19 = {}, j16 = i14(f15, C19, "filter", Oe), S16 = i14(f15, C19, "namespace", y20);
              if (H5(f15, C19, `in onResolve() call for plugin ${J7(u17)}`), j16 == null) throw new Error("onResolve() call is missing a filter");
              let O11 = I12++;
              x22[O11] = { name: u17, callback: c16, note: M6 }, A15.onResolve.push({ id: O11, filter: j16.source, namespace: S16 || "" });
            }, onLoad(f15, c16) {
              let b18 = 'This error came from the "onLoad" callback registered here:', M6 = Pe2(new Error(b18), l10, "onLoad"), C19 = {}, j16 = i14(f15, C19, "filter", Oe), S16 = i14(f15, C19, "namespace", y20);
              if (H5(f15, C19, `in onLoad() call for plugin ${J7(u17)}`), j16 == null) throw new Error("onLoad() call is missing a filter");
              let O11 = I12++;
              N12[O11] = { name: u17, callback: c16, note: M6 }, A15.onLoad.push({ id: O11, filter: j16.source, namespace: S16 || "" });
            }, onDispose(f15) {
              _22.push(f15);
            }, esbuild: l10.esbuild });
            P11 && await P11, L8.push(A15);
          } catch ($6) {
            return { ok: false, error: $6, pluginName: u17 };
          }
        }
        s12["on-start"] = async (g16, d20) => {
          o10.clear();
          let u17 = { errors: [], warnings: [] };
          await Promise.all(w13.map(async ({ name: $6, callback: A15, note: D8 }) => {
            try {
              let P11 = await A15();
              if (P11 != null) {
                if (typeof P11 != "object") throw new Error(`Expected onStart() callback in plugin ${J7($6)} to return an object`);
                let f15 = {}, c16 = i14(P11, f15, "errors", Y5), b18 = i14(P11, f15, "warnings", Y5);
                H5(P11, f15, `from onStart() callback in plugin ${J7($6)}`), c16 != null && u17.errors.push(...ae3(c16, "errors", o10, $6, void 0)), b18 != null && u17.warnings.push(...ae3(b18, "warnings", o10, $6, void 0));
              }
            } catch (P11) {
              u17.errors.push(fe2(P11, l10, o10, D8 && D8(), $6));
            }
          })), r9(g16, u17);
        }, s12["on-resolve"] = async (g16, d20) => {
          let u17 = {}, $6 = "", A15, D8;
          for (let P11 of d20.ids) try {
            ({ name: $6, callback: A15, note: D8 } = x22[P11]);
            let f15 = await A15({ path: d20.path, importer: d20.importer, namespace: d20.namespace, resolveDir: d20.resolveDir, kind: d20.kind, pluginData: o10.load(d20.pluginData), with: d20.with });
            if (f15 != null) {
              if (typeof f15 != "object") throw new Error(`Expected onResolve() callback in plugin ${J7($6)} to return an object`);
              let c16 = {}, b18 = i14(f15, c16, "pluginName", y20), M6 = i14(f15, c16, "path", y20), C19 = i14(f15, c16, "namespace", y20), j16 = i14(f15, c16, "suffix", y20), S16 = i14(f15, c16, "external", z11), O11 = i14(f15, c16, "sideEffects", z11), k13 = i14(f15, c16, "pluginData", Me), E11 = i14(f15, c16, "errors", Y5), B10 = i14(f15, c16, "warnings", Y5), T9 = i14(f15, c16, "watchFiles", Y5), F5 = i14(f15, c16, "watchDirs", Y5);
              H5(f15, c16, `from onResolve() callback in plugin ${J7($6)}`), u17.id = P11, b18 != null && (u17.pluginName = b18), M6 != null && (u17.path = M6), C19 != null && (u17.namespace = C19), j16 != null && (u17.suffix = j16), S16 != null && (u17.external = S16), O11 != null && (u17.sideEffects = O11), k13 != null && (u17.pluginData = o10.store(k13)), E11 != null && (u17.errors = ae3(E11, "errors", o10, $6, void 0)), B10 != null && (u17.warnings = ae3(B10, "warnings", o10, $6, void 0)), T9 != null && (u17.watchFiles = je(T9, "watchFiles")), F5 != null && (u17.watchDirs = je(F5, "watchDirs"));
              break;
            }
          } catch (f15) {
            u17 = { id: P11, errors: [fe2(f15, l10, o10, D8 && D8(), $6)] };
            break;
          }
          r9(g16, u17);
        }, s12["on-load"] = async (g16, d20) => {
          let u17 = {}, $6 = "", A15, D8;
          for (let P11 of d20.ids) try {
            ({ name: $6, callback: A15, note: D8 } = N12[P11]);
            let f15 = await A15({ path: d20.path, namespace: d20.namespace, suffix: d20.suffix, pluginData: o10.load(d20.pluginData), with: d20.with });
            if (f15 != null) {
              if (typeof f15 != "object") throw new Error(`Expected onLoad() callback in plugin ${J7($6)} to return an object`);
              let c16 = {}, b18 = i14(f15, c16, "pluginName", y20), M6 = i14(f15, c16, "contents", st), C19 = i14(f15, c16, "resolveDir", y20), j16 = i14(f15, c16, "pluginData", Me), S16 = i14(f15, c16, "loader", y20), O11 = i14(f15, c16, "errors", Y5), k13 = i14(f15, c16, "warnings", Y5), E11 = i14(f15, c16, "watchFiles", Y5), B10 = i14(f15, c16, "watchDirs", Y5);
              H5(f15, c16, `from onLoad() callback in plugin ${J7($6)}`), u17.id = P11, b18 != null && (u17.pluginName = b18), M6 instanceof Uint8Array ? u17.contents = M6 : M6 != null && (u17.contents = ne3(M6)), C19 != null && (u17.resolveDir = C19), j16 != null && (u17.pluginData = o10.store(j16)), S16 != null && (u17.loader = S16), O11 != null && (u17.errors = ae3(O11, "errors", o10, $6, void 0)), k13 != null && (u17.warnings = ae3(k13, "warnings", o10, $6, void 0)), E11 != null && (u17.watchFiles = je(E11, "watchFiles")), B10 != null && (u17.watchDirs = je(B10, "watchDirs"));
              break;
            }
          } catch (f15) {
            u17 = { id: P11, errors: [fe2(f15, l10, o10, D8 && D8(), $6)] };
            break;
          }
          r9(g16, u17);
        };
        let q16 = (g16, d20) => d20([], []);
        m23.length > 0 && (q16 = (g16, d20) => {
          (async () => {
            let u17 = [], $6 = [];
            for (let { name: A15, callback: D8, note: P11 } of m23) {
              let f15, c16;
              try {
                let b18 = await D8(g16);
                if (b18 != null) {
                  if (typeof b18 != "object") throw new Error(`Expected onEnd() callback in plugin ${J7(A15)} to return an object`);
                  let M6 = {}, C19 = i14(b18, M6, "errors", Y5), j16 = i14(b18, M6, "warnings", Y5);
                  H5(b18, M6, `from onEnd() callback in plugin ${J7(A15)}`), C19 != null && (f15 = ae3(C19, "errors", o10, A15, void 0)), j16 != null && (c16 = ae3(j16, "warnings", o10, A15, void 0));
                }
              } catch (b18) {
                f15 = [fe2(b18, l10, o10, P11 && P11(), A15)];
              }
              if (f15) {
                u17.push(...f15);
                try {
                  g16.errors.push(...f15);
                } catch {
                }
              }
              if (c16) {
                $6.push(...c16);
                try {
                  g16.warnings.push(...c16);
                } catch {
                }
              }
            }
            d20(u17, $6);
          })();
        });
        let v15 = () => {
          for (let g16 of _22) setTimeout(() => g16(), 0);
        };
        return W9 = true, { ok: true, requestPlugins: L8, runOnEndCallbacks: q16, scheduleOnDisposeCallbacks: v15 };
      };
      function dt() {
        let e2 = /* @__PURE__ */ new Map(), t = 0;
        return { clear() {
          e2.clear();
        }, load(r9) {
          return e2.get(r9);
        }, store(r9) {
          if (r9 === void 0) return -1;
          let n14 = t++;
          return e2.set(n14, r9), n14;
        } };
      }
      function Pe2(e2, t, r9) {
        let n14, l10 = false;
        return () => {
          if (l10) return n14;
          l10 = true;
          try {
            let s12 = (e2.stack + "").split(`
`);
            s12.splice(1, 1);
            let a20 = ht(t, s12, r9);
            if (a20) return n14 = { text: e2.message, location: a20 }, n14;
          } catch {
          }
        };
      }
      function fe2(e2, t, r9, n14, l10) {
        let s12 = "Internal error", a20 = null;
        try {
          s12 = (e2 && e2.message || e2) + "";
        } catch {
        }
        try {
          a20 = ht(t, (e2.stack + "").split(`
`), "");
        } catch {
        }
        return { id: "", pluginName: l10, text: s12, location: a20, notes: n14 ? [n14] : [], detail: r9 ? r9.store(e2) : -1 };
      }
      function ht(e2, t, r9) {
        let n14 = "    at ";
        if (e2.readFileSync && !t[0].startsWith(n14) && t[1].startsWith(n14)) for (let l10 = 1; l10 < t.length; l10++) {
          let s12 = t[l10];
          if (s12.startsWith(n14)) for (s12 = s12.slice(n14.length); ; ) {
            let a20 = /^(?:new |async )?\S+ \((.*)\)$/.exec(s12);
            if (a20) {
              s12 = a20[1];
              continue;
            }
            if (a20 = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(s12), a20) {
              s12 = a20[1];
              continue;
            }
            if (a20 = /^(\S+):(\d+):(\d+)$/.exec(s12), a20) {
              let h20;
              try {
                h20 = e2.readFileSync(a20[1], "utf8");
              } catch {
                break;
              }
              let o10 = h20.split(/\r\n|\r|\n|\u2028|\u2029/)[+a20[2] - 1] || "", w13 = +a20[3] - 1, m23 = o10.slice(w13, w13 + r9.length) === r9 ? r9.length : 0;
              return { file: a20[1], namespace: "file", line: +a20[2], column: ne3(o10.slice(0, w13)).length, length: ne3(o10.slice(w13, w13 + m23)).length, lineText: o10 + `
` + t.slice(1).join(`
`), suggestion: "" };
            }
            break;
          }
        }
        return null;
      }
      function xe3(e2, t, r9) {
        let n14 = 5;
        e2 += t.length < 1 ? "" : ` with ${t.length} error${t.length < 2 ? "" : "s"}:` + t.slice(0, n14 + 1).map((s12, a20) => {
          if (a20 === n14) return `
...`;
          if (!s12.location) return `
error: ${s12.text}`;
          let { file: h20, line: o10, column: w13 } = s12.location, m23 = s12.pluginName ? `[plugin: ${s12.pluginName}] ` : "";
          return `
${h20}:${o10}:${w13}: ERROR: ${m23}${s12.text}`;
        }).join("");
        let l10 = new Error(e2);
        for (let [s12, a20] of [["errors", t], ["warnings", r9]]) Object.defineProperty(l10, s12, { configurable: true, enumerable: true, get: () => a20, set: (h20) => Object.defineProperty(l10, s12, { configurable: true, enumerable: true, value: h20 }) });
        return l10;
      }
      function ye2(e2, t) {
        for (let r9 of e2) r9.detail = t.load(r9.detail);
        return e2;
      }
      function Ge(e2, t, r9) {
        if (e2 == null) return null;
        let n14 = {}, l10 = i14(e2, n14, "file", y20), s12 = i14(e2, n14, "namespace", y20), a20 = i14(e2, n14, "line", ce3), h20 = i14(e2, n14, "column", ce3), o10 = i14(e2, n14, "length", ce3), w13 = i14(e2, n14, "lineText", y20), m23 = i14(e2, n14, "suggestion", y20);
        if (H5(e2, n14, t), w13) {
          let x22 = w13.slice(0, (h20 && h20 > 0 ? h20 : 0) + (o10 && o10 > 0 ? o10 : 0) + (r9 && r9 > 0 ? r9 : 80));
          !/[\x7F-\uFFFF]/.test(x22) && !/\n/.test(w13) && (w13 = x22);
        }
        return { file: l10 || "", namespace: s12 || "", line: a20 || 0, column: h20 || 0, length: o10 || 0, lineText: w13 || "", suggestion: m23 || "" };
      }
      function ae3(e2, t, r9, n14, l10) {
        let s12 = [], a20 = 0;
        for (let h20 of e2) {
          let o10 = {}, w13 = i14(h20, o10, "id", y20), m23 = i14(h20, o10, "pluginName", y20), x22 = i14(h20, o10, "text", y20), N12 = i14(h20, o10, "location", Xe), _22 = i14(h20, o10, "notes", Y5), I12 = i14(h20, o10, "detail", Me), R8 = `in element ${a20} of "${t}"`;
          H5(h20, o10, R8);
          let L8 = [];
          if (_22) for (let W9 of _22) {
            let q16 = {}, v15 = i14(W9, q16, "text", y20), g16 = i14(W9, q16, "location", Xe);
            H5(W9, q16, R8), L8.push({ text: v15 || "", location: Ge(g16, R8, l10) });
          }
          s12.push({ id: w13 || "", pluginName: m23 || n14, text: x22 || "", location: Ge(N12, R8, l10), notes: L8, detail: r9 ? r9.store(I12) : -1 }), a20++;
        }
        return s12;
      }
      function je(e2, t) {
        let r9 = [];
        for (let n14 of e2) {
          if (typeof n14 != "string") throw new Error(`${J7(t)} must be an array of strings`);
          r9.push(n14);
        }
        return r9;
      }
      function Kt(e2, t) {
        let r9 = /* @__PURE__ */ Object.create(null);
        for (let n14 in e2) {
          let l10 = e2[n14];
          if (typeof l10 != "string") throw new Error(`key ${J7(n14)} in object ${J7(t)} must be a string`);
          r9[n14] = l10;
        }
        return r9;
      }
      function Qt({ path: e2, contents: t, hash: r9 }) {
        let n14 = null;
        return { path: e2, contents: t, hash: r9, get text() {
          let l10 = this.contents;
          return (n14 === null || l10 !== t) && (t = l10, n14 = we2(l10)), n14;
        } };
      }
      var oe4 = le("fs"), Ze = le("os"), re3 = le("path"), ge3 = __Process$.env.ESBUILD_BINARY_PATH || ge3, Xt = (e2) => !!e2 && e2 !== "/usr/bin/esbuild", et = "@esbuild/darwin-arm64", tt = "@esbuild/darwin-x64", De2 = { "win32 arm64 LE": "@esbuild/win32-arm64", "win32 ia32 LE": "@esbuild/win32-ia32", "win32 x64 LE": "@esbuild/win32-x64" }, Ce = { "aix ppc64 BE": "@esbuild/aix-ppc64", "android arm64 LE": "@esbuild/android-arm64", "darwin arm64 LE": "@esbuild/darwin-arm64", "darwin x64 LE": "@esbuild/darwin-x64", "freebsd arm64 LE": "@esbuild/freebsd-arm64", "freebsd x64 LE": "@esbuild/freebsd-x64", "linux arm LE": "@esbuild/linux-arm", "linux arm64 LE": "@esbuild/linux-arm64", "linux ia32 LE": "@esbuild/linux-ia32", "linux mips64el LE": "@esbuild/linux-mips64el", "linux ppc64 LE": "@esbuild/linux-ppc64", "linux riscv64 LE": "@esbuild/linux-riscv64", "linux s390x BE": "@esbuild/linux-s390x", "linux x64 LE": "@esbuild/linux-x64", "linux loong64 LE": "@esbuild/linux-loong64", "netbsd x64 LE": "@esbuild/netbsd-x64", "openbsd arm64 LE": "@esbuild/openbsd-arm64", "openbsd x64 LE": "@esbuild/openbsd-x64", "sunos x64 LE": "@esbuild/sunos-x64" }, rt = { "android arm LE": "@esbuild/android-arm", "android x64 LE": "@esbuild/android-x64" };
      function Gt() {
        let e2, t, r9 = false, n14 = `${__Process$.platform} ${Ze.arch()} ${Ze.endianness()}`;
        if (n14 in De2) e2 = De2[n14], t = "esbuild.exe";
        else if (n14 in Ce) e2 = Ce[n14], t = "bin/esbuild";
        else if (n14 in rt) e2 = rt[n14], t = "bin/esbuild", r9 = true;
        else throw new Error(`Unsupported platform: ${n14}`);
        return { pkg: e2, subpath: t, isWASM: r9 };
      }
      function Zt() {
        let e2 = __rResolve$("esbuild"), t = re3.dirname(re3.dirname(re3.dirname(e2)));
        if (re3.basename(t) === "node_modules") {
          for (let r9 in Ce) try {
            let n14 = Ce[r9];
            if (oe4.existsSync(re3.join(t, n14))) return n14;
          } catch {
          }
          for (let r9 in De2) try {
            let n14 = De2[r9];
            if (oe4.existsSync(re3.join(t, n14))) return n14;
          } catch {
          }
        }
        return null;
      }
      function er(e2, t) {
        let r9 = re3.dirname(__rResolve$("esbuild"));
        return re3.join(r9, `downloaded-${e2.replace("/", "-")}-${re3.basename(t)}`);
      }
      function tr() {
        if (Xt(ge3)) if (!oe4.existsSync(ge3)) console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ge3}`);
        else return { binPath: ge3, isWASM: false };
        let { pkg: e2, subpath: t, isWASM: r9 } = Gt(), n14;
        try {
          n14 = __rResolve$(`${e2}/${t}`);
        } catch (l10) {
          if (n14 = er(e2, t), !oe4.existsSync(n14)) {
            try {
              __rResolve$(e2);
            } catch {
              let s12 = Zt();
              if (s12) {
                let a20 = `
Specifically the "${s12}" package is present but this platform
needs the "${e2}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
                throw (e2 === tt && s12 === et || e2 === et && s12 === tt) && (a20 = `
Specifically the "${s12}" package is present but this platform
needs the "${e2}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`), new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${a20}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
              }
              throw new Error(`The package "${e2}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
            }
            throw l10;
          }
        }
        if (/\.zip\//.test(n14)) {
          let l10;
          try {
            l10 = (Ve(), Ot(Ye));
          } catch {
          }
          if (l10) {
            let s12 = l10.getPackageInformation(l10.topLevel).packageLocation, a20 = re3.join(s12, "node_modules", ".cache", "esbuild", `pnpapi-${e2.replace("/", "-")}-0.24.0-${re3.basename(t)}`);
            return oe4.existsSync(a20) || (oe4.mkdirSync(re3.dirname(a20), { recursive: true }), oe4.copyFileSync(n14, a20), oe4.chmodSync(a20, 493)), { binPath: a20, isWASM: r9 };
          }
        }
        return { binPath: n14, isWASM: r9 };
      }
      var mt = le("child_process"), rr = le("crypto"), Ne = le("path"), de3 = le("fs"), nr = le("os"), ir = le("tty"), Q3;
      if (__Process$.env.ESBUILD_WORKER_THREADS !== "0") {
        try {
          Q3 = le("worker_threads");
        } catch {
        }
        let [e2, t] = __Process$.versions.node.split(".");
        (+e2 < 12 || +e2 == 12 && +t < 17 || +e2 == 13 && +t < 13) && (Q3 = void 0);
      }
      var nt, ke = ((nt = Q3?.workerData) == null ? void 0 : nt.esbuildVersion) === "0.24.0", pt = () => {
        if (!ge3 && (Ne.basename("/_virtual/esm.sh/v135/esbuild@0.24.0/denonext/esbuild.mjs") !== "main.js" || Ne.basename("/_virtual/esm.sh/v135/esbuild@0.24.0/denonext") !== "lib")) throw new Error(`The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (/_virtual/esm.sh/v135/esbuild@0.24.0/denonext/esbuild.mjs) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`);
        {
          let { binPath: e2, isWASM: t } = tr();
          return t ? ["node", [e2]] : [e2, []];
        }
      }, $e = () => ir.isatty(2), lr = { readFile(e2, t) {
        try {
          let r9 = de3.readFileSync(e2, "utf8");
          try {
            de3.unlinkSync(e2);
          } catch {
          }
          t(null, r9);
        } catch (r9) {
          t(r9, null);
        }
      }, writeFile(e2, t) {
        try {
          let r9 = gt();
          de3.writeFileSync(r9, e2), t(r9);
        } catch {
          t(null);
        }
      } }, ar = { readFile(e2, t) {
        try {
          de3.readFile(e2, "utf8", (r9, n14) => {
            try {
              de3.unlink(e2, () => t(r9, n14));
            } catch {
              t(r9, n14);
            }
          });
        } catch (r9) {
          t(r9, null);
        }
      }, writeFile(e2, t) {
        try {
          let r9 = gt();
          de3.writeFile(r9, e2, (n14) => t(n14 !== null ? null : r9));
        } catch {
          t(null);
        }
      } }, or = "0.24.0", sr = (e2) => me2().build(e2), ur = (e2) => me2().context(e2), fr = (e2, t) => me2().transform(e2, t), cr2 = (e2, t) => me2().formatMessages(e2, t), dr = (e2, t) => me2().analyzeMetafile(e2, t), hr = (e2) => {
        if (Q3 && !ke) return X5 || (X5 = _e(Q3)), X5.buildSync(e2);
        let t;
        return Fe2((r9) => r9.buildOrContext({ callName: "buildSync", refs: null, options: e2, isTTY: $e(), defaultWD: he3, callback: (n14, l10) => {
          if (n14) throw n14;
          t = l10;
        } })), t;
      }, mr2 = (e2, t) => {
        if (Q3 && !ke) return X5 || (X5 = _e(Q3)), X5.transformSync(e2, t);
        let r9;
        return Fe2((n14) => n14.transform({ callName: "transformSync", refs: null, input: e2, options: t || {}, isTTY: $e(), fs: lr, callback: (l10, s12) => {
          if (l10) throw l10;
          r9 = s12;
        } })), r9;
      }, pr2 = (e2, t) => {
        if (Q3 && !ke) return X5 || (X5 = _e(Q3)), X5.formatMessagesSync(e2, t);
        let r9;
        return Fe2((n14) => n14.formatMessages({ callName: "formatMessagesSync", refs: null, messages: e2, options: t, callback: (l10, s12) => {
          if (l10) throw l10;
          r9 = s12;
        } })), r9;
      }, gr = (e2, t) => {
        if (Q3 && !ke) return X5 || (X5 = _e(Q3)), X5.analyzeMetafileSync(e2, t);
        let r9;
        return Fe2((n14) => n14.analyzeMetafile({ callName: "analyzeMetafileSync", refs: null, metafile: typeof e2 == "string" ? e2 : JSON.stringify(e2), options: t, callback: (l10, s12) => {
          if (l10) throw l10;
          r9 = s12;
        } })), r9;
      }, wr = () => (Le && Le(), X5 && X5.stop(), Promise.resolve()), Re3 = false, yr = (e2) => {
        if (e2 = qt(e2 || {}), e2.wasmURL) throw new Error('The "wasmURL" option only works in the browser');
        if (e2.wasmModule) throw new Error('The "wasmModule" option only works in the browser');
        if (e2.worker) throw new Error('The "worker" option only works in the browser');
        if (Re3) throw new Error('Cannot call "initialize" more than once');
        return me2(), Re3 = true, Promise.resolve();
      }, he3 = __Process$.cwd(), ve, Le, me2 = () => {
        if (ve) return ve;
        let [e2, t] = pt(), r9 = mt.spawn(e2, t.concat("--service=0.24.0", "--ping"), { windowsHide: true, stdio: ["pipe", "pipe", "inherit"], cwd: he3 }), { readFromStdout: n14, afterClose: l10, service: s12 } = ct({ writeToStdin(m23) {
          r9.stdin.write(m23, (x22) => {
            x22 && l10(x22);
          });
        }, readFileSync: de3.readFileSync, isSync: false, hasFS: true, esbuild: Ee2 });
        r9.stdin.on("error", l10), r9.on("error", l10);
        let a20 = r9.stdin, h20 = r9.stdout;
        h20.on("data", n14), h20.on("end", l10), Le = () => {
          a20.destroy(), h20.destroy(), r9.kill(), Re3 = false, ve = void 0, Le = void 0;
        };
        let o10 = 0;
        r9.unref(), a20.unref && a20.unref(), h20.unref && h20.unref();
        let w13 = { ref() {
          ++o10 === 1 && r9.ref();
        }, unref() {
          --o10 === 0 && r9.unref();
        } };
        return ve = { build: (m23) => new Promise((x22, N12) => {
          s12.buildOrContext({ callName: "build", refs: w13, options: m23, isTTY: $e(), defaultWD: he3, callback: (_22, I12) => _22 ? N12(_22) : x22(I12) });
        }), context: (m23) => new Promise((x22, N12) => s12.buildOrContext({ callName: "context", refs: w13, options: m23, isTTY: $e(), defaultWD: he3, callback: (_22, I12) => _22 ? N12(_22) : x22(I12) })), transform: (m23, x22) => new Promise((N12, _22) => s12.transform({ callName: "transform", refs: w13, input: m23, options: x22 || {}, isTTY: $e(), fs: ar, callback: (I12, R8) => I12 ? _22(I12) : N12(R8) })), formatMessages: (m23, x22) => new Promise((N12, _22) => s12.formatMessages({ callName: "formatMessages", refs: w13, messages: m23, options: x22, callback: (I12, R8) => I12 ? _22(I12) : N12(R8) })), analyzeMetafile: (m23, x22) => new Promise((N12, _22) => s12.analyzeMetafile({ callName: "analyzeMetafile", refs: w13, metafile: typeof m23 == "string" ? m23 : JSON.stringify(m23), options: x22, callback: (I12, R8) => I12 ? _22(I12) : N12(R8) })) }, ve;
      }, Fe2 = (e2) => {
        let [t, r9] = pt(), n14 = new Uint8Array(), { readFromStdout: l10, afterClose: s12, service: a20 } = ct({ writeToStdin(o10) {
          if (n14.length !== 0) throw new Error("Must run at most one command");
          n14 = o10;
        }, isSync: true, hasFS: true, esbuild: Ee2 });
        e2(a20);
        let h20 = mt.execFileSync(t, r9.concat("--service=0.24.0"), { cwd: he3, windowsHide: true, input: n14, maxBuffer: +__Process$.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024 });
        l10(h20), s12(null);
      }, gt = () => Ne.join(nr.tmpdir(), `esbuild-${rr.randomBytes(32).toString("hex")}`), X5 = null, _e = (e2) => {
        let { port1: t, port2: r9 } = new e2.MessageChannel(), n14 = new e2.Worker("/_virtual/esm.sh/v135/esbuild@0.24.0/denonext/esbuild.mjs", { workerData: { workerPort: r9, defaultWD: he3, esbuildVersion: "0.24.0" }, transferList: [r9], execArgv: [] }), l10 = 0, s12 = (w13) => {
          let m23 = new Error(`Build failed with 1 error:
error: ${w13}`), x22 = [{ id: "", pluginName: "", text: w13, location: null, notes: [], detail: void 0 }];
          return m23.errors = x22, m23.warnings = [], m23;
        }, a20 = (w13) => {
          if (!w13) return;
          let m23 = w13.plugins;
          if (m23 && m23.length > 0) throw s12("Cannot use plugins in synchronous API calls");
        }, h20 = (w13, m23) => {
          for (let x22 in m23) w13[x22] = m23[x22];
        }, o10 = (w13, m23) => {
          let x22 = l10++, N12 = new SharedArrayBuffer(8), _22 = new Int32Array(N12), I12 = { sharedBuffer: N12, id: x22, command: w13, args: m23 };
          n14.postMessage(I12);
          let R8 = Atomics.wait(_22, 0, 0);
          if (R8 !== "ok" && R8 !== "not-equal") throw new Error("Internal error: Atomics.wait() failed: " + R8);
          let { message: { id: L8, resolve: W9, reject: q16, properties: v15 } } = e2.receiveMessageOnPort(t);
          if (x22 !== L8) throw new Error(`Internal error: Expected id ${x22} but got id ${L8}`);
          if (q16) throw h20(q16, v15), q16;
          return W9;
        };
        return n14.unref(), { buildSync(w13) {
          return a20(w13), o10("build", [w13]);
        }, transformSync(w13, m23) {
          return o10("transform", [w13, m23]);
        }, formatMessagesSync(w13, m23) {
          return o10("formatMessages", [w13, m23]);
        }, analyzeMetafileSync(w13, m23) {
          return o10("analyzeMetafile", [w13, m23]);
        }, stop() {
          n14.terminate(), X5 = null;
        } };
      }, br = () => {
        let e2 = Q3.workerData.workerPort, t = Q3.parentPort, r9 = (n14) => {
          let l10 = {};
          if (n14 && typeof n14 == "object") for (let s12 in n14) l10[s12] = n14[s12];
          return l10;
        };
        try {
          let n14 = me2();
          he3 = Q3.workerData.defaultWD, t.on("message", (l10) => {
            (async () => {
              let { sharedBuffer: s12, id: a20, command: h20, args: o10 } = l10, w13 = new Int32Array(s12);
              try {
                switch (h20) {
                  case "build":
                    e2.postMessage({ id: a20, resolve: await n14.build(o10[0]) });
                    break;
                  case "transform":
                    e2.postMessage({ id: a20, resolve: await n14.transform(o10[0], o10[1]) });
                    break;
                  case "formatMessages":
                    e2.postMessage({ id: a20, resolve: await n14.formatMessages(o10[0], o10[1]) });
                    break;
                  case "analyzeMetafile":
                    e2.postMessage({ id: a20, resolve: await n14.analyzeMetafile(o10[0], o10[1]) });
                    break;
                  default:
                    throw new Error(`Invalid command: ${h20}`);
                }
              } catch (m23) {
                e2.postMessage({ id: a20, reject: m23, properties: r9(m23) });
              }
              Atomics.add(w13, 0, 1), Atomics.notify(w13, 0, 1 / 0);
            })();
          });
        } catch (n14) {
          t.on("message", (l10) => {
            let { sharedBuffer: s12, id: a20 } = l10, h20 = new Int32Array(s12);
            e2.postMessage({ id: a20, reject: n14, properties: r9(n14) }), Atomics.add(h20, 0, 1), Atomics.notify(h20, 0, 1 / 0);
          });
        }
      };
      ke && br();
      var vr2 = Ee2;
    });
    se = {};
    We(se, { analyzeMetafile: () => xr, analyzeMetafileSync: () => $r, build: () => Er, buildSync: () => kr, context: () => Sr, default: () => Tr, formatMessages: () => Ar, formatMessagesSync: () => Pr, initialize: () => jr, stop: () => Mr, transform: () => Or, transformSync: () => Dr, version: () => Cr });
    bt = qe(ze());
    ue(se, qe(ze()));
    ({ analyzeMetafile: xr, analyzeMetafileSync: $r, build: Er, buildSync: kr, context: Sr, formatMessages: Ar, formatMessagesSync: Pr, initialize: jr, stop: Mr, transform: Or, transformSync: Dr, version: Cr } = bt);
    ({ default: yt, ...Lr } = bt);
    Tr = yt !== void 0 ? yt : Lr;
  }
});

// https://esm.sh/esbuild@0.24.0
var init_esbuild_0_24 = __esm({
  "https://esm.sh/esbuild@0.24.0"() {
    init_esbuild();
    init_esbuild();
  }
});

// dist/node/constants.js
import path, { resolve } from "node:path";
import { fileURLToPath } from "node:url";
import { readFileSync } from "node:fs";
var version, CSS_LANGS_RE, FS_PREFIX, CLIENT_PUBLIC_PATH, ENV_PUBLIC_PATH, VITE_PACKAGE_DIR, CLIENT_ENTRY, ENV_ENTRY, CLIENT_DIR, KNOWN_ASSET_TYPES, DEFAULT_ASSETS_RE;
var init_constants = __esm({
  "dist/node/constants.js"() {
    ({ version } = JSON.parse(
      readFileSync(new URL("../../package.json", import.meta.url)).toString()
    ));
    CSS_LANGS_RE = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
    FS_PREFIX = `/@fs/`;
    CLIENT_PUBLIC_PATH = `/@vite/client`;
    ENV_PUBLIC_PATH = `/@vite/env`;
    VITE_PACKAGE_DIR = resolve(
      // import.meta.url is `dist/node/constants.js` after bundle
      fileURLToPath(import.meta.url),
      "../../.."
    );
    CLIENT_ENTRY = resolve(VITE_PACKAGE_DIR, "dist/client/client.mjs");
    ENV_ENTRY = resolve(VITE_PACKAGE_DIR, "dist/client/env.mjs");
    CLIENT_DIR = path.dirname(CLIENT_ENTRY);
    KNOWN_ASSET_TYPES = [
      // images
      "apng",
      "bmp",
      "png",
      "jpe?g",
      "jfif",
      "pjpeg",
      "pjp",
      "gif",
      "svg",
      "ico",
      "webp",
      "avif",
      // media
      "mp4",
      "webm",
      "ogg",
      "mp3",
      "wav",
      "flac",
      "aac",
      "opus",
      "mov",
      "m4a",
      "vtt",
      // fonts
      "woff2?",
      "eot",
      "ttf",
      "otf",
      // other
      "webmanifest",
      "pdf",
      "txt"
    ];
    DEFAULT_ASSETS_RE = new RegExp(
      `\\.(` + KNOWN_ASSET_TYPES.join("|") + `)(\\?.*)?$`
    );
  }
});

// ../rollup/wasm-node/bindings_wasm.js
import fs from "node:fs";
import { TextDecoder as TextDecoder2, TextEncoder as TextEncoder2 } from "node:util";
function getObject(idx) {
  return heap[idx];
}
function dropObject(idx) {
  if (idx < 132) return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}
function addHeapObject(obj) {
  if (heap_next === heap.length) heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127) break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function getDataViewMemory0() {
  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
    cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
  }
  return cachedDataViewMemory0;
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
function handleError(f15, args) {
  try {
    return f15.apply(this, args);
  } catch (e2) {
    wasm.__wbindgen_export_3(addHeapObject(e2));
  }
}
var module, imports, wasm, heap, heap_next, cachedTextDecoder, cachedUint8ArrayMemory0, WASM_VECTOR_LEN, cachedTextEncoder, encodeString, cachedDataViewMemory0, path2, bytes, wasmModule, wasmInstance, parse, xxhashBase64Url, xxhashBase36, xxhashBase16, __wbindgen_object_drop_ref, __wbg_crypto_1d1f22824a6a080c, __wbindgen_is_object, __wbg_process_4a72847cc503995b, __wbg_versions_f686565e586dd935, __wbg_node_104a2ff8d6ea03a2, __wbindgen_is_string, __wbg_require_cca90b1a94a0255b, __wbindgen_is_function, __wbindgen_string_new, __wbg_msCrypto_eb05e62b530a1508, __wbg_randomFillSync_5c9c955aa56b6049, __wbg_getRandomValues_3aa56aa6edec874c, __wbindgen_object_clone_ref, __wbg_newnoargs_1ede4bf2ebbaaf43, __wbg_call_a9ef466721e824f2, __wbg_self_bf91bf94d9e04084, __wbg_window_52dd9f07d03fd5f8, __wbg_globalThis_05c129bf37fcf1be, __wbg_global_3eca19bb09e9c484, __wbindgen_is_undefined, __wbg_call_3bfa248576352471, __wbg_buffer_ccaed51a635d8a2d, __wbg_newwithbyteoffsetandlength_7e3eb787208af730, __wbg_new_fec2611eb9180f95, __wbg_set_ec2fcf81bc573fd9, __wbg_length_9254c4bd3b9f23c4, __wbg_newwithlength_76462a666eca145f, __wbg_subarray_975a06f9dbd16995, __wbindgen_throw, __wbindgen_memory, __wasm, bindings_wasm_default;
var init_bindings_wasm = __esm({
  "../rollup/wasm-node/bindings_wasm.js"() {
    module = module || {};
    module.exports = module.exports || {};
    imports = {};
    imports["__wbindgen_placeholder__"] = module.exports;
    heap = new Array(128).fill(void 0);
    heap.push(void 0, null, true, false);
    heap_next = heap.length;
    cachedTextDecoder = new TextDecoder2("utf-8", { ignoreBOM: true, fatal: true });
    cachedTextDecoder.decode();
    cachedUint8ArrayMemory0 = null;
    WASM_VECTOR_LEN = 0;
    cachedTextEncoder = new TextEncoder2("utf-8");
    encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    cachedDataViewMemory0 = null;
    module.exports.parse = function(code, allow_return_outside_function, jsx) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.parse(retptr, ptr0, len0, allow_return_outside_function, jsx);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var v22 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_2(r0, r1 * 1, 1);
        return v22;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    };
    module.exports.xxhashBase64Url = function(input) {
      let deferred1_0;
      let deferred1_1;
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.xxhashBase64Url(retptr, addHeapObject(input));
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        deferred1_0 = r0;
        deferred1_1 = r1;
        return getStringFromWasm0(r0, r1);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);
      }
    };
    module.exports.xxhashBase36 = function(input) {
      let deferred1_0;
      let deferred1_1;
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.xxhashBase36(retptr, addHeapObject(input));
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        deferred1_0 = r0;
        deferred1_1 = r1;
        return getStringFromWasm0(r0, r1);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);
      }
    };
    module.exports.xxhashBase16 = function(input) {
      let deferred1_0;
      let deferred1_1;
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.xxhashBase16(retptr, addHeapObject(input));
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        deferred1_0 = r0;
        deferred1_1 = r1;
        return getStringFromWasm0(r0, r1);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);
      }
    };
    module.exports.__wbindgen_object_drop_ref = function(arg0) {
      takeObject(arg0);
    };
    module.exports.__wbg_crypto_1d1f22824a6a080c = function(arg0) {
      const ret = getObject(arg0).crypto;
      return addHeapObject(ret);
    };
    module.exports.__wbindgen_is_object = function(arg0) {
      const val = getObject(arg0);
      const ret = typeof val === "object" && val !== null;
      return ret;
    };
    module.exports.__wbg_process_4a72847cc503995b = function(arg0) {
      const ret = getObject(arg0).process;
      return addHeapObject(ret);
    };
    module.exports.__wbg_versions_f686565e586dd935 = function(arg0) {
      const ret = getObject(arg0).versions;
      return addHeapObject(ret);
    };
    module.exports.__wbg_node_104a2ff8d6ea03a2 = function(arg0) {
      const ret = getObject(arg0).node;
      return addHeapObject(ret);
    };
    module.exports.__wbindgen_is_string = function(arg0) {
      const ret = typeof getObject(arg0) === "string";
      return ret;
    };
    module.exports.__wbg_require_cca90b1a94a0255b = function() {
      return handleError(function() {
        const ret = module.require;
        return addHeapObject(ret);
      }, arguments);
    };
    module.exports.__wbindgen_is_function = function(arg0) {
      const ret = typeof getObject(arg0) === "function";
      return ret;
    };
    module.exports.__wbindgen_string_new = function(arg0, arg1) {
      const ret = getStringFromWasm0(arg0, arg1);
      return addHeapObject(ret);
    };
    module.exports.__wbg_msCrypto_eb05e62b530a1508 = function(arg0) {
      const ret = getObject(arg0).msCrypto;
      return addHeapObject(ret);
    };
    module.exports.__wbg_randomFillSync_5c9c955aa56b6049 = function() {
      return handleError(function(arg0, arg1) {
        getObject(arg0).randomFillSync(takeObject(arg1));
      }, arguments);
    };
    module.exports.__wbg_getRandomValues_3aa56aa6edec874c = function() {
      return handleError(function(arg0, arg1) {
        getObject(arg0).getRandomValues(getObject(arg1));
      }, arguments);
    };
    module.exports.__wbindgen_object_clone_ref = function(arg0) {
      const ret = getObject(arg0);
      return addHeapObject(ret);
    };
    module.exports.__wbg_newnoargs_1ede4bf2ebbaaf43 = function(arg0, arg1) {
      const ret = new Function(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    };
    module.exports.__wbg_call_a9ef466721e824f2 = function() {
      return handleError(function(arg0, arg1) {
        const ret = getObject(arg0).call(getObject(arg1));
        return addHeapObject(ret);
      }, arguments);
    };
    module.exports.__wbg_self_bf91bf94d9e04084 = function() {
      return handleError(function() {
        const ret = self.self;
        return addHeapObject(ret);
      }, arguments);
    };
    module.exports.__wbg_window_52dd9f07d03fd5f8 = function() {
      return handleError(function() {
        const ret = window.window;
        return addHeapObject(ret);
      }, arguments);
    };
    module.exports.__wbg_globalThis_05c129bf37fcf1be = function() {
      return handleError(function() {
        const ret = globalThis.globalThis;
        return addHeapObject(ret);
      }, arguments);
    };
    module.exports.__wbg_global_3eca19bb09e9c484 = function() {
      return handleError(function() {
        const ret = global.global;
        return addHeapObject(ret);
      }, arguments);
    };
    module.exports.__wbindgen_is_undefined = function(arg0) {
      const ret = getObject(arg0) === void 0;
      return ret;
    };
    module.exports.__wbg_call_3bfa248576352471 = function() {
      return handleError(function(arg0, arg1, arg2) {
        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
        return addHeapObject(ret);
      }, arguments);
    };
    module.exports.__wbg_buffer_ccaed51a635d8a2d = function(arg0) {
      const ret = getObject(arg0).buffer;
      return addHeapObject(ret);
    };
    module.exports.__wbg_newwithbyteoffsetandlength_7e3eb787208af730 = function(arg0, arg1, arg2) {
      const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
      return addHeapObject(ret);
    };
    module.exports.__wbg_new_fec2611eb9180f95 = function(arg0) {
      const ret = new Uint8Array(getObject(arg0));
      return addHeapObject(ret);
    };
    module.exports.__wbg_set_ec2fcf81bc573fd9 = function(arg0, arg1, arg2) {
      getObject(arg0).set(getObject(arg1), arg2 >>> 0);
    };
    module.exports.__wbg_length_9254c4bd3b9f23c4 = function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    };
    module.exports.__wbg_newwithlength_76462a666eca145f = function(arg0) {
      const ret = new Uint8Array(arg0 >>> 0);
      return addHeapObject(ret);
    };
    module.exports.__wbg_subarray_975a06f9dbd16995 = function(arg0, arg1, arg2) {
      const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
      return addHeapObject(ret);
    };
    module.exports.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
    module.exports.__wbindgen_memory = function() {
      const ret = wasm.memory;
      return addHeapObject(ret);
    };
    path2 = new URL(import.meta.resolve("./bindings_wasm_bg.wasm")).pathname;
    bytes = fs.readFileSync(path2);
    wasmModule = new WebAssembly.Module(bytes);
    wasmInstance = new WebAssembly.Instance(wasmModule, imports);
    wasm = wasmInstance.exports;
    module.exports.__wasm = wasm;
    ({
      parse,
      xxhashBase64Url,
      xxhashBase36,
      xxhashBase16,
      __wbindgen_object_drop_ref,
      __wbg_crypto_1d1f22824a6a080c,
      __wbindgen_is_object,
      __wbg_process_4a72847cc503995b,
      __wbg_versions_f686565e586dd935,
      __wbg_node_104a2ff8d6ea03a2,
      __wbindgen_is_string,
      __wbg_require_cca90b1a94a0255b,
      __wbindgen_is_function,
      __wbindgen_string_new,
      __wbg_msCrypto_eb05e62b530a1508,
      __wbg_randomFillSync_5c9c955aa56b6049,
      __wbg_getRandomValues_3aa56aa6edec874c,
      __wbindgen_object_clone_ref,
      __wbg_newnoargs_1ede4bf2ebbaaf43,
      __wbg_call_a9ef466721e824f2,
      __wbg_self_bf91bf94d9e04084,
      __wbg_window_52dd9f07d03fd5f8,
      __wbg_globalThis_05c129bf37fcf1be,
      __wbg_global_3eca19bb09e9c484,
      __wbindgen_is_undefined,
      __wbg_call_3bfa248576352471,
      __wbg_buffer_ccaed51a635d8a2d,
      __wbg_newwithbyteoffsetandlength_7e3eb787208af730,
      __wbg_new_fec2611eb9180f95,
      __wbg_set_ec2fcf81bc573fd9,
      __wbg_length_9254c4bd3b9f23c4,
      __wbg_newwithlength_76462a666eca145f,
      __wbg_subarray_975a06f9dbd16995,
      __wbindgen_throw,
      __wbindgen_memory,
      __wasm
    } = module.exports);
    bindings_wasm_default = module.exports;
  }
});

// ../rollup/native.js
var parseAsync;
var init_native = __esm({
  "../rollup/native.js"() {
    init_bindings_wasm();
    parseAsync = parse;
  }
});

// ../rollup/shared/parseAst.js
import { resolve as resolve2, basename, extname, dirname } from "node:path";
function rangeContains(range, index3) {
  return range.start <= index3 && index3 < range.end;
}
function getLocator(source, options2 = {}) {
  const { offsetLine = 0, offsetColumn = 0 } = options2;
  let start2 = 0;
  const ranges = source.split("\n").map((line, i15) => {
    const end = start2 + line.length + 1;
    const range = { start: start2, end, line: i15 };
    start2 = end;
    return range;
  });
  let i14 = 0;
  function locator(search, index3) {
    if (typeof search === "string") {
      search = source.indexOf(search, index3 ?? 0);
    }
    if (search === -1) return void 0;
    let range = ranges[i14];
    const d20 = search >= range.end ? 1 : -1;
    while (range) {
      if (rangeContains(range, search)) {
        return {
          line: offsetLine + range.line,
          column: offsetColumn + search - range.start,
          character: search
        };
      }
      i14 += d20;
      range = ranges[i14];
    }
  }
  return locator;
}
function locate(source, search, options2) {
  return getLocator(source, options2)(search, options2 && options2.startIndex);
}
function spaces(index3) {
  let result = "";
  while (index3--)
    result += " ";
  return result;
}
function tabsToSpaces(value2) {
  return value2.replace(/^\t+/, (match2) => match2.split("	").join("  "));
}
function getCodeFrame(source, line, column) {
  let lines = source.split("\n");
  if (line > lines.length)
    return "";
  const maxLineLength = Math.max(tabsToSpaces(lines[line - 1].slice(0, column)).length + MIN_CHARACTERS_SHOWN_AFTER_LOCATION + ELLIPSIS.length, LINE_TRUNCATE_LENGTH);
  const frameStart = Math.max(0, line - 3);
  let frameEnd = Math.min(line + 2, lines.length);
  lines = lines.slice(frameStart, frameEnd);
  while (!/\S/.test(lines[lines.length - 1])) {
    lines.pop();
    frameEnd -= 1;
  }
  const digits = String(frameEnd).length;
  return lines.map((sourceLine, index3) => {
    const isErrorLine = frameStart + index3 + 1 === line;
    let lineNumber = String(index3 + frameStart + 1);
    while (lineNumber.length < digits)
      lineNumber = ` ${lineNumber}`;
    let displayedLine = tabsToSpaces(sourceLine);
    if (displayedLine.length > maxLineLength) {
      displayedLine = `${displayedLine.slice(0, maxLineLength - ELLIPSIS.length)}${ELLIPSIS}`;
    }
    if (isErrorLine) {
      const indicator = spaces(digits + 2 + tabsToSpaces(sourceLine.slice(0, column)).length) + "^";
      return `${lineNumber}: ${displayedLine}
${indicator}`;
    }
    return `${lineNumber}: ${displayedLine}`;
  }).join("\n");
}
function isAbsolute(path7) {
  return ABSOLUTE_PATH_REGEX.test(path7);
}
function isRelative(path7) {
  return RELATIVE_PATH_REGEX.test(path7);
}
function normalize(path7) {
  return path7.replace(BACKSLASH_REGEX, "/");
}
function printQuotedStringList(list, verbs) {
  const isSingleItem = list.length <= 1;
  const quotedList = list.map((item) => `"${item}"`);
  let output = isSingleItem ? quotedList[0] : `${quotedList.slice(0, -1).join(", ")} and ${quotedList.slice(-1)[0]}`;
  if (verbs) {
    output += ` ${isSingleItem ? verbs[0] : verbs[1]}`;
  }
  return output;
}
function relative(from, to) {
  const fromParts = from.split(ANY_SLASH_REGEX).filter(Boolean);
  const toParts = to.split(ANY_SLASH_REGEX).filter(Boolean);
  if (fromParts[0] === ".")
    fromParts.shift();
  if (toParts[0] === ".")
    toParts.shift();
  while (fromParts[0] && toParts[0] && fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  while (toParts[0] === ".." && fromParts.length > 0) {
    toParts.shift();
    fromParts.pop();
  }
  while (fromParts.pop()) {
    toParts.unshift("..");
  }
  return toParts.join("/");
}
function getAliasName(id3) {
  const base = basename(id3);
  return base.slice(0, Math.max(0, base.length - extname(id3).length));
}
function relativeId(id3) {
  if (!isAbsolute(id3))
    return id3;
  return relative(resolve2(), id3);
}
function isPathFragment(name2) {
  return name2[0] === "/" || name2[0] === "." && (name2[1] === "/" || name2[1] === ".") || isAbsolute(name2);
}
function getImportPath(importerId, targetPath, stripJsExtension, ensureFileName) {
  while (targetPath.startsWith("../")) {
    targetPath = targetPath.slice(3);
    importerId = "_/" + importerId;
  }
  let relativePath = normalize(relative(dirname(importerId), targetPath));
  if (stripJsExtension && relativePath.endsWith(".js")) {
    relativePath = relativePath.slice(0, -3);
  }
  if (ensureFileName) {
    if (relativePath === "")
      return "../" + basename(targetPath);
    if (UPPER_DIR_REGEX.test(relativePath)) {
      return [...relativePath.split("/"), "..", basename(targetPath)].join("/");
    }
  }
  return relativePath ? relativePath.startsWith("..") ? relativePath : "./" + relativePath : ".";
}
function isValidUrl(url2) {
  try {
    new URL(url2);
  } catch {
    return false;
  }
  return true;
}
function getRollupUrl(snippet) {
  return `https://rollupjs.org/${snippet}`;
}
function addTrailingSlashIfMissed(url2) {
  if (!url2.endsWith("/")) {
    return url2 + "/";
  }
  return url2;
}
function error(base) {
  throw base instanceof Error ? base : getRollupError(base);
}
function getRollupError(base) {
  augmentLogMessage(base);
  const errorInstance = Object.assign(new Error(base.message), base);
  Object.defineProperty(errorInstance, "name", {
    value: "RollupError",
    writable: true
  });
  return errorInstance;
}
function augmentCodeLocation(properties, pos, source, id3) {
  if (typeof pos === "object") {
    const { line, column } = pos;
    properties.loc = { column, file: id3, line };
  } else {
    properties.pos = pos;
    const location2 = locate(source, pos, { offsetLine: 1 });
    if (!location2) {
      return;
    }
    const { line, column } = location2;
    properties.loc = { column, file: id3, line };
  }
  if (properties.frame === void 0) {
    const { line, column } = properties.loc;
    properties.frame = getCodeFrame(source, line, column);
  }
}
function augmentLogMessage(log) {
  if (!(log.plugin || log.loc) || log[symbolAugmented]) {
    return;
  }
  log[symbolAugmented] = true;
  let prefix = "";
  if (log.plugin) {
    prefix += `[plugin ${log.plugin}] `;
  }
  const id3 = log.id || log.loc?.file;
  if (id3) {
    const position = log.loc ? ` (${log.loc.line}:${log.loc.column})` : "";
    prefix += `${relativeId(id3)}${position}: `;
  }
  const oldMessage = log.message;
  log.message = prefix + log.message;
  tweakStackMessage(log, oldMessage);
}
function logAddonNotGenerated(message, hook, plugin2) {
  return {
    code: ADDON_ERROR,
    message: `Could not retrieve "${hook}". Check configuration of plugin "${plugin2}".
	Error Message: ${message}`
  };
}
function logAlreadyClosed() {
  return {
    code: ALREADY_CLOSED,
    message: 'Bundle is already closed, no more calls to "generate" or "write" are allowed.'
  };
}
function logAmbiguousExternalNamespaces(binding, reexportingModule, usedModule, sources) {
  return {
    binding,
    code: AMBIGUOUS_EXTERNAL_NAMESPACES,
    ids: sources,
    message: `Ambiguous external namespace resolution: "${relativeId(reexportingModule)}" re-exports "${binding}" from one of the external modules ${printQuotedStringList(sources.map((module3) => relativeId(module3)))}, guessing "${relativeId(usedModule)}".`,
    reexporter: reexportingModule
  };
}
function logAnonymousPluginCache() {
  return {
    code: ANONYMOUS_PLUGIN_CACHE,
    message: "A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey."
  };
}
function logAssetNotFinalisedForFileName(name2) {
  return {
    code: ASSET_NOT_FINALISED,
    message: `Plugin error - Unable to get file name for asset "${name2}". Ensure that the source is set and that generate is called first. If you reference assets via import.meta.ROLLUP_FILE_URL_<referenceId>, you need to either have set their source after "renderStart" or need to provide an explicit "fileName" when emitting them.`
  };
}
function logAssetReferenceIdNotFoundForSetSource(assetReferenceId) {
  return {
    code: ASSET_NOT_FOUND,
    message: `Plugin error - Unable to set the source for unknown asset "${assetReferenceId}".`
  };
}
function logAssetSourceAlreadySet(name2) {
  return {
    code: ASSET_SOURCE_ALREADY_SET,
    message: `Unable to set the source for asset "${name2}", source already set.`
  };
}
function logNoAssetSourceSet(assetName) {
  return {
    code: ASSET_SOURCE_MISSING,
    message: `Plugin error creating asset "${assetName}" - no asset source set.`
  };
}
function logBadLoader(id3) {
  return {
    code: BAD_LOADER,
    message: `Error loading "${relativeId(id3)}": plugin load hook should return a string, a { code, map } object, or nothing/null.`
  };
}
function logCannotCallNamespace(name2) {
  return {
    code: CANNOT_CALL_NAMESPACE,
    message: `Cannot call a namespace ("${name2}").`
  };
}
function logCannotEmitFromOptionsHook() {
  return {
    code: CANNOT_EMIT_FROM_OPTIONS_HOOK,
    message: `Cannot emit files or set asset sources in the "outputOptions" hook, use the "renderStart" hook instead.`
  };
}
function logChunkNotGeneratedForFileName(name2) {
  return {
    code: CHUNK_NOT_GENERATED,
    message: `Plugin error - Unable to get file name for emitted chunk "${name2}". You can only get file names once chunks have been generated after the "renderStart" hook.`
  };
}
function logChunkInvalid({ fileName, code }, { pos, message }) {
  const errorProperties = {
    code: CHUNK_INVALID,
    message: `Chunk "${fileName}" is not valid JavaScript: ${message}.`
  };
  augmentCodeLocation(errorProperties, pos, code, fileName);
  return errorProperties;
}
function logCircularDependency(cyclePath) {
  return {
    code: CIRCULAR_DEPENDENCY,
    ids: cyclePath,
    message: `Circular dependency: ${cyclePath.map(relativeId).join(" -> ")}`
  };
}
function logCircularReexport(exportName, exporter) {
  return {
    code: CIRCULAR_REEXPORT,
    exporter,
    message: `"${exportName}" cannot be exported from "${relativeId(exporter)}" as it is a reexport that references itself.`
  };
}
function logCyclicCrossChunkReexport(exportName, exporter, reexporter, importer, preserveModules) {
  return {
    code: CYCLIC_CROSS_CHUNK_REEXPORT,
    exporter,
    id: importer,
    message: `Export "${exportName}" of module "${relativeId(exporter)}" was reexported through module "${relativeId(reexporter)}" while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.
Either change the import in "${relativeId(importer)}" to point directly to the exporting module or ${preserveModules ? 'do not use "output.preserveModules"' : 'reconfigure "output.manualChunks"'} to ensure these modules end up in the same chunk.`,
    reexporter
  };
}
function logDeprecation(deprecation, urlSnippet, plugin2) {
  return {
    code: DEPRECATED_FEATURE,
    message: deprecation,
    url: getRollupUrl(urlSnippet),
    ...{}
  };
}
function logConstVariableReassignError() {
  return {
    code: CONST_REASSIGN,
    message: "Cannot reassign a variable declared with `const`"
  };
}
function logDuplicateArgumentNameError(name2) {
  return {
    code: DUPLICATE_ARGUMENT_NAME,
    message: `Duplicate argument name "${name2}"`
  };
}
function logDuplicateExportError(name2) {
  return { code: DUPLICATE_EXPORT, message: `Duplicate export "${name2}"` };
}
function logDuplicatePluginName(plugin2) {
  return {
    code: DUPLICATE_PLUGIN_NAME,
    message: `The plugin name ${plugin2} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`
  };
}
function logEmptyChunk(chunkName) {
  return {
    code: EMPTY_BUNDLE,
    message: `Generated an empty chunk: "${chunkName}".`,
    names: [chunkName]
  };
}
function logEval(id3) {
  return {
    code: EVAL,
    id: id3,
    message: `Use of eval in "${relativeId(id3)}" is strongly discouraged as it poses security risks and may cause issues with minification.`,
    url: getRollupUrl(URL_AVOIDING_EVAL)
  };
}
function logExternalSyntheticExports(id3, importer) {
  return {
    code: EXTERNAL_SYNTHETIC_EXPORTS,
    exporter: id3,
    message: `External "${id3}" cannot have "syntheticNamedExports" enabled (imported by "${relativeId(importer)}").`
  };
}
function logFileNameConflict(fileName) {
  return {
    code: FILE_NAME_CONFLICT,
    message: `The emitted file "${fileName}" overwrites a previously emitted file of the same name.`
  };
}
function logFileReferenceIdNotFoundForFilename(assetReferenceId) {
  return {
    code: FILE_NOT_FOUND,
    message: `Plugin error - Unable to get file name for unknown file "${assetReferenceId}".`
  };
}
function logFirstSideEffect(source, id3, { line, column }) {
  return {
    code: FIRST_SIDE_EFFECT,
    message: `First side effect in ${relativeId(id3)} is at (${line}:${column})
${getCodeFrame(source, line, column)}`
  };
}
function logIllegalIdentifierAsName(name2) {
  return {
    code: ILLEGAL_IDENTIFIER_AS_NAME,
    message: `Given name "${name2}" is not a legal JS identifier. If you need this, you can try "output.extend: true".`,
    url: getRollupUrl(URL_OUTPUT_EXTEND)
  };
}
function logIllegalImportReassignment(name2, importingId) {
  return {
    code: ILLEGAL_REASSIGNMENT,
    message: `Illegal reassignment of import "${name2}" in "${relativeId(importingId)}".`
  };
}
function logInconsistentImportAttributes(existingAttributes, newAttributes, source, importer) {
  return {
    code: INCONSISTENT_IMPORT_ATTRIBUTES,
    message: `Module "${relativeId(importer)}" tried to import "${relativeId(source)}" with ${formatAttributes(newAttributes)} attributes, but it was already imported elsewhere with ${formatAttributes(existingAttributes)} attributes. Please ensure that import attributes for the same module are always consistent.`
  };
}
function logInvalidAnnotation(comment3, id3, type) {
  return {
    code: INVALID_ANNOTATION,
    id: id3,
    message: `A comment

"${comment3}"

in "${relativeId(id3)}" contains an annotation that Rollup cannot interpret due to the position of the comment. The comment will be removed to avoid issues.`,
    url: getRollupUrl(type === "noSideEffects" ? URL_TREESHAKE_NOSIDEEFFECTS : URL_TREESHAKE_PURE)
  };
}
function logInputHookInOutputPlugin(pluginName, hookName) {
  return {
    code: INPUT_HOOK_IN_OUTPUT_PLUGIN,
    message: `The "${hookName}" hook used by the output plugin ${pluginName} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`
  };
}
function logCannotAssignModuleToChunk(moduleId, assignToAlias, currentAlias) {
  return {
    code: INVALID_CHUNK,
    message: `Cannot assign "${relativeId(moduleId)}" to the "${assignToAlias}" chunk as it is already in the "${currentAlias}" chunk.`
  };
}
function tweakStackMessage(error2, oldMessage) {
  if (!error2.stack) {
    return error2;
  }
  error2.stack = error2.stack.replace(oldMessage, error2.message);
  return error2;
}
function logInvalidExportOptionValue(optionValue) {
  return {
    code: INVALID_EXPORT_OPTION,
    message: `"output.exports" must be "default", "named", "none", "auto", or left unspecified (defaults to "auto"), received "${optionValue}".`,
    url: getRollupUrl(URL_OUTPUT_EXPORTS)
  };
}
function logIncompatibleExportOptionValue(optionValue, keys, entryModule) {
  return {
    code: INVALID_EXPORT_OPTION,
    message: `"${optionValue}" was specified for "output.exports", but entry module "${relativeId(entryModule)}" has the following exports: ${printQuotedStringList(keys)}`,
    url: getRollupUrl(URL_OUTPUT_EXPORTS)
  };
}
function logInternalIdCannotBeExternal(source, importer) {
  return {
    code: INVALID_EXTERNAL_ID,
    message: `"${source}" is imported as an external by "${relativeId(importer)}", but is already an existing non-external module id.`
  };
}
function logImportOptionsAreInvalid(importer) {
  return {
    code: INVALID_IMPORT_ATTRIBUTE,
    message: `Rollup could not statically analyze the options argument of a dynamic import in "${relativeId(importer)}". Dynamic import options need to be an object with a nested attributes object.`
  };
}
function logImportAttributeIsInvalid(importer) {
  return {
    code: INVALID_IMPORT_ATTRIBUTE,
    message: `Rollup could not statically analyze an import attribute of a dynamic import in "${relativeId(importer)}". Import attributes need to have string keys and values. The attribute will be removed.`
  };
}
function logInvalidLogPosition(plugin2) {
  return {
    code: INVALID_LOG_POSITION,
    message: `Plugin "${plugin2}" tried to add a file position to a log or warning. This is only supported in the "transform" hook at the moment and will be ignored.`
  };
}
function logInvalidOption(option, urlSnippet, explanation, value2) {
  return {
    code: INVALID_OPTION,
    message: `Invalid value ${value2 === void 0 ? "" : `${JSON.stringify(value2)} `}for option "${option}" - ${explanation}.`,
    url: getRollupUrl(urlSnippet)
  };
}
function logInvalidAddonPluginHook(hook, plugin2) {
  return {
    code: INVALID_PLUGIN_HOOK,
    hook,
    message: `Error running plugin hook "${hook}" for plugin "${plugin2}", expected a string, a function hook or an object with a "handler" string or function.`,
    plugin: plugin2
  };
}
function logInvalidFunctionPluginHook(hook, plugin2) {
  return {
    code: INVALID_PLUGIN_HOOK,
    hook,
    message: `Error running plugin hook "${hook}" for plugin "${plugin2}", expected a function hook or an object with a "handler" function.`,
    plugin: plugin2
  };
}
function logInvalidRollupPhaseForChunkEmission() {
  return {
    code: INVALID_ROLLUP_PHASE,
    message: `Cannot emit chunks after module loading has finished.`
  };
}
function logInvalidSetAssetSourceCall() {
  return {
    code: INVALID_SETASSETSOURCE,
    message: `setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook.`
  };
}
function logInvalidFormatForTopLevelAwait(id3, format2) {
  return {
    code: INVALID_TLA_FORMAT,
    id: id3,
    message: `Module format "${format2}" does not support top-level await. Use the "es" or "system" output formats rather.`
  };
}
function logMissingEntryExport(binding, exporter) {
  return {
    binding,
    code: MISSING_EXPORT,
    exporter,
    message: `Exported variable "${binding}" is not defined in "${relativeId(exporter)}".`,
    url: getRollupUrl(URL_NAME_IS_NOT_EXPORTED)
  };
}
function logMissingExport(binding, importingModule, exporter) {
  const isJson = extname(exporter) === ".json";
  return {
    binding,
    code: MISSING_EXPORT,
    exporter,
    id: importingModule,
    message: `"${binding}" is not exported by "${relativeId(exporter)}", imported by "${relativeId(importingModule)}".${isJson ? " (Note that you need @rollup/plugin-json to import JSON files)" : ""}`,
    url: getRollupUrl(URL_NAME_IS_NOT_EXPORTED)
  };
}
function logMissingGlobalName(externalId, guess) {
  return {
    code: MISSING_GLOBAL_NAME,
    id: externalId,
    message: `No name was provided for external module "${externalId}" in "output.globals" – guessing "${guess}".`,
    names: [guess],
    url: getRollupUrl(URL_OUTPUT_GLOBALS)
  };
}
function logImplicitDependantCannotBeExternal(unresolvedId, implicitlyLoadedBefore) {
  return {
    code: MISSING_IMPLICIT_DEPENDANT,
    message: `Module "${relativeId(unresolvedId)}" that should be implicitly loaded before "${relativeId(implicitlyLoadedBefore)}" cannot be external.`
  };
}
function logUnresolvedImplicitDependant(unresolvedId, implicitlyLoadedBefore) {
  return {
    code: MISSING_IMPLICIT_DEPENDANT,
    message: `Module "${relativeId(unresolvedId)}" that should be implicitly loaded before "${relativeId(implicitlyLoadedBefore)}" could not be resolved.`
  };
}
function logImplicitDependantIsNotIncluded(module3) {
  const implicitDependencies = [...module3.implicitlyLoadedBefore].map((dependency) => relativeId(dependency.id)).sort();
  return {
    code: MISSING_IMPLICIT_DEPENDANT,
    message: `Module "${relativeId(module3.id)}" that should be implicitly loaded before ${printQuotedStringList(implicitDependencies)} is not included in the module graph. Either it was not imported by an included module or only via a tree-shaken dynamic import, or no imported bindings were used and it had otherwise no side-effects.`
  };
}
function logMissingJsxExport(name2, exporter, importer) {
  return {
    code: MISSING_JSX_EXPORT,
    exporter,
    id: importer,
    message: `Export "${name2}" is not defined in module "${relativeId(exporter)}" even though it is needed in "${relativeId(importer)}" to provide JSX syntax. Please check your "jsx" option.`,
    names: [name2],
    url: getRollupUrl(URL_JSX)
  };
}
function logMissingNameOptionForIifeExport() {
  return {
    code: MISSING_NAME_OPTION_FOR_IIFE_EXPORT,
    message: `If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.`,
    url: getRollupUrl(URL_OUTPUT_NAME)
  };
}
function logMissingNameOptionForUmdExport() {
  return {
    code: MISSING_NAME_OPTION_FOR_IIFE_EXPORT,
    message: 'You must supply "output.name" for UMD bundles that have exports so that the exports are accessible in environments without a module loader.',
    url: getRollupUrl(URL_OUTPUT_NAME)
  };
}
function logMissingNodeBuiltins(externalBuiltins) {
  return {
    code: MISSING_NODE_BUILTINS,
    ids: externalBuiltins,
    message: `Creating a browser bundle that depends on Node.js built-in modules (${printQuotedStringList(externalBuiltins)}). You might need to include https://github.com/FredKSchott/rollup-plugin-polyfill-node`
  };
}
function logMissingFileOrDirOption() {
  return {
    code: MISSING_OPTION,
    message: 'You must specify "output.file" or "output.dir" for the build.',
    url: getRollupUrl(URL_OUTPUT_DIR)
  };
}
function logMixedExport(facadeModuleId, name2) {
  return {
    code: MIXED_EXPORTS,
    id: facadeModuleId,
    message: `Entry module "${relativeId(facadeModuleId)}" is using named and default exports together. Consumers of your bundle will have to use \`${name2 || "chunk"}.default\` to access the default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning.`,
    url: getRollupUrl(URL_OUTPUT_EXPORTS)
  };
}
function logModuleLevelDirective(directive2, id3) {
  return {
    code: MODULE_LEVEL_DIRECTIVE,
    id: id3,
    message: `Module level directives cause errors when bundled, "${directive2}" in "${relativeId(id3)}" was ignored.`
  };
}
function logNamespaceConflict(binding, reexportingModuleId, sources) {
  return {
    binding,
    code: NAMESPACE_CONFLICT,
    ids: sources,
    message: `Conflicting namespaces: "${relativeId(reexportingModuleId)}" re-exports "${binding}" from one of the modules ${printQuotedStringList(sources.map((moduleId) => relativeId(moduleId)))} (will be ignored).`,
    reexporter: reexportingModuleId
  };
}
function logNoTransformMapOrAstWithoutCode(pluginName) {
  return {
    code: NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE,
    message: `The plugin "${pluginName}" returned a "map" or "ast" without returning a "code". This will be ignored.`
  };
}
function logOptimizeChunkStatus(chunks, smallChunks, pointInTime) {
  return {
    code: OPTIMIZE_CHUNK_STATUS,
    message: `${pointInTime}, there are
${chunks} chunks, of which
${smallChunks} are below minChunkSize.`
  };
}
function logParseError(message, pos) {
  return { code: PARSE_ERROR, message, pos };
}
function logRedeclarationError(name2) {
  return {
    code: REDECLARATION_ERROR,
    message: `Identifier "${name2}" has already been declared`
  };
}
function logReservedNamespace(namespace2) {
  return {
    code: RESERVED_NAMESPACE,
    message: `You have overided reserved namespace "${namespace2}"`
  };
}
function logModuleParseError(error2, moduleId) {
  let message = error2.message.replace(/ \(\d+:\d+\)$/, "");
  if (moduleId.endsWith(".json")) {
    message += " (Note that you need @rollup/plugin-json to import JSON files)";
  } else if (!moduleId.endsWith(".js")) {
    message += " (Note that you need plugins to import files that are not JavaScript)";
  }
  return tweakStackMessage({
    cause: error2,
    code: PARSE_ERROR,
    id: moduleId,
    message,
    stack: error2.stack
  }, error2.message);
}
function logPluginError(error2, plugin2, { hook, id: id3 } = {}) {
  const code = error2.code;
  if (!error2.pluginCode && code != null && (typeof code !== "string" || !code.startsWith("PLUGIN_"))) {
    error2.pluginCode = code;
  }
  error2.code = PLUGIN_ERROR;
  error2.plugin = plugin2;
  if (hook) {
    error2.hook = hook;
  }
  if (id3) {
    error2.id = id3;
  }
  return error2;
}
function logShimmedExport(id3, binding) {
  return {
    binding,
    code: SHIMMED_EXPORT,
    exporter: id3,
    message: `Missing export "${binding}" has been shimmed in module "${relativeId(id3)}".`
  };
}
function logSourcemapBroken(plugin2) {
  return {
    code: SOURCEMAP_BROKEN,
    message: `Sourcemap is likely to be incorrect: a plugin (${plugin2}) was used to transform files, but didn't generate a sourcemap for the transformation. Consult the plugin documentation for help`,
    plugin: plugin2,
    url: getRollupUrl(URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT)
  };
}
function logConflictingSourcemapSources(filename) {
  return {
    code: SOURCEMAP_BROKEN,
    message: `Multiple conflicting contents for sourcemap source ${filename}`
  };
}
function logInvalidSourcemapForError(error2, id3, column, line, pos) {
  return {
    cause: error2,
    code: SOURCEMAP_ERROR,
    id: id3,
    loc: {
      column,
      file: id3,
      line
    },
    message: `Error when using sourcemap for reporting an error: ${error2.message}`,
    pos
  };
}
function logSyntheticNamedExportsNeedNamespaceExport(id3, syntheticNamedExportsOption) {
  return {
    code: SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT,
    exporter: id3,
    message: `Module "${relativeId(id3)}" that is marked with \`syntheticNamedExports: ${JSON.stringify(syntheticNamedExportsOption)}\` needs ${typeof syntheticNamedExportsOption === "string" && syntheticNamedExportsOption !== "default" ? `an explicit export named "${syntheticNamedExportsOption}"` : "a default export"} that does not reexport an unresolved named export of the same module.`
  };
}
function logThisIsUndefined() {
  return {
    code: THIS_IS_UNDEFINED,
    message: `The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten`,
    url: getRollupUrl(URL_THIS_IS_UNDEFINED)
  };
}
function logUnexpectedNamedImport(id3, imported, isReexport) {
  const importType = isReexport ? "reexport" : "import";
  return {
    code: UNEXPECTED_NAMED_IMPORT,
    exporter: id3,
    message: `The named export "${imported}" was ${importType}ed from the external module "${relativeId(id3)}" even though its interop type is "defaultOnly". Either remove or change this ${importType} or change the value of the "output.interop" option.`,
    url: getRollupUrl(URL_OUTPUT_INTEROP)
  };
}
function logUnexpectedNamespaceReexport(id3) {
  return {
    code: UNEXPECTED_NAMED_IMPORT,
    exporter: id3,
    message: `There was a namespace "*" reexport from the external module "${relativeId(id3)}" even though its interop type is "defaultOnly". This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the "output.interop" option.`,
    url: getRollupUrl(URL_OUTPUT_INTEROP)
  };
}
function logUnknownOption(optionType, unknownOptions, validOptions) {
  return {
    code: UNKNOWN_OPTION,
    message: `Unknown ${optionType}: ${unknownOptions.join(", ")}. Allowed options: ${validOptions.join(", ")}`
  };
}
function logEntryCannotBeExternal(unresolvedId) {
  return {
    code: UNRESOLVED_ENTRY,
    message: `Entry module "${relativeId(unresolvedId)}" cannot be external.`
  };
}
function logExternalModulesCannotBeIncludedInManualChunks(source) {
  return {
    code: EXTERNAL_MODULES_CANNOT_BE_INCLUDED_IN_MANUAL_CHUNKS,
    message: `"${source}" cannot be included in manualChunks because it is resolved as an external module by the "external" option or plugins.`
  };
}
function logExternalModulesCannotBeTransformedToModules(source) {
  return {
    code: EXTERNAL_MODULES_CANNOT_BE_TRANSFORMED_TO_MODULES,
    message: `${source} is resolved as a module now, but it was an external module before. Please check whether there are conflicts in your Rollup options "external" and "manualChunks", manualChunks cannot include external modules.`
  };
}
function logUnresolvedEntry(unresolvedId) {
  return {
    code: UNRESOLVED_ENTRY,
    message: `Could not resolve entry module "${relativeId(unresolvedId)}".`
  };
}
function logUnresolvedImport(source, importer) {
  return {
    code: UNRESOLVED_IMPORT,
    exporter: source,
    id: importer,
    message: `Could not resolve "${source}" from "${relativeId(importer)}"`
  };
}
function logUnresolvedImportTreatedAsExternal(source, importer) {
  return {
    code: UNRESOLVED_IMPORT,
    exporter: source,
    id: importer,
    message: `"${source}" is imported by "${relativeId(importer)}", but could not be resolved – treating it as an external dependency.`,
    url: getRollupUrl(URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY)
  };
}
function logUnusedExternalImports(externalId, names, importers) {
  return {
    code: UNUSED_EXTERNAL_IMPORT,
    exporter: externalId,
    ids: importers,
    message: `${printQuotedStringList(names, [
      "is",
      "are"
    ])} imported from external module "${externalId}" but never used in ${printQuotedStringList(importers.map((importer) => relativeId(importer)))}.`,
    names
  };
}
function logFailedValidation(message) {
  return {
    code: VALIDATION_ERROR,
    message
  };
}
function warnDeprecation(deprecation, urlSnippet, activeDeprecation, options2, plugin2) {
  warnDeprecationWithOptions(deprecation, urlSnippet, activeDeprecation, options2.onLog, options2.strictDeprecations);
}
function warnDeprecationWithOptions(deprecation, urlSnippet, activeDeprecation, log, strictDeprecations, plugin2) {
  if (activeDeprecation || strictDeprecations) {
    const warning = logDeprecation(deprecation, urlSnippet);
    if (strictDeprecations) {
      return error(warning);
    }
    log(LOGLEVEL_WARN, warning);
  }
}
function convertProgram(buffer) {
  const node3 = convertNode(0, buffer);
  switch (node3.type) {
    case PanicError: {
      return error(getRollupError(logParseError(node3.message)));
    }
    case ParseError: {
      return error(getRollupError(logParseError(node3.message, node3.start)));
    }
    default: {
      return node3;
    }
  }
}
function convertNode(position, buffer) {
  const nodeType = buffer[position];
  const converter = nodeConverters[nodeType];
  if (!converter) {
    console.trace();
    throw new Error(`Unknown node type: ${nodeType}`);
  }
  return converter(position + 1, buffer);
}
function convertNodeList(position, buffer) {
  if (position === 0)
    return EMPTY_ARRAY;
  const length = buffer[position++];
  const list = new Array(length);
  for (let index3 = 0; index3 < length; index3++) {
    const nodePosition = buffer[position++];
    list[index3] = nodePosition ? convertNode(nodePosition, buffer) : null;
  }
  return list;
}
function getAstBuffer(astBuffer) {
  const array2 = new Uint32Array(astBuffer.buffer);
  let convertString;
  if (typeof Buffer !== "undefined" && astBuffer instanceof Buffer) {
    convertString = (position) => {
      const length = array2[position++];
      const bytePosition = position << 2;
      return astBuffer.toString("utf8", bytePosition, bytePosition + length);
    };
  } else {
    const textDecoder = new TextDecoder();
    convertString = (position) => {
      const length = array2[position++];
      const bytePosition = position << 2;
      return textDecoder.decode(astBuffer.subarray(bytePosition, bytePosition + length));
    };
  }
  return Object.assign(array2, { convertString });
}
var ArrowFunctionExpression, BlockStatement, CallExpression, CatchClause, ExportDefaultDeclaration, ExpressionStatement, Identifier, Literal, PanicError, ParseError, Program, Property, ReturnStatement, StaticBlock, TemplateLiteral, VariableDeclarator, BLANK, EMPTY_OBJECT, EMPTY_ARRAY, EMPTY_SET, FIXED_STRINGS, ANNOTATION_KEY, INVALID_ANNOTATION_KEY, convertAnnotations, convertAnnotation, LINE_TRUNCATE_LENGTH, MIN_CHARACTERS_SHOWN_AFTER_LOCATION, ELLIPSIS, LOGLEVEL_SILENT, LOGLEVEL_ERROR, LOGLEVEL_WARN, LOGLEVEL_INFO, LOGLEVEL_DEBUG, logLevelPriority, ABSOLUTE_PATH_REGEX, RELATIVE_PATH_REGEX, BACKSLASH_REGEX, ANY_SLASH_REGEX, UPPER_DIR_REGEX, URL_AVOIDING_EVAL, URL_NAME_IS_NOT_EXPORTED, URL_THIS_IS_UNDEFINED, URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY, URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT, URL_JSX, URL_OUTPUT_AMD_ID, URL_OUTPUT_AMD_BASEPATH, URL_OUTPUT_DIR, URL_OUTPUT_EXPORTS, URL_OUTPUT_EXTEND, URL_OUTPUT_EXTERNALIMPORTATTRIBUTES, URL_OUTPUT_FORMAT, URL_OUTPUT_GENERATEDCODE, URL_OUTPUT_GLOBALS, URL_OUTPUT_INLINEDYNAMICIMPORTS, URL_OUTPUT_INTEROP, URL_OUTPUT_MANUALCHUNKS, URL_OUTPUT_NAME, URL_OUTPUT_SOURCEMAPBASEURL, URL_OUTPUT_SOURCEMAPFILE, URL_PRESERVEENTRYSIGNATURES, URL_TREESHAKE, URL_TREESHAKE_PURE, URL_TREESHAKE_NOSIDEEFFECTS, URL_TREESHAKE_MODULESIDEEFFECTS, URL_WATCH, URL_GENERATEBUNDLE, symbolAugmented, ADDON_ERROR, ALREADY_CLOSED, AMBIGUOUS_EXTERNAL_NAMESPACES, ANONYMOUS_PLUGIN_CACHE, ASSET_NOT_FINALISED, ASSET_NOT_FOUND, ASSET_SOURCE_ALREADY_SET, ASSET_SOURCE_MISSING, BAD_LOADER, CANNOT_CALL_NAMESPACE, CANNOT_EMIT_FROM_OPTIONS_HOOK, CHUNK_NOT_GENERATED, CHUNK_INVALID, CIRCULAR_DEPENDENCY, CIRCULAR_REEXPORT, CONST_REASSIGN, CYCLIC_CROSS_CHUNK_REEXPORT, DEPRECATED_FEATURE, DUPLICATE_ARGUMENT_NAME, DUPLICATE_EXPORT, DUPLICATE_PLUGIN_NAME, EMPTY_BUNDLE, EVAL, EXTERNAL_MODULES_CANNOT_BE_INCLUDED_IN_MANUAL_CHUNKS, EXTERNAL_MODULES_CANNOT_BE_TRANSFORMED_TO_MODULES, EXTERNAL_SYNTHETIC_EXPORTS, FILE_NAME_CONFLICT, FILE_NOT_FOUND, FIRST_SIDE_EFFECT, ILLEGAL_IDENTIFIER_AS_NAME, ILLEGAL_REASSIGNMENT, INCONSISTENT_IMPORT_ATTRIBUTES, INVALID_ANNOTATION, INPUT_HOOK_IN_OUTPUT_PLUGIN, INVALID_CHUNK, INVALID_EXPORT_OPTION, INVALID_EXTERNAL_ID, INVALID_IMPORT_ATTRIBUTE, INVALID_LOG_POSITION, INVALID_OPTION, INVALID_PLUGIN_HOOK, INVALID_ROLLUP_PHASE, INVALID_SETASSETSOURCE, INVALID_TLA_FORMAT, MISSING_EXPORT, MISSING_GLOBAL_NAME, MISSING_IMPLICIT_DEPENDANT, MISSING_JSX_EXPORT, MISSING_NAME_OPTION_FOR_IIFE_EXPORT, MISSING_NODE_BUILTINS, MISSING_OPTION, MIXED_EXPORTS, MODULE_LEVEL_DIRECTIVE, NAMESPACE_CONFLICT, NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE, OPTIMIZE_CHUNK_STATUS, PARSE_ERROR, PLUGIN_ERROR, REDECLARATION_ERROR, RESERVED_NAMESPACE, SHIMMED_EXPORT, SOURCEMAP_BROKEN, SOURCEMAP_ERROR, SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT, THIS_IS_UNDEFINED, UNEXPECTED_NAMED_IMPORT, UNKNOWN_OPTION, UNRESOLVED_ENTRY, UNRESOLVED_IMPORT, UNUSED_EXTERNAL_IMPORT, VALIDATION_ERROR, formatAttributes, nodeConverters, parseAst, parseAstAsync, exports2, parseAst_default;
var init_parseAst = __esm({
  "../rollup/shared/parseAst.js"() {
    init_native();
    ArrowFunctionExpression = "ArrowFunctionExpression";
    BlockStatement = "BlockStatement";
    CallExpression = "CallExpression";
    CatchClause = "CatchClause";
    ExportDefaultDeclaration = "ExportDefaultDeclaration";
    ExpressionStatement = "ExpressionStatement";
    Identifier = "Identifier";
    Literal = "Literal";
    PanicError = "PanicError";
    ParseError = "ParseError";
    Program = "Program";
    Property = "Property";
    ReturnStatement = "ReturnStatement";
    StaticBlock = "StaticBlock";
    TemplateLiteral = "TemplateLiteral";
    VariableDeclarator = "VariableDeclarator";
    BLANK = Object.freeze(/* @__PURE__ */ Object.create(null));
    EMPTY_OBJECT = Object.freeze({});
    EMPTY_ARRAY = Object.freeze([]);
    EMPTY_SET = Object.freeze(new class extends Set {
      add() {
        throw new Error("Cannot add to empty set");
      }
    }());
    FIXED_STRINGS = [
      "var",
      "let",
      "const",
      "init",
      "get",
      "set",
      "constructor",
      "method",
      "-",
      "+",
      "!",
      "~",
      "typeof",
      "void",
      "delete",
      "++",
      "--",
      "==",
      "!=",
      "===",
      "!==",
      "<",
      "<=",
      ">",
      ">=",
      "<<",
      ">>",
      ">>>",
      "+",
      "-",
      "*",
      "/",
      "%",
      "|",
      "^",
      "&",
      "||",
      "&&",
      "in",
      "instanceof",
      "**",
      "??",
      "=",
      "+=",
      "-=",
      "*=",
      "/=",
      "%=",
      "<<=",
      ">>=",
      ">>>=",
      "|=",
      "^=",
      "&=",
      "**=",
      "&&=",
      "||=",
      "??=",
      "pure",
      "noSideEffects",
      "sourcemap",
      "using",
      "await using"
    ];
    ANNOTATION_KEY = "_rollupAnnotations";
    INVALID_ANNOTATION_KEY = "_rollupRemoved";
    convertAnnotations = (position, buffer) => {
      if (position === 0)
        return EMPTY_ARRAY;
      const length = buffer[position++];
      const list = new Array(length);
      for (let index3 = 0; index3 < length; index3++) {
        list[index3] = convertAnnotation(buffer[position++], buffer);
      }
      return list;
    };
    convertAnnotation = (position, buffer) => {
      const start2 = buffer[position++];
      const end = buffer[position++];
      const type = FIXED_STRINGS[buffer[position]];
      return { end, start: start2, type };
    };
    LINE_TRUNCATE_LENGTH = 120;
    MIN_CHARACTERS_SHOWN_AFTER_LOCATION = 10;
    ELLIPSIS = "...";
    LOGLEVEL_SILENT = "silent";
    LOGLEVEL_ERROR = "error";
    LOGLEVEL_WARN = "warn";
    LOGLEVEL_INFO = "info";
    LOGLEVEL_DEBUG = "debug";
    logLevelPriority = {
      [LOGLEVEL_DEBUG]: 0,
      [LOGLEVEL_INFO]: 1,
      [LOGLEVEL_SILENT]: 3,
      [LOGLEVEL_WARN]: 2
    };
    ABSOLUTE_PATH_REGEX = /^(?:\/|(?:[A-Za-z]:)?[/\\|])/;
    RELATIVE_PATH_REGEX = /^\.?\.(\/|$)/;
    BACKSLASH_REGEX = /\\/g;
    ANY_SLASH_REGEX = /[/\\]/;
    UPPER_DIR_REGEX = /^(\.\.\/)*\.\.$/;
    URL_AVOIDING_EVAL = "troubleshooting/#avoiding-eval";
    URL_NAME_IS_NOT_EXPORTED = "troubleshooting/#error-name-is-not-exported-by-module";
    URL_THIS_IS_UNDEFINED = "troubleshooting/#error-this-is-undefined";
    URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY = "troubleshooting/#warning-treating-module-as-external-dependency";
    URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT = "troubleshooting/#warning-sourcemap-is-likely-to-be-incorrect";
    URL_JSX = "configuration-options/#jsx";
    URL_OUTPUT_AMD_ID = "configuration-options/#output-amd-id";
    URL_OUTPUT_AMD_BASEPATH = "configuration-options/#output-amd-basepath";
    URL_OUTPUT_DIR = "configuration-options/#output-dir";
    URL_OUTPUT_EXPORTS = "configuration-options/#output-exports";
    URL_OUTPUT_EXTEND = "configuration-options/#output-extend";
    URL_OUTPUT_EXTERNALIMPORTATTRIBUTES = "configuration-options/#output-externalimportattributes";
    URL_OUTPUT_FORMAT = "configuration-options/#output-format";
    URL_OUTPUT_GENERATEDCODE = "configuration-options/#output-generatedcode";
    URL_OUTPUT_GLOBALS = "configuration-options/#output-globals";
    URL_OUTPUT_INLINEDYNAMICIMPORTS = "configuration-options/#output-inlinedynamicimports";
    URL_OUTPUT_INTEROP = "configuration-options/#output-interop";
    URL_OUTPUT_MANUALCHUNKS = "configuration-options/#output-manualchunks";
    URL_OUTPUT_NAME = "configuration-options/#output-name";
    URL_OUTPUT_SOURCEMAPBASEURL = "configuration-options/#output-sourcemapbaseurl";
    URL_OUTPUT_SOURCEMAPFILE = "configuration-options/#output-sourcemapfile";
    URL_PRESERVEENTRYSIGNATURES = "configuration-options/#preserveentrysignatures";
    URL_TREESHAKE = "configuration-options/#treeshake";
    URL_TREESHAKE_PURE = "configuration-options/#pure";
    URL_TREESHAKE_NOSIDEEFFECTS = "configuration-options/#no-side-effects";
    URL_TREESHAKE_MODULESIDEEFFECTS = "configuration-options/#treeshake-modulesideeffects";
    URL_WATCH = "configuration-options/#watch";
    URL_GENERATEBUNDLE = "plugin-development/#generatebundle";
    symbolAugmented = Symbol("augmented");
    ADDON_ERROR = "ADDON_ERROR";
    ALREADY_CLOSED = "ALREADY_CLOSED";
    AMBIGUOUS_EXTERNAL_NAMESPACES = "AMBIGUOUS_EXTERNAL_NAMESPACES";
    ANONYMOUS_PLUGIN_CACHE = "ANONYMOUS_PLUGIN_CACHE";
    ASSET_NOT_FINALISED = "ASSET_NOT_FINALISED";
    ASSET_NOT_FOUND = "ASSET_NOT_FOUND";
    ASSET_SOURCE_ALREADY_SET = "ASSET_SOURCE_ALREADY_SET";
    ASSET_SOURCE_MISSING = "ASSET_SOURCE_MISSING";
    BAD_LOADER = "BAD_LOADER";
    CANNOT_CALL_NAMESPACE = "CANNOT_CALL_NAMESPACE";
    CANNOT_EMIT_FROM_OPTIONS_HOOK = "CANNOT_EMIT_FROM_OPTIONS_HOOK";
    CHUNK_NOT_GENERATED = "CHUNK_NOT_GENERATED";
    CHUNK_INVALID = "CHUNK_INVALID";
    CIRCULAR_DEPENDENCY = "CIRCULAR_DEPENDENCY";
    CIRCULAR_REEXPORT = "CIRCULAR_REEXPORT";
    CONST_REASSIGN = "CONST_REASSIGN";
    CYCLIC_CROSS_CHUNK_REEXPORT = "CYCLIC_CROSS_CHUNK_REEXPORT";
    DEPRECATED_FEATURE = "DEPRECATED_FEATURE";
    DUPLICATE_ARGUMENT_NAME = "DUPLICATE_ARGUMENT_NAME";
    DUPLICATE_EXPORT = "DUPLICATE_EXPORT";
    DUPLICATE_PLUGIN_NAME = "DUPLICATE_PLUGIN_NAME";
    EMPTY_BUNDLE = "EMPTY_BUNDLE";
    EVAL = "EVAL";
    EXTERNAL_MODULES_CANNOT_BE_INCLUDED_IN_MANUAL_CHUNKS = "EXTERNAL_MODULES_CANNOT_BE_INCLUDED_IN_MANUAL_CHUNKS";
    EXTERNAL_MODULES_CANNOT_BE_TRANSFORMED_TO_MODULES = "EXTERNAL_MODULES_CANNOT_BE_TRANSFORMED_TO_MODULES";
    EXTERNAL_SYNTHETIC_EXPORTS = "EXTERNAL_SYNTHETIC_EXPORTS";
    FILE_NAME_CONFLICT = "FILE_NAME_CONFLICT";
    FILE_NOT_FOUND = "FILE_NOT_FOUND";
    FIRST_SIDE_EFFECT = "FIRST_SIDE_EFFECT";
    ILLEGAL_IDENTIFIER_AS_NAME = "ILLEGAL_IDENTIFIER_AS_NAME";
    ILLEGAL_REASSIGNMENT = "ILLEGAL_REASSIGNMENT";
    INCONSISTENT_IMPORT_ATTRIBUTES = "INCONSISTENT_IMPORT_ATTRIBUTES";
    INVALID_ANNOTATION = "INVALID_ANNOTATION";
    INPUT_HOOK_IN_OUTPUT_PLUGIN = "INPUT_HOOK_IN_OUTPUT_PLUGIN";
    INVALID_CHUNK = "INVALID_CHUNK";
    INVALID_EXPORT_OPTION = "INVALID_EXPORT_OPTION";
    INVALID_EXTERNAL_ID = "INVALID_EXTERNAL_ID";
    INVALID_IMPORT_ATTRIBUTE = "INVALID_IMPORT_ATTRIBUTE";
    INVALID_LOG_POSITION = "INVALID_LOG_POSITION";
    INVALID_OPTION = "INVALID_OPTION";
    INVALID_PLUGIN_HOOK = "INVALID_PLUGIN_HOOK";
    INVALID_ROLLUP_PHASE = "INVALID_ROLLUP_PHASE";
    INVALID_SETASSETSOURCE = "INVALID_SETASSETSOURCE";
    INVALID_TLA_FORMAT = "INVALID_TLA_FORMAT";
    MISSING_EXPORT = "MISSING_EXPORT";
    MISSING_GLOBAL_NAME = "MISSING_GLOBAL_NAME";
    MISSING_IMPLICIT_DEPENDANT = "MISSING_IMPLICIT_DEPENDANT";
    MISSING_JSX_EXPORT = "MISSING_JSX_EXPORT";
    MISSING_NAME_OPTION_FOR_IIFE_EXPORT = "MISSING_NAME_OPTION_FOR_IIFE_EXPORT";
    MISSING_NODE_BUILTINS = "MISSING_NODE_BUILTINS";
    MISSING_OPTION = "MISSING_OPTION";
    MIXED_EXPORTS = "MIXED_EXPORTS";
    MODULE_LEVEL_DIRECTIVE = "MODULE_LEVEL_DIRECTIVE";
    NAMESPACE_CONFLICT = "NAMESPACE_CONFLICT";
    NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE = "NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE";
    OPTIMIZE_CHUNK_STATUS = "OPTIMIZE_CHUNK_STATUS";
    PARSE_ERROR = "PARSE_ERROR";
    PLUGIN_ERROR = "PLUGIN_ERROR";
    REDECLARATION_ERROR = "REDECLARATION_ERROR";
    RESERVED_NAMESPACE = "RESERVED_NAMESPACE";
    SHIMMED_EXPORT = "SHIMMED_EXPORT";
    SOURCEMAP_BROKEN = "SOURCEMAP_BROKEN";
    SOURCEMAP_ERROR = "SOURCEMAP_ERROR";
    SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT = "SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT";
    THIS_IS_UNDEFINED = "THIS_IS_UNDEFINED";
    UNEXPECTED_NAMED_IMPORT = "UNEXPECTED_NAMED_IMPORT";
    UNKNOWN_OPTION = "UNKNOWN_OPTION";
    UNRESOLVED_ENTRY = "UNRESOLVED_ENTRY";
    UNRESOLVED_IMPORT = "UNRESOLVED_IMPORT";
    UNUSED_EXTERNAL_IMPORT = "UNUSED_EXTERNAL_IMPORT";
    VALIDATION_ERROR = "VALIDATION_ERROR";
    formatAttributes = (attributes) => {
      const entries = Object.entries(attributes);
      if (entries.length === 0)
        return "no";
      return entries.map(([key, value2]) => `"${key}": "${value2}"`).join(", ");
    };
    nodeConverters = [
      function panicError(position, buffer) {
        return {
          type: "PanicError",
          start: buffer[position],
          end: buffer[position + 1],
          message: buffer.convertString(buffer[position + 2])
        };
      },
      function parseError(position, buffer) {
        return {
          type: "ParseError",
          start: buffer[position],
          end: buffer[position + 1],
          message: buffer.convertString(buffer[position + 2])
        };
      },
      function arrayExpression(position, buffer) {
        return {
          type: "ArrayExpression",
          start: buffer[position],
          end: buffer[position + 1],
          elements: convertNodeList(buffer[position + 2], buffer)
        };
      },
      function arrayPattern(position, buffer) {
        return {
          type: "ArrayPattern",
          start: buffer[position],
          end: buffer[position + 1],
          elements: convertNodeList(buffer[position + 2], buffer)
        };
      },
      function arrowFunctionExpression(position, buffer) {
        const flags = buffer[position + 2];
        const annotations = convertAnnotations(buffer[position + 3], buffer);
        return {
          type: "ArrowFunctionExpression",
          start: buffer[position],
          end: buffer[position + 1],
          async: (flags & 1) === 1,
          expression: (flags & 2) === 2,
          generator: (flags & 4) === 4,
          ...annotations.length > 0 ? { [ANNOTATION_KEY]: annotations } : {},
          params: convertNodeList(buffer[position + 4], buffer),
          body: convertNode(buffer[position + 5], buffer),
          id: null
        };
      },
      function assignmentExpression(position, buffer) {
        return {
          type: "AssignmentExpression",
          start: buffer[position],
          end: buffer[position + 1],
          operator: FIXED_STRINGS[buffer[position + 2]],
          left: convertNode(buffer[position + 3], buffer),
          right: convertNode(buffer[position + 4], buffer)
        };
      },
      function assignmentPattern(position, buffer) {
        return {
          type: "AssignmentPattern",
          start: buffer[position],
          end: buffer[position + 1],
          left: convertNode(buffer[position + 2], buffer),
          right: convertNode(buffer[position + 3], buffer)
        };
      },
      function awaitExpression(position, buffer) {
        return {
          type: "AwaitExpression",
          start: buffer[position],
          end: buffer[position + 1],
          argument: convertNode(buffer[position + 2], buffer)
        };
      },
      function binaryExpression(position, buffer) {
        return {
          type: "BinaryExpression",
          start: buffer[position],
          end: buffer[position + 1],
          operator: FIXED_STRINGS[buffer[position + 2]],
          left: convertNode(buffer[position + 3], buffer),
          right: convertNode(buffer[position + 4], buffer)
        };
      },
      function blockStatement(position, buffer) {
        return {
          type: "BlockStatement",
          start: buffer[position],
          end: buffer[position + 1],
          body: convertNodeList(buffer[position + 2], buffer)
        };
      },
      function breakStatement(position, buffer) {
        const labelPosition = buffer[position + 2];
        return {
          type: "BreakStatement",
          start: buffer[position],
          end: buffer[position + 1],
          label: labelPosition === 0 ? null : convertNode(labelPosition, buffer)
        };
      },
      function callExpression(position, buffer) {
        const flags = buffer[position + 2];
        const annotations = convertAnnotations(buffer[position + 3], buffer);
        return {
          type: "CallExpression",
          start: buffer[position],
          end: buffer[position + 1],
          optional: (flags & 1) === 1,
          ...annotations.length > 0 ? { [ANNOTATION_KEY]: annotations } : {},
          callee: convertNode(buffer[position + 4], buffer),
          arguments: convertNodeList(buffer[position + 5], buffer)
        };
      },
      function catchClause(position, buffer) {
        const parameterPosition = buffer[position + 2];
        return {
          type: "CatchClause",
          start: buffer[position],
          end: buffer[position + 1],
          param: parameterPosition === 0 ? null : convertNode(parameterPosition, buffer),
          body: convertNode(buffer[position + 3], buffer)
        };
      },
      function chainExpression(position, buffer) {
        return {
          type: "ChainExpression",
          start: buffer[position],
          end: buffer[position + 1],
          expression: convertNode(buffer[position + 2], buffer)
        };
      },
      function classBody(position, buffer) {
        return {
          type: "ClassBody",
          start: buffer[position],
          end: buffer[position + 1],
          body: convertNodeList(buffer[position + 2], buffer)
        };
      },
      function classDeclaration(position, buffer) {
        const idPosition = buffer[position + 3];
        const superClassPosition = buffer[position + 4];
        return {
          type: "ClassDeclaration",
          start: buffer[position],
          end: buffer[position + 1],
          decorators: convertNodeList(buffer[position + 2], buffer),
          id: idPosition === 0 ? null : convertNode(idPosition, buffer),
          superClass: superClassPosition === 0 ? null : convertNode(superClassPosition, buffer),
          body: convertNode(buffer[position + 5], buffer)
        };
      },
      function classExpression(position, buffer) {
        const idPosition = buffer[position + 3];
        const superClassPosition = buffer[position + 4];
        return {
          type: "ClassExpression",
          start: buffer[position],
          end: buffer[position + 1],
          decorators: convertNodeList(buffer[position + 2], buffer),
          id: idPosition === 0 ? null : convertNode(idPosition, buffer),
          superClass: superClassPosition === 0 ? null : convertNode(superClassPosition, buffer),
          body: convertNode(buffer[position + 5], buffer)
        };
      },
      function conditionalExpression(position, buffer) {
        return {
          type: "ConditionalExpression",
          start: buffer[position],
          end: buffer[position + 1],
          test: convertNode(buffer[position + 2], buffer),
          consequent: convertNode(buffer[position + 3], buffer),
          alternate: convertNode(buffer[position + 4], buffer)
        };
      },
      function continueStatement(position, buffer) {
        const labelPosition = buffer[position + 2];
        return {
          type: "ContinueStatement",
          start: buffer[position],
          end: buffer[position + 1],
          label: labelPosition === 0 ? null : convertNode(labelPosition, buffer)
        };
      },
      function debuggerStatement(position, buffer) {
        return {
          type: "DebuggerStatement",
          start: buffer[position],
          end: buffer[position + 1]
        };
      },
      function decorator(position, buffer) {
        return {
          type: "Decorator",
          start: buffer[position],
          end: buffer[position + 1],
          expression: convertNode(buffer[position + 2], buffer)
        };
      },
      function directive(position, buffer) {
        return {
          type: "ExpressionStatement",
          start: buffer[position],
          end: buffer[position + 1],
          directive: buffer.convertString(buffer[position + 2]),
          expression: convertNode(buffer[position + 3], buffer)
        };
      },
      function doWhileStatement(position, buffer) {
        return {
          type: "DoWhileStatement",
          start: buffer[position],
          end: buffer[position + 1],
          body: convertNode(buffer[position + 2], buffer),
          test: convertNode(buffer[position + 3], buffer)
        };
      },
      function emptyStatement(position, buffer) {
        return {
          type: "EmptyStatement",
          start: buffer[position],
          end: buffer[position + 1]
        };
      },
      function exportAllDeclaration(position, buffer) {
        const exportedPosition = buffer[position + 2];
        return {
          type: "ExportAllDeclaration",
          start: buffer[position],
          end: buffer[position + 1],
          exported: exportedPosition === 0 ? null : convertNode(exportedPosition, buffer),
          source: convertNode(buffer[position + 3], buffer),
          attributes: convertNodeList(buffer[position + 4], buffer)
        };
      },
      function exportDefaultDeclaration(position, buffer) {
        return {
          type: "ExportDefaultDeclaration",
          start: buffer[position],
          end: buffer[position + 1],
          declaration: convertNode(buffer[position + 2], buffer)
        };
      },
      function exportNamedDeclaration(position, buffer) {
        const sourcePosition = buffer[position + 3];
        const declarationPosition = buffer[position + 5];
        return {
          type: "ExportNamedDeclaration",
          start: buffer[position],
          end: buffer[position + 1],
          specifiers: convertNodeList(buffer[position + 2], buffer),
          source: sourcePosition === 0 ? null : convertNode(sourcePosition, buffer),
          attributes: convertNodeList(buffer[position + 4], buffer),
          declaration: declarationPosition === 0 ? null : convertNode(declarationPosition, buffer)
        };
      },
      function exportSpecifier(position, buffer) {
        const local = convertNode(buffer[position + 2], buffer);
        const exportedPosition = buffer[position + 3];
        return {
          type: "ExportSpecifier",
          start: buffer[position],
          end: buffer[position + 1],
          local,
          exported: exportedPosition === 0 ? { ...local } : convertNode(exportedPosition, buffer)
        };
      },
      function expressionStatement(position, buffer) {
        return {
          type: "ExpressionStatement",
          start: buffer[position],
          end: buffer[position + 1],
          expression: convertNode(buffer[position + 2], buffer)
        };
      },
      function forInStatement(position, buffer) {
        return {
          type: "ForInStatement",
          start: buffer[position],
          end: buffer[position + 1],
          left: convertNode(buffer[position + 2], buffer),
          right: convertNode(buffer[position + 3], buffer),
          body: convertNode(buffer[position + 4], buffer)
        };
      },
      function forOfStatement(position, buffer) {
        const flags = buffer[position + 2];
        return {
          type: "ForOfStatement",
          start: buffer[position],
          end: buffer[position + 1],
          await: (flags & 1) === 1,
          left: convertNode(buffer[position + 3], buffer),
          right: convertNode(buffer[position + 4], buffer),
          body: convertNode(buffer[position + 5], buffer)
        };
      },
      function forStatement(position, buffer) {
        const initPosition = buffer[position + 2];
        const testPosition = buffer[position + 3];
        const updatePosition = buffer[position + 4];
        return {
          type: "ForStatement",
          start: buffer[position],
          end: buffer[position + 1],
          init: initPosition === 0 ? null : convertNode(initPosition, buffer),
          test: testPosition === 0 ? null : convertNode(testPosition, buffer),
          update: updatePosition === 0 ? null : convertNode(updatePosition, buffer),
          body: convertNode(buffer[position + 5], buffer)
        };
      },
      function functionDeclaration(position, buffer) {
        const flags = buffer[position + 2];
        const annotations = convertAnnotations(buffer[position + 3], buffer);
        const idPosition = buffer[position + 4];
        return {
          type: "FunctionDeclaration",
          start: buffer[position],
          end: buffer[position + 1],
          async: (flags & 1) === 1,
          generator: (flags & 2) === 2,
          ...annotations.length > 0 ? { [ANNOTATION_KEY]: annotations } : {},
          id: idPosition === 0 ? null : convertNode(idPosition, buffer),
          params: convertNodeList(buffer[position + 5], buffer),
          body: convertNode(buffer[position + 6], buffer),
          expression: false
        };
      },
      function functionExpression(position, buffer) {
        const flags = buffer[position + 2];
        const annotations = convertAnnotations(buffer[position + 3], buffer);
        const idPosition = buffer[position + 4];
        return {
          type: "FunctionExpression",
          start: buffer[position],
          end: buffer[position + 1],
          async: (flags & 1) === 1,
          generator: (flags & 2) === 2,
          ...annotations.length > 0 ? { [ANNOTATION_KEY]: annotations } : {},
          id: idPosition === 0 ? null : convertNode(idPosition, buffer),
          params: convertNodeList(buffer[position + 5], buffer),
          body: convertNode(buffer[position + 6], buffer),
          expression: false
        };
      },
      function identifier(position, buffer) {
        return {
          type: "Identifier",
          start: buffer[position],
          end: buffer[position + 1],
          name: buffer.convertString(buffer[position + 2])
        };
      },
      function ifStatement(position, buffer) {
        const alternatePosition = buffer[position + 4];
        return {
          type: "IfStatement",
          start: buffer[position],
          end: buffer[position + 1],
          test: convertNode(buffer[position + 2], buffer),
          consequent: convertNode(buffer[position + 3], buffer),
          alternate: alternatePosition === 0 ? null : convertNode(alternatePosition, buffer)
        };
      },
      function importAttribute(position, buffer) {
        return {
          type: "ImportAttribute",
          start: buffer[position],
          end: buffer[position + 1],
          key: convertNode(buffer[position + 2], buffer),
          value: convertNode(buffer[position + 3], buffer)
        };
      },
      function importDeclaration(position, buffer) {
        return {
          type: "ImportDeclaration",
          start: buffer[position],
          end: buffer[position + 1],
          specifiers: convertNodeList(buffer[position + 2], buffer),
          source: convertNode(buffer[position + 3], buffer),
          attributes: convertNodeList(buffer[position + 4], buffer)
        };
      },
      function importDefaultSpecifier(position, buffer) {
        return {
          type: "ImportDefaultSpecifier",
          start: buffer[position],
          end: buffer[position + 1],
          local: convertNode(buffer[position + 2], buffer)
        };
      },
      function importExpression(position, buffer) {
        const optionsPosition = buffer[position + 3];
        return {
          type: "ImportExpression",
          start: buffer[position],
          end: buffer[position + 1],
          source: convertNode(buffer[position + 2], buffer),
          options: optionsPosition === 0 ? null : convertNode(optionsPosition, buffer)
        };
      },
      function importNamespaceSpecifier(position, buffer) {
        return {
          type: "ImportNamespaceSpecifier",
          start: buffer[position],
          end: buffer[position + 1],
          local: convertNode(buffer[position + 2], buffer)
        };
      },
      function importSpecifier(position, buffer) {
        const importedPosition = buffer[position + 2];
        const local = convertNode(buffer[position + 3], buffer);
        return {
          type: "ImportSpecifier",
          start: buffer[position],
          end: buffer[position + 1],
          imported: importedPosition === 0 ? { ...local } : convertNode(importedPosition, buffer),
          local
        };
      },
      function jsxAttribute(position, buffer) {
        const valuePosition = buffer[position + 3];
        return {
          type: "JSXAttribute",
          start: buffer[position],
          end: buffer[position + 1],
          name: convertNode(buffer[position + 2], buffer),
          value: valuePosition === 0 ? null : convertNode(valuePosition, buffer)
        };
      },
      function jsxClosingElement(position, buffer) {
        return {
          type: "JSXClosingElement",
          start: buffer[position],
          end: buffer[position + 1],
          name: convertNode(buffer[position + 2], buffer)
        };
      },
      function jsxClosingFragment(position, buffer) {
        return {
          type: "JSXClosingFragment",
          start: buffer[position],
          end: buffer[position + 1]
        };
      },
      function jsxElement(position, buffer) {
        const closingElementPosition = buffer[position + 4];
        return {
          type: "JSXElement",
          start: buffer[position],
          end: buffer[position + 1],
          openingElement: convertNode(buffer[position + 2], buffer),
          children: convertNodeList(buffer[position + 3], buffer),
          closingElement: closingElementPosition === 0 ? null : convertNode(closingElementPosition, buffer)
        };
      },
      function jsxEmptyExpression(position, buffer) {
        return {
          type: "JSXEmptyExpression",
          start: buffer[position],
          end: buffer[position + 1]
        };
      },
      function jsxExpressionContainer(position, buffer) {
        return {
          type: "JSXExpressionContainer",
          start: buffer[position],
          end: buffer[position + 1],
          expression: convertNode(buffer[position + 2], buffer)
        };
      },
      function jsxFragment(position, buffer) {
        return {
          type: "JSXFragment",
          start: buffer[position],
          end: buffer[position + 1],
          openingFragment: convertNode(buffer[position + 2], buffer),
          children: convertNodeList(buffer[position + 3], buffer),
          closingFragment: convertNode(buffer[position + 4], buffer)
        };
      },
      function jsxIdentifier(position, buffer) {
        return {
          type: "JSXIdentifier",
          start: buffer[position],
          end: buffer[position + 1],
          name: buffer.convertString(buffer[position + 2])
        };
      },
      function jsxMemberExpression(position, buffer) {
        return {
          type: "JSXMemberExpression",
          start: buffer[position],
          end: buffer[position + 1],
          object: convertNode(buffer[position + 2], buffer),
          property: convertNode(buffer[position + 3], buffer)
        };
      },
      function jsxNamespacedName(position, buffer) {
        return {
          type: "JSXNamespacedName",
          start: buffer[position],
          end: buffer[position + 1],
          namespace: convertNode(buffer[position + 2], buffer),
          name: convertNode(buffer[position + 3], buffer)
        };
      },
      function jsxOpeningElement(position, buffer) {
        const flags = buffer[position + 2];
        return {
          type: "JSXOpeningElement",
          start: buffer[position],
          end: buffer[position + 1],
          selfClosing: (flags & 1) === 1,
          name: convertNode(buffer[position + 3], buffer),
          attributes: convertNodeList(buffer[position + 4], buffer)
        };
      },
      function jsxOpeningFragment(position, buffer) {
        return {
          type: "JSXOpeningFragment",
          start: buffer[position],
          end: buffer[position + 1],
          attributes: [],
          selfClosing: false
        };
      },
      function jsxSpreadAttribute(position, buffer) {
        return {
          type: "JSXSpreadAttribute",
          start: buffer[position],
          end: buffer[position + 1],
          argument: convertNode(buffer[position + 2], buffer)
        };
      },
      function jsxSpreadChild(position, buffer) {
        return {
          type: "JSXSpreadChild",
          start: buffer[position],
          end: buffer[position + 1],
          expression: convertNode(buffer[position + 2], buffer)
        };
      },
      function jsxText(position, buffer) {
        return {
          type: "JSXText",
          start: buffer[position],
          end: buffer[position + 1],
          value: buffer.convertString(buffer[position + 2]),
          raw: buffer.convertString(buffer[position + 3])
        };
      },
      function labeledStatement(position, buffer) {
        return {
          type: "LabeledStatement",
          start: buffer[position],
          end: buffer[position + 1],
          label: convertNode(buffer[position + 2], buffer),
          body: convertNode(buffer[position + 3], buffer)
        };
      },
      function literalBigInt(position, buffer) {
        const bigint = buffer.convertString(buffer[position + 2]);
        return {
          type: "Literal",
          start: buffer[position],
          end: buffer[position + 1],
          bigint,
          raw: buffer.convertString(buffer[position + 3]),
          value: BigInt(bigint)
        };
      },
      function literalBoolean(position, buffer) {
        const flags = buffer[position + 2];
        const value2 = (flags & 1) === 1;
        return {
          type: "Literal",
          start: buffer[position],
          end: buffer[position + 1],
          value: value2,
          raw: value2 ? "true" : "false"
        };
      },
      function literalNull(position, buffer) {
        return {
          type: "Literal",
          start: buffer[position],
          end: buffer[position + 1],
          raw: "null",
          value: null
        };
      },
      function literalNumber(position, buffer) {
        const rawPosition = buffer[position + 2];
        return {
          type: "Literal",
          start: buffer[position],
          end: buffer[position + 1],
          raw: rawPosition === 0 ? void 0 : buffer.convertString(rawPosition),
          value: new DataView(buffer.buffer).getFloat64(position + 3 << 2, true)
        };
      },
      function literalRegExp(position, buffer) {
        const flags = buffer.convertString(buffer[position + 2]);
        const pattern2 = buffer.convertString(buffer[position + 3]);
        return {
          type: "Literal",
          start: buffer[position],
          end: buffer[position + 1],
          raw: `/${pattern2}/${flags}`,
          regex: { flags, pattern: pattern2 },
          value: new RegExp(pattern2, flags)
        };
      },
      function literalString(position, buffer) {
        const rawPosition = buffer[position + 3];
        return {
          type: "Literal",
          start: buffer[position],
          end: buffer[position + 1],
          value: buffer.convertString(buffer[position + 2]),
          raw: rawPosition === 0 ? void 0 : buffer.convertString(rawPosition)
        };
      },
      function logicalExpression(position, buffer) {
        return {
          type: "LogicalExpression",
          start: buffer[position],
          end: buffer[position + 1],
          operator: FIXED_STRINGS[buffer[position + 2]],
          left: convertNode(buffer[position + 3], buffer),
          right: convertNode(buffer[position + 4], buffer)
        };
      },
      function memberExpression(position, buffer) {
        const flags = buffer[position + 2];
        return {
          type: "MemberExpression",
          start: buffer[position],
          end: buffer[position + 1],
          computed: (flags & 1) === 1,
          optional: (flags & 2) === 2,
          object: convertNode(buffer[position + 3], buffer),
          property: convertNode(buffer[position + 4], buffer)
        };
      },
      function metaProperty(position, buffer) {
        return {
          type: "MetaProperty",
          start: buffer[position],
          end: buffer[position + 1],
          meta: convertNode(buffer[position + 2], buffer),
          property: convertNode(buffer[position + 3], buffer)
        };
      },
      function methodDefinition(position, buffer) {
        const flags = buffer[position + 2];
        return {
          type: "MethodDefinition",
          start: buffer[position],
          end: buffer[position + 1],
          static: (flags & 1) === 1,
          computed: (flags & 2) === 2,
          decorators: convertNodeList(buffer[position + 3], buffer),
          key: convertNode(buffer[position + 4], buffer),
          value: convertNode(buffer[position + 5], buffer),
          kind: FIXED_STRINGS[buffer[position + 6]]
        };
      },
      function newExpression(position, buffer) {
        const annotations = convertAnnotations(buffer[position + 2], buffer);
        return {
          type: "NewExpression",
          start: buffer[position],
          end: buffer[position + 1],
          ...annotations.length > 0 ? { [ANNOTATION_KEY]: annotations } : {},
          callee: convertNode(buffer[position + 3], buffer),
          arguments: convertNodeList(buffer[position + 4], buffer)
        };
      },
      function objectExpression(position, buffer) {
        return {
          type: "ObjectExpression",
          start: buffer[position],
          end: buffer[position + 1],
          properties: convertNodeList(buffer[position + 2], buffer)
        };
      },
      function objectPattern(position, buffer) {
        return {
          type: "ObjectPattern",
          start: buffer[position],
          end: buffer[position + 1],
          properties: convertNodeList(buffer[position + 2], buffer)
        };
      },
      function privateIdentifier(position, buffer) {
        return {
          type: "PrivateIdentifier",
          start: buffer[position],
          end: buffer[position + 1],
          name: buffer.convertString(buffer[position + 2])
        };
      },
      function program(position, buffer) {
        const invalidAnnotations = convertAnnotations(buffer[position + 3], buffer);
        return {
          type: "Program",
          start: buffer[position],
          end: buffer[position + 1],
          body: convertNodeList(buffer[position + 2], buffer),
          ...invalidAnnotations.length > 0 ? { [INVALID_ANNOTATION_KEY]: invalidAnnotations } : {},
          sourceType: "module"
        };
      },
      function property(position, buffer) {
        const flags = buffer[position + 2];
        const keyPosition = buffer[position + 3];
        const value2 = convertNode(buffer[position + 4], buffer);
        return {
          type: "Property",
          start: buffer[position],
          end: buffer[position + 1],
          method: (flags & 1) === 1,
          shorthand: (flags & 2) === 2,
          computed: (flags & 4) === 4,
          key: keyPosition === 0 ? { ...value2 } : convertNode(keyPosition, buffer),
          value: value2,
          kind: FIXED_STRINGS[buffer[position + 5]]
        };
      },
      function propertyDefinition(position, buffer) {
        const flags = buffer[position + 2];
        const valuePosition = buffer[position + 5];
        return {
          type: "PropertyDefinition",
          start: buffer[position],
          end: buffer[position + 1],
          static: (flags & 1) === 1,
          computed: (flags & 2) === 2,
          decorators: convertNodeList(buffer[position + 3], buffer),
          key: convertNode(buffer[position + 4], buffer),
          value: valuePosition === 0 ? null : convertNode(valuePosition, buffer)
        };
      },
      function restElement(position, buffer) {
        return {
          type: "RestElement",
          start: buffer[position],
          end: buffer[position + 1],
          argument: convertNode(buffer[position + 2], buffer)
        };
      },
      function returnStatement(position, buffer) {
        const argumentPosition = buffer[position + 2];
        return {
          type: "ReturnStatement",
          start: buffer[position],
          end: buffer[position + 1],
          argument: argumentPosition === 0 ? null : convertNode(argumentPosition, buffer)
        };
      },
      function sequenceExpression(position, buffer) {
        return {
          type: "SequenceExpression",
          start: buffer[position],
          end: buffer[position + 1],
          expressions: convertNodeList(buffer[position + 2], buffer)
        };
      },
      function spreadElement(position, buffer) {
        return {
          type: "SpreadElement",
          start: buffer[position],
          end: buffer[position + 1],
          argument: convertNode(buffer[position + 2], buffer)
        };
      },
      function staticBlock(position, buffer) {
        return {
          type: "StaticBlock",
          start: buffer[position],
          end: buffer[position + 1],
          body: convertNodeList(buffer[position + 2], buffer)
        };
      },
      function superElement(position, buffer) {
        return {
          type: "Super",
          start: buffer[position],
          end: buffer[position + 1]
        };
      },
      function switchCase(position, buffer) {
        const testPosition = buffer[position + 2];
        return {
          type: "SwitchCase",
          start: buffer[position],
          end: buffer[position + 1],
          test: testPosition === 0 ? null : convertNode(testPosition, buffer),
          consequent: convertNodeList(buffer[position + 3], buffer)
        };
      },
      function switchStatement(position, buffer) {
        return {
          type: "SwitchStatement",
          start: buffer[position],
          end: buffer[position + 1],
          discriminant: convertNode(buffer[position + 2], buffer),
          cases: convertNodeList(buffer[position + 3], buffer)
        };
      },
      function taggedTemplateExpression(position, buffer) {
        return {
          type: "TaggedTemplateExpression",
          start: buffer[position],
          end: buffer[position + 1],
          tag: convertNode(buffer[position + 2], buffer),
          quasi: convertNode(buffer[position + 3], buffer)
        };
      },
      function templateElement(position, buffer) {
        const flags = buffer[position + 2];
        const cookedPosition = buffer[position + 3];
        const cooked = cookedPosition === 0 ? void 0 : buffer.convertString(cookedPosition);
        const raw = buffer.convertString(buffer[position + 4]);
        return {
          type: "TemplateElement",
          start: buffer[position],
          end: buffer[position + 1],
          tail: (flags & 1) === 1,
          value: { cooked, raw }
        };
      },
      function templateLiteral(position, buffer) {
        return {
          type: "TemplateLiteral",
          start: buffer[position],
          end: buffer[position + 1],
          quasis: convertNodeList(buffer[position + 2], buffer),
          expressions: convertNodeList(buffer[position + 3], buffer)
        };
      },
      function thisExpression(position, buffer) {
        return {
          type: "ThisExpression",
          start: buffer[position],
          end: buffer[position + 1]
        };
      },
      function throwStatement(position, buffer) {
        return {
          type: "ThrowStatement",
          start: buffer[position],
          end: buffer[position + 1],
          argument: convertNode(buffer[position + 2], buffer)
        };
      },
      function tryStatement(position, buffer) {
        const handlerPosition = buffer[position + 3];
        const finalizerPosition = buffer[position + 4];
        return {
          type: "TryStatement",
          start: buffer[position],
          end: buffer[position + 1],
          block: convertNode(buffer[position + 2], buffer),
          handler: handlerPosition === 0 ? null : convertNode(handlerPosition, buffer),
          finalizer: finalizerPosition === 0 ? null : convertNode(finalizerPosition, buffer)
        };
      },
      function unaryExpression(position, buffer) {
        return {
          type: "UnaryExpression",
          start: buffer[position],
          end: buffer[position + 1],
          operator: FIXED_STRINGS[buffer[position + 2]],
          argument: convertNode(buffer[position + 3], buffer),
          prefix: true
        };
      },
      function updateExpression(position, buffer) {
        const flags = buffer[position + 2];
        return {
          type: "UpdateExpression",
          start: buffer[position],
          end: buffer[position + 1],
          prefix: (flags & 1) === 1,
          operator: FIXED_STRINGS[buffer[position + 3]],
          argument: convertNode(buffer[position + 4], buffer)
        };
      },
      function variableDeclaration(position, buffer) {
        return {
          type: "VariableDeclaration",
          start: buffer[position],
          end: buffer[position + 1],
          kind: FIXED_STRINGS[buffer[position + 2]],
          declarations: convertNodeList(buffer[position + 3], buffer)
        };
      },
      function variableDeclarator(position, buffer) {
        const initPosition = buffer[position + 3];
        return {
          type: "VariableDeclarator",
          start: buffer[position],
          end: buffer[position + 1],
          id: convertNode(buffer[position + 2], buffer),
          init: initPosition === 0 ? null : convertNode(initPosition, buffer)
        };
      },
      function whileStatement(position, buffer) {
        return {
          type: "WhileStatement",
          start: buffer[position],
          end: buffer[position + 1],
          test: convertNode(buffer[position + 2], buffer),
          body: convertNode(buffer[position + 3], buffer)
        };
      },
      function yieldExpression(position, buffer) {
        const flags = buffer[position + 2];
        const argumentPosition = buffer[position + 3];
        return {
          type: "YieldExpression",
          start: buffer[position],
          end: buffer[position + 1],
          delegate: (flags & 1) === 1,
          argument: argumentPosition === 0 ? null : convertNode(argumentPosition, buffer)
        };
      }
    ];
    parseAst = (input, { allowReturnOutsideFunction = false, jsx = false } = {}) => convertProgram(getAstBuffer(parse(input, allowReturnOutsideFunction, jsx)));
    parseAstAsync = async (input, { allowReturnOutsideFunction = false, jsx = false, signal } = {}) => convertProgram(getAstBuffer(await parseAsync(input, allowReturnOutsideFunction, jsx, signal)));
    exports2 = { ANNOTATION_KEY, ArrowFunctionExpression, BLANK, BlockStatement, CallExpression, CatchClause, EMPTY_ARRAY, EMPTY_OBJECT, EMPTY_SET, ExportDefaultDeclaration, ExpressionStatement, FIXED_STRINGS, INVALID_ANNOTATION_KEY, Identifier, LOGLEVEL_DEBUG, LOGLEVEL_ERROR, LOGLEVEL_INFO, LOGLEVEL_WARN, Literal, Program, Property, ReturnStatement, StaticBlock, TemplateLiteral, URL_GENERATEBUNDLE, URL_JSX, URL_OUTPUT_AMD_BASEPATH, URL_OUTPUT_AMD_ID, URL_OUTPUT_DIR, URL_OUTPUT_EXTERNALIMPORTATTRIBUTES, URL_OUTPUT_FORMAT, URL_OUTPUT_GENERATEDCODE, URL_OUTPUT_INLINEDYNAMICIMPORTS, URL_OUTPUT_INTEROP, URL_OUTPUT_MANUALCHUNKS, URL_OUTPUT_SOURCEMAPBASEURL, URL_OUTPUT_SOURCEMAPFILE, URL_PRESERVEENTRYSIGNATURES, URL_TREESHAKE, URL_TREESHAKE_MODULESIDEEFFECTS, URL_WATCH, VariableDeclarator, addTrailingSlashIfMissed, augmentCodeLocation, augmentLogMessage, convertAnnotations, convertNode, error, getAliasName, getAstBuffer, getImportPath, getRollupError, isAbsolute, isPathFragment, isRelative, isValidUrl, locate, logAddonNotGenerated, logAlreadyClosed, logAmbiguousExternalNamespaces, logAnonymousPluginCache, logAssetNotFinalisedForFileName, logAssetReferenceIdNotFoundForSetSource, logAssetSourceAlreadySet, logBadLoader, logCannotAssignModuleToChunk, logCannotCallNamespace, logCannotEmitFromOptionsHook, logChunkInvalid, logChunkNotGeneratedForFileName, logCircularDependency, logCircularReexport, logConflictingSourcemapSources, logConstVariableReassignError, logCyclicCrossChunkReexport, logDuplicateArgumentNameError, logDuplicateExportError, logDuplicatePluginName, logEmptyChunk, logEntryCannotBeExternal, logEval, logExternalModulesCannotBeIncludedInManualChunks, logExternalModulesCannotBeTransformedToModules, logExternalSyntheticExports, logFailedValidation, logFileNameConflict, logFileReferenceIdNotFoundForFilename, logFirstSideEffect, logIllegalIdentifierAsName, logIllegalImportReassignment, logImplicitDependantCannotBeExternal, logImplicitDependantIsNotIncluded, logImportAttributeIsInvalid, logImportOptionsAreInvalid, logIncompatibleExportOptionValue, logInconsistentImportAttributes, logInputHookInOutputPlugin, logInternalIdCannotBeExternal, logInvalidAddonPluginHook, logInvalidAnnotation, logInvalidExportOptionValue, logInvalidFormatForTopLevelAwait, logInvalidFunctionPluginHook, logInvalidLogPosition, logInvalidOption, logInvalidRollupPhaseForChunkEmission, logInvalidSetAssetSourceCall, logInvalidSourcemapForError, logLevelPriority, logMissingEntryExport, logMissingExport, logMissingFileOrDirOption, logMissingGlobalName, logMissingJsxExport, logMissingNameOptionForIifeExport, logMissingNameOptionForUmdExport, logMissingNodeBuiltins, logMixedExport, logModuleLevelDirective, logModuleParseError, logNamespaceConflict, logNoAssetSourceSet, logNoTransformMapOrAstWithoutCode, logOptimizeChunkStatus, logParseError, logPluginError, logRedeclarationError, logReservedNamespace, logShimmedExport, logSourcemapBroken, logSyntheticNamedExportsNeedNamespaceExport, logThisIsUndefined, logUnexpectedNamedImport, logUnexpectedNamespaceReexport, logUnknownOption, logUnresolvedEntry, logUnresolvedImplicitDependant, logUnresolvedImport, logUnresolvedImportTreatedAsExternal, logUnusedExternalImports, normalize, parseAst, parseAstAsync, printQuotedStringList, relative, relativeId, warnDeprecation };
    parseAst_default = exports2;
  }
});

// ../rollup/parseAst.js
import "node:path";
var parseAst2, parseAstAsync2, parseAst_default2;
var init_parseAst2 = __esm({
  "../rollup/parseAst.js"() {
    init_native();
    init_parseAst();
    parseAst2 = parseAst_default.parseAst;
    parseAstAsync2 = parseAst_default.parseAstAsync;
    parseAst_default2 = exports;
  }
});

// dist/node/chunks/dep-IQS-Za7F.js
import { fileURLToPath as __cjs_fileURLToPath } from "node:url";
import { dirname as __cjs_dirname } from "node:path";
import { createRequire as __cjs_createRequire } from "node:module";
function stringifyNode(node3, custom) {
  var type = node3.type;
  var value2 = node3.value;
  var buf;
  var customResult;
  if (custom && (customResult = custom(node3)) !== void 0) {
    return customResult;
  } else if (type === "word" || type === "space") {
    return value2;
  } else if (type === "string") {
    buf = node3.quote || "";
    return buf + value2 + (node3.unclosed ? "" : buf);
  } else if (type === "comment") {
    return "/*" + value2 + (node3.unclosed ? "" : "*/");
  } else if (type === "div") {
    return (node3.before || "") + value2 + (node3.after || "");
  } else if (Array.isArray(node3.nodes)) {
    buf = stringify$1(node3.nodes, custom);
    if (type !== "function") {
      return buf;
    }
    return value2 + "(" + (node3.before || "") + buf + (node3.after || "") + (node3.unclosed ? "" : ")");
  }
  return value2;
}
function stringify$1(nodes, custom) {
  var result, i14;
  if (Array.isArray(nodes)) {
    result = "";
    for (i14 = nodes.length - 1; ~i14; i14 -= 1) {
      result = stringifyNode(nodes[i14], custom) + result;
    }
    return result;
  }
  return stringifyNode(nodes, custom);
}
function requireUnit() {
  if (hasRequiredUnit) return unit;
  hasRequiredUnit = 1;
  var minus = "-".charCodeAt(0);
  var plus3 = "+".charCodeAt(0);
  var dot = ".".charCodeAt(0);
  var exp = "e".charCodeAt(0);
  var EXP = "E".charCodeAt(0);
  function likeNumber(value2) {
    var code = value2.charCodeAt(0);
    var nextCode;
    if (code === plus3 || code === minus) {
      nextCode = value2.charCodeAt(1);
      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }
      var nextNextCode = value2.charCodeAt(2);
      if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
        return true;
      }
      return false;
    }
    if (code === dot) {
      nextCode = value2.charCodeAt(1);
      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }
      return false;
    }
    if (code >= 48 && code <= 57) {
      return true;
    }
    return false;
  }
  unit = function(value2) {
    var pos = 0;
    var length = value2.length;
    var code;
    var nextCode;
    var nextNextCode;
    if (length === 0 || !likeNumber(value2)) {
      return false;
    }
    code = value2.charCodeAt(pos);
    if (code === plus3 || code === minus) {
      pos++;
    }
    while (pos < length) {
      code = value2.charCodeAt(pos);
      if (code < 48 || code > 57) {
        break;
      }
      pos += 1;
    }
    code = value2.charCodeAt(pos);
    nextCode = value2.charCodeAt(pos + 1);
    if (code === dot && nextCode >= 48 && nextCode <= 57) {
      pos += 2;
      while (pos < length) {
        code = value2.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
    }
    code = value2.charCodeAt(pos);
    nextCode = value2.charCodeAt(pos + 1);
    nextNextCode = value2.charCodeAt(pos + 2);
    if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus3 || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
      pos += nextCode === plus3 || nextCode === minus ? 3 : 2;
      while (pos < length) {
        code = value2.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
    }
    return {
      number: value2.slice(0, pos),
      unit: value2.slice(pos)
    };
  };
  return unit;
}
function ValueParser(value2) {
  if (this instanceof ValueParser) {
    this.nodes = parse2(value2);
    return this;
  }
  return new ValueParser(value2);
}
var __filename, __dirname, require3, openParentheses, closeParentheses, singleQuote, doubleQuote, backslash, slash, comma, colon, star, uLower, uUpper, plus, isUnicodeRange, parse$1, walk$1, stringify_1, unit, hasRequiredUnit, parse2, walk2, stringify, lib;
var init_dep_IQS_Za7F = __esm({
  "dist/node/chunks/dep-IQS-Za7F.js"() {
    __filename = __cjs_fileURLToPath(import.meta.url);
    __dirname = __cjs_dirname(__filename);
    require3 = __cjs_createRequire(import.meta.url);
    openParentheses = "(".charCodeAt(0);
    closeParentheses = ")".charCodeAt(0);
    singleQuote = "'".charCodeAt(0);
    doubleQuote = '"'.charCodeAt(0);
    backslash = "\\".charCodeAt(0);
    slash = "/".charCodeAt(0);
    comma = ",".charCodeAt(0);
    colon = ":".charCodeAt(0);
    star = "*".charCodeAt(0);
    uLower = "u".charCodeAt(0);
    uUpper = "U".charCodeAt(0);
    plus = "+".charCodeAt(0);
    isUnicodeRange = /^[a-f0-9?-]+$/i;
    parse$1 = function(input) {
      var tokens = [];
      var value2 = input;
      var next, quote3, prev, token, escape2, escapePos, whitespacePos, parenthesesOpenPos;
      var pos = 0;
      var code = value2.charCodeAt(pos);
      var max = value2.length;
      var stack = [{ nodes: tokens }];
      var balanced2 = 0;
      var parent;
      var name2 = "";
      var before = "";
      var after = "";
      while (pos < max) {
        if (code <= 32) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          token = value2.slice(pos, next);
          prev = tokens[tokens.length - 1];
          if (code === closeParentheses && balanced2) {
            after = token;
          } else if (prev && prev.type === "div") {
            prev.after = token;
            prev.sourceEndIndex += token.length;
          } else if (code === comma || code === colon || code === slash && value2.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
            before = token;
          } else {
            tokens.push({
              type: "space",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        } else if (code === singleQuote || code === doubleQuote) {
          next = pos;
          quote3 = code === singleQuote ? "'" : '"';
          token = {
            type: "string",
            sourceIndex: pos,
            quote: quote3
          };
          do {
            escape2 = false;
            next = value2.indexOf(quote3, next + 1);
            if (~next) {
              escapePos = next;
              while (value2.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape2 = !escape2;
              }
            } else {
              value2 += quote3;
              next = value2.length - 1;
              token.unclosed = true;
            }
          } while (escape2);
          token.value = value2.slice(pos + 1, next);
          token.sourceEndIndex = token.unclosed ? next : next + 1;
          tokens.push(token);
          pos = next + 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash && value2.charCodeAt(pos + 1) === star) {
          next = value2.indexOf("*/", pos);
          token = {
            type: "comment",
            sourceIndex: pos,
            sourceEndIndex: next + 2
          };
          if (next === -1) {
            token.unclosed = true;
            next = value2.length;
            token.sourceEndIndex = next;
          }
          token.value = value2.slice(pos + 2, next);
          tokens.push(token);
          pos = next + 2;
          code = value2.charCodeAt(pos);
        } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
          token = value2[pos];
          tokens.push({
            type: "word",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token
          });
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash || code === comma || code === colon) {
          token = value2[pos];
          tokens.push({
            type: "div",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token,
            before,
            after: ""
          });
          before = "";
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (openParentheses === code) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          parenthesesOpenPos = pos;
          token = {
            type: "function",
            sourceIndex: pos - name2.length,
            value: name2,
            before: value2.slice(parenthesesOpenPos + 1, next)
          };
          pos = next;
          if (name2 === "url" && code !== singleQuote && code !== doubleQuote) {
            next -= 1;
            do {
              escape2 = false;
              next = value2.indexOf(")", next + 1);
              if (~next) {
                escapePos = next;
                while (value2.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape2 = !escape2;
                }
              } else {
                value2 += ")";
                next = value2.length - 1;
                token.unclosed = true;
              }
            } while (escape2);
            whitespacePos = next;
            do {
              whitespacePos -= 1;
              code = value2.charCodeAt(whitespacePos);
            } while (code <= 32);
            if (parenthesesOpenPos < whitespacePos) {
              if (pos !== whitespacePos + 1) {
                token.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: whitespacePos + 1,
                    value: value2.slice(pos, whitespacePos + 1)
                  }
                ];
              } else {
                token.nodes = [];
              }
              if (token.unclosed && whitespacePos + 1 !== next) {
                token.after = "";
                token.nodes.push({
                  type: "space",
                  sourceIndex: whitespacePos + 1,
                  sourceEndIndex: next,
                  value: value2.slice(whitespacePos + 1, next)
                });
              } else {
                token.after = value2.slice(whitespacePos + 1, next);
                token.sourceEndIndex = next;
              }
            } else {
              token.after = "";
              token.nodes = [];
            }
            pos = next + 1;
            token.sourceEndIndex = token.unclosed ? next : pos;
            code = value2.charCodeAt(pos);
            tokens.push(token);
          } else {
            balanced2 += 1;
            token.after = "";
            token.sourceEndIndex = pos + 1;
            tokens.push(token);
            stack.push(token);
            tokens = token.nodes = [];
            parent = token;
          }
          name2 = "";
        } else if (closeParentheses === code && balanced2) {
          pos += 1;
          code = value2.charCodeAt(pos);
          parent.after = after;
          parent.sourceEndIndex += after.length;
          after = "";
          balanced2 -= 1;
          stack[stack.length - 1].sourceEndIndex = pos;
          stack.pop();
          parent = stack[balanced2];
          tokens = parent.nodes;
        } else {
          next = pos;
          do {
            if (code === backslash) {
              next += 1;
            }
            next += 1;
            code = value2.charCodeAt(next);
          } while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced2));
          token = value2.slice(pos, next);
          if (openParentheses === code) {
            name2 = token;
          } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
            tokens.push({
              type: "unicode-range",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          } else {
            tokens.push({
              type: "word",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        }
      }
      for (pos = stack.length - 1; pos; pos -= 1) {
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value2.length;
      }
      return stack[0].nodes;
    };
    walk$1 = function walk(nodes, cb, bubble) {
      var i14, max, node3, result;
      for (i14 = 0, max = nodes.length; i14 < max; i14 += 1) {
        node3 = nodes[i14];
        if (!bubble) {
          result = cb(node3, i14, nodes);
        }
        if (result !== false && node3.type === "function" && Array.isArray(node3.nodes)) {
          walk(node3.nodes, cb, bubble);
        }
        if (bubble) {
          cb(node3, i14, nodes);
        }
      }
    };
    stringify_1 = stringify$1;
    parse2 = parse$1;
    walk2 = walk$1;
    stringify = stringify_1;
    ValueParser.prototype.toString = function() {
      return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
    };
    ValueParser.prototype.walk = function(cb, bubble) {
      walk2(this.nodes, cb, bubble);
      return this;
    };
    ValueParser.unit = requireUnit();
    ValueParser.walk = walk2;
    ValueParser.stringify = stringify;
    lib = ValueParser;
  }
});

// dist/node/chunks/dep-GkhNNjoY.js
var dep_GkhNNjoY_exports = {};
__export(dep_GkhNNjoY_exports, {
  i: () => index$1
});
import require$$0 from "node:path";
import require$$0__default from "node:fs";
import { fileURLToPath as __cjs_fileURLToPath2 } from "node:url";
import { dirname as __cjs_dirname2 } from "node:path";
import { createRequire as __cjs_createRequire2 } from "node:module";
function _mergeNamespaces(n14, m23) {
  for (var i14 = 0; i14 < m23.length; i14++) {
    var e2 = m23[i14];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (var k13 in e2) {
        if (k13 !== "default" && !(k13 in n14)) {
          n14[k13] = e2[k13];
        }
      }
    }
  }
  return n14;
}
function convert(content, encoding) {
  if (Buffer.isEncoding(encoding)) {
    return content.toString(encoding);
  }
  return content;
}
function isValid(url2) {
  return anyDataURLRegexp.test(url2);
}
function contents(url2) {
  if (base64DataURLRegexp.test(url2)) {
    return Buffer.from(url2.slice(21), "base64").toString();
  }
  if (plainDataURLRegexp.test(url2)) {
    return decodeURIComponent(url2.slice(20));
  }
  return decodeURIComponent(url2.slice(14));
}
function parseCharset(result, atRule, conditions, from) {
  if (atRule.prev()) {
    return result.warn("@charset must precede all other statements", {
      node: atRule
    });
  }
  return {
    type: "charset",
    node: atRule,
    conditions: [...conditions],
    from
  };
}
function parseImport(result, atRule, conditions, from) {
  let prev = atRule.prev();
  if (prev) {
    do {
      if (prev.type === "comment" || prev.type === "atrule" && prev.name === "import") {
        prev = prev.prev();
        continue;
      }
      break;
    } while (prev);
  }
  if (prev) {
    do {
      if (prev.type === "comment" || prev.type === "atrule" && (prev.name === "charset" || prev.name === "layer" && !prev.nodes)) {
        prev = prev.prev();
        continue;
      }
      return result.warn(
        "@import must precede all other statements (besides @charset or empty @layer)",
        { node: atRule }
      );
    } while (prev);
  }
  if (atRule.nodes) {
    return result.warn(
      "It looks like you didn't end your @import statement correctly. Child nodes are attached to it.",
      { node: atRule }
    );
  }
  const params = valueParser(atRule.params).nodes;
  const stmt = {
    type: "import",
    uri: "",
    fullUri: "",
    node: atRule,
    conditions: [...conditions],
    from
  };
  let layer;
  let media;
  let supports;
  for (let i14 = 0; i14 < params.length; i14++) {
    const node3 = params[i14];
    if (node3.type === "space" || node3.type === "comment") continue;
    if (node3.type === "string") {
      if (stmt.uri) {
        return result.warn(`Multiple url's in '${atRule.toString()}'`, {
          node: atRule
        });
      }
      if (!node3.value) {
        return result.warn(`Unable to find uri in '${atRule.toString()}'`, {
          node: atRule
        });
      }
      stmt.uri = node3.value;
      stmt.fullUri = stringify2(node3);
      continue;
    }
    if (node3.type === "function" && /^url$/i.test(node3.value)) {
      if (stmt.uri) {
        return result.warn(`Multiple url's in '${atRule.toString()}'`, {
          node: atRule
        });
      }
      if (!node3.nodes?.[0]?.value) {
        return result.warn(`Unable to find uri in '${atRule.toString()}'`, {
          node: atRule
        });
      }
      stmt.uri = node3.nodes[0].value;
      stmt.fullUri = stringify2(node3);
      continue;
    }
    if (!stmt.uri) {
      return result.warn(`Unable to find uri in '${atRule.toString()}'`, {
        node: atRule
      });
    }
    if ((node3.type === "word" || node3.type === "function") && /^layer$/i.test(node3.value)) {
      if (typeof layer !== "undefined") {
        return result.warn(`Multiple layers in '${atRule.toString()}'`, {
          node: atRule
        });
      }
      if (typeof supports !== "undefined") {
        return result.warn(
          `layers must be defined before support conditions in '${atRule.toString()}'`,
          {
            node: atRule
          }
        );
      }
      if (node3.nodes) {
        layer = stringify2(node3.nodes);
      } else {
        layer = "";
      }
      continue;
    }
    if (node3.type === "function" && /^supports$/i.test(node3.value)) {
      if (typeof supports !== "undefined") {
        return result.warn(
          `Multiple support conditions in '${atRule.toString()}'`,
          {
            node: atRule
          }
        );
      }
      supports = stringify2(node3.nodes);
      continue;
    }
    media = stringify2(params.slice(i14));
    break;
  }
  if (!stmt.uri) {
    return result.warn(`Unable to find uri in '${atRule.toString()}'`, {
      node: atRule
    });
  }
  if (typeof media !== "undefined" || typeof layer !== "undefined" || typeof supports !== "undefined") {
    stmt.conditions.push({
      layer,
      media,
      supports
    });
  }
  return stmt;
}
function runPostcss(postcss2, content, filename, plugins2, parsers, index3) {
  if (!index3) index3 = 0;
  return postcss2(plugins2).process(content, {
    from: filename,
    parser: parsers[index3]
  }).catch((err) => {
    index3++;
    if (index3 === parsers.length) throw err;
    return runPostcss(postcss2, content, filename, plugins2, parsers, index3);
  });
}
async function parseStyles$1(result, styles, options2, state, conditions, from, postcss2) {
  const statements = parseStatements2(result, styles, conditions, from);
  for (const stmt of statements) {
    if (stmt.type !== "import" || !isProcessableURL(stmt.uri)) {
      continue;
    }
    if (options2.filter && !options2.filter(stmt.uri)) {
      continue;
    }
    await resolveImportId(result, stmt, options2, state, postcss2);
  }
  let charset;
  const imports2 = [];
  const bundle = [];
  function handleCharset(stmt) {
    if (!charset) charset = stmt;
    else if (stmt.node.params.toLowerCase() !== charset.node.params.toLowerCase()) {
      throw stmt.node.error(
        `Incompatible @charset statements:
  ${stmt.node.params} specified in ${stmt.node.source.input.file}
  ${charset.node.params} specified in ${charset.node.source.input.file}`
      );
    }
  }
  statements.forEach((stmt) => {
    if (stmt.type === "charset") handleCharset(stmt);
    else if (stmt.type === "import") {
      if (stmt.children) {
        stmt.children.forEach((child, index3) => {
          if (child.type === "import") imports2.push(child);
          else if (child.type === "charset") handleCharset(child);
          else bundle.push(child);
          if (index3 === 0) child.parent = stmt;
        });
      } else imports2.push(stmt);
    } else if (stmt.type === "nodes") {
      bundle.push(stmt);
    }
  });
  return charset ? [charset, ...imports2.concat(bundle)] : imports2.concat(bundle);
}
async function resolveImportId(result, stmt, options2, state, postcss2) {
  if (dataURL.isValid(stmt.uri)) {
    stmt.children = await loadImportContent(
      result,
      stmt,
      stmt.uri,
      options2,
      state,
      postcss2
    );
    return;
  } else if (dataURL.isValid(stmt.from.slice(-1))) {
    throw stmt.node.error(
      `Unable to import '${stmt.uri}' from a stylesheet that is embedded in a data url`
    );
  }
  const atRule = stmt.node;
  let sourceFile;
  if (atRule.source?.input?.file) {
    sourceFile = atRule.source.input.file;
  }
  const base = sourceFile ? path$1.dirname(atRule.source.input.file) : options2.root;
  const paths = [await options2.resolve(stmt.uri, base, options2, atRule)].flat();
  const resolved = await Promise.all(
    paths.map((file) => {
      return !path$1.isAbsolute(file) ? resolveId$1(file) : file;
    })
  );
  resolved.forEach((file) => {
    result.messages.push({
      type: "dependency",
      plugin: "postcss-import",
      file,
      parent: sourceFile
    });
  });
  const importedContent = await Promise.all(
    resolved.map((file) => {
      return loadImportContent(result, stmt, file, options2, state, postcss2);
    })
  );
  stmt.children = importedContent.flat().filter((x22) => !!x22);
}
async function loadImportContent(result, stmt, filename, options2, state, postcss2) {
  const atRule = stmt.node;
  const { conditions, from } = stmt;
  const stmtDuplicateCheckKey = conditions.map(
    (condition) => formatImportPrelude2(condition.layer, condition.media, condition.supports)
  ).join(":");
  if (options2.skipDuplicates) {
    if (state.importedFiles[filename]?.[stmtDuplicateCheckKey]) {
      return;
    }
    if (!state.importedFiles[filename]) {
      state.importedFiles[filename] = {};
    }
    state.importedFiles[filename][stmtDuplicateCheckKey] = true;
  }
  if (from.includes(filename)) {
    return;
  }
  const content = await options2.load(filename, options2);
  if (content.trim() === "" && options2.warnOnEmpty) {
    result.warn(`${filename} is empty`, { node: atRule });
    return;
  }
  if (options2.skipDuplicates && state.hashFiles[content]?.[stmtDuplicateCheckKey]) {
    return;
  }
  const importedResult = await processContent2(
    result,
    content,
    filename,
    options2,
    postcss2
  );
  const styles = importedResult.root;
  result.messages = result.messages.concat(importedResult.messages);
  if (options2.skipDuplicates) {
    const hasImport = styles.some((child) => {
      return child.type === "atrule" && child.name === "import";
    });
    if (!hasImport) {
      if (!state.hashFiles[content]) {
        state.hashFiles[content] = {};
      }
      state.hashFiles[content][stmtDuplicateCheckKey] = true;
    }
  }
  return parseStyles$1(
    result,
    styles,
    options2,
    state,
    conditions,
    [...from, filename],
    postcss2
  );
}
function isProcessableURL(uri) {
  if (/^(?:[a-z]+:)?\/\//i.test(uri)) {
    return false;
  }
  try {
    const url2 = new URL(uri, "https://example.com");
    if (url2.search) {
      return false;
    }
  } catch {
  }
  return true;
}
function AtImport(options2) {
  options2 = {
    root: process.cwd(),
    path: [],
    skipDuplicates: true,
    resolve: resolveId,
    load: loadContent2,
    plugins: [],
    addModulesDirectories: [],
    warnOnEmpty: true,
    ...options2
  };
  options2.root = path3.resolve(options2.root);
  if (typeof options2.path === "string") options2.path = [options2.path];
  if (!Array.isArray(options2.path)) options2.path = [];
  options2.path = options2.path.map((p20) => path3.resolve(options2.root, p20));
  return {
    postcssPlugin: "postcss-import",
    async Once(styles, { result, atRule, postcss: postcss2 }) {
      const state = {
        importedFiles: {},
        hashFiles: {}
      };
      if (styles.source?.input?.file) {
        state.importedFiles[styles.source.input.file] = {};
      }
      if (options2.plugins && !Array.isArray(options2.plugins)) {
        throw new Error("plugins option must be an array");
      }
      const bundle = await parseStyles(
        result,
        styles,
        options2,
        state,
        [],
        [],
        postcss2
      );
      applyRaws2(bundle);
      applyConditions2(bundle, atRule);
      applyStyles2(bundle, styles);
    }
  };
}
var __filename2, __dirname2, require4, __require, formatImportPrelude$2, formatImportPrelude$1, base64EncodedImport, base64EncodedConditionalImport2, applyConditions$1, applyRaws$1, applyStyles$1, readCache$1, pify$2, processFn, pify$1, pifyExports, fs2, path$3, pify, stat, readFile, resolve3, cache, readCacheExports, anyDataURLRegexp, base64DataURLRegexp, plainDataURLRegexp, dataUrl, readCache, dataURL$1, loadContent$1, valueParser, stringify2, parseStatements$1, path$2, sugarss, processContent$1, path$1, dataURL, parseStatements2, processContent2, resolveId$1, formatImportPrelude2, parseStyles_1, path3, applyConditions2, applyRaws2, applyStyles2, loadContent2, parseStyles, resolveId, postcssImport, index, index$1;
var init_dep_GkhNNjoY = __esm({
  "dist/node/chunks/dep-GkhNNjoY.js"() {
    init_dep_BWSbWtLw();
    init_dep_IQS_Za7F();
    __filename2 = __cjs_fileURLToPath2(import.meta.url);
    __dirname2 = __cjs_dirname2(__filename2);
    require4 = __cjs_createRequire2(import.meta.url);
    __require = require4;
    formatImportPrelude$2 = function formatImportPrelude(layer, media, supports) {
      const parts = [];
      if (typeof layer !== "undefined") {
        let layerParams = "layer";
        if (layer) {
          layerParams = `layer(${layer})`;
        }
        parts.push(layerParams);
      }
      if (typeof supports !== "undefined") {
        parts.push(`supports(${supports})`);
      }
      if (typeof media !== "undefined") {
        parts.push(media);
      }
      return parts.join(" ");
    };
    formatImportPrelude$1 = formatImportPrelude$2;
    base64EncodedImport = function base64EncodedConditionalImport(prelude, conditions) {
      conditions.reverse();
      const first2 = conditions.pop();
      let params = `${prelude} ${formatImportPrelude$1(
        first2.layer,
        first2.media,
        first2.supports
      )}`;
      for (const condition of conditions) {
        params = `'data:text/css;base64,${Buffer.from(`@import ${params}`).toString(
          "base64"
        )}' ${formatImportPrelude$1(
          condition.layer,
          condition.media,
          condition.supports
        )}`;
      }
      return params;
    };
    base64EncodedConditionalImport2 = base64EncodedImport;
    applyConditions$1 = function applyConditions(bundle, atRule) {
      bundle.forEach((stmt) => {
        if (stmt.type === "charset" || stmt.type === "warning" || !stmt.conditions?.length) {
          return;
        }
        if (stmt.type === "import") {
          stmt.node.params = base64EncodedConditionalImport2(
            stmt.fullUri,
            stmt.conditions
          );
          return;
        }
        const { nodes } = stmt;
        const { parent } = nodes[0];
        const atRules = [];
        for (const condition of stmt.conditions) {
          if (typeof condition.media !== "undefined") {
            const mediaNode = atRule({
              name: "media",
              params: condition.media,
              source: parent.source
            });
            atRules.push(mediaNode);
          }
          if (typeof condition.supports !== "undefined") {
            const supportsNode = atRule({
              name: "supports",
              params: `(${condition.supports})`,
              source: parent.source
            });
            atRules.push(supportsNode);
          }
          if (typeof condition.layer !== "undefined") {
            const layerNode = atRule({
              name: "layer",
              params: condition.layer,
              source: parent.source
            });
            atRules.push(layerNode);
          }
        }
        const outerAtRule = atRules.shift();
        const innerAtRule = atRules.reduce((previous, next) => {
          previous.append(next);
          return next;
        }, outerAtRule);
        parent.insertBefore(nodes[0], outerAtRule);
        nodes.forEach((node3) => {
          node3.parent = void 0;
        });
        nodes[0].raws.before = nodes[0].raws.before || "\n";
        innerAtRule.append(nodes);
        stmt.type = "nodes";
        stmt.nodes = [outerAtRule];
        delete stmt.node;
      });
    };
    applyRaws$1 = function applyRaws(bundle) {
      bundle.forEach((stmt, index3) => {
        if (index3 === 0) return;
        if (stmt.parent) {
          const { before } = stmt.parent.node.raws;
          if (stmt.type === "nodes") stmt.nodes[0].raws.before = before;
          else stmt.node.raws.before = before;
        } else if (stmt.type === "nodes") {
          stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || "\n";
        }
      });
    };
    applyStyles$1 = function applyStyles(bundle, styles) {
      styles.nodes = [];
      bundle.forEach((stmt) => {
        if (["charset", "import"].includes(stmt.type)) {
          stmt.node.parent = void 0;
          styles.append(stmt.node);
        } else if (stmt.type === "nodes") {
          stmt.nodes.forEach((node3) => {
            node3.parent = void 0;
            styles.append(node3);
          });
        }
      });
    };
    readCache$1 = { exports: {} };
    pify$2 = { exports: {} };
    processFn = function(fn, P11, opts) {
      return function() {
        var that = this;
        var args = new Array(arguments.length);
        for (var i14 = 0; i14 < arguments.length; i14++) {
          args[i14] = arguments[i14];
        }
        return new P11(function(resolve5, reject) {
          args.push(function(err, result) {
            if (err) {
              reject(err);
            } else if (opts.multiArgs) {
              var results = new Array(arguments.length - 1);
              for (var i15 = 1; i15 < arguments.length; i15++) {
                results[i15 - 1] = arguments[i15];
              }
              resolve5(results);
            } else {
              resolve5(result);
            }
          });
          fn.apply(that, args);
        });
      };
    };
    pify$1 = pify$2.exports = function(obj, P11, opts) {
      if (typeof P11 !== "function") {
        opts = P11;
        P11 = Promise;
      }
      opts = opts || {};
      opts.exclude = opts.exclude || [/.+Sync$/];
      var filter2 = function(key) {
        var match2 = function(pattern2) {
          return typeof pattern2 === "string" ? key === pattern2 : pattern2.test(key);
        };
        return opts.include ? opts.include.some(match2) : !opts.exclude.some(match2);
      };
      var ret = typeof obj === "function" ? function() {
        if (opts.excludeMain) {
          return obj.apply(this, arguments);
        }
        return processFn(obj, P11, opts).apply(this, arguments);
      } : {};
      return Object.keys(obj).reduce(function(ret2, key) {
        var x22 = obj[key];
        ret2[key] = typeof x22 === "function" && filter2(key) ? processFn(x22, P11, opts) : x22;
        return ret2;
      }, ret);
    };
    pify$1.all = pify$1;
    pifyExports = pify$2.exports;
    fs2 = require$$0__default;
    path$3 = require$$0;
    pify = pifyExports;
    stat = pify(fs2.stat);
    readFile = pify(fs2.readFile);
    resolve3 = path$3.resolve;
    cache = /* @__PURE__ */ Object.create(null);
    readCache$1.exports = function(path7, encoding) {
      path7 = resolve3(path7);
      return stat(path7).then(function(stats) {
        var item = cache[path7];
        if (item && item.mtime.getTime() === stats.mtime.getTime()) {
          return convert(item.content, encoding);
        }
        return readFile(path7).then(function(data) {
          cache[path7] = {
            mtime: stats.mtime,
            content: data
          };
          return convert(data, encoding);
        });
      }).catch(function(err) {
        cache[path7] = null;
        return Promise.reject(err);
      });
    };
    readCache$1.exports.sync = function(path7, encoding) {
      path7 = resolve3(path7);
      try {
        var stats = fs2.statSync(path7);
        var item = cache[path7];
        if (item && item.mtime.getTime() === stats.mtime.getTime()) {
          return convert(item.content, encoding);
        }
        var data = fs2.readFileSync(path7);
        cache[path7] = {
          mtime: stats.mtime,
          content: data
        };
        return convert(data, encoding);
      } catch (err) {
        cache[path7] = null;
        throw err;
      }
    };
    readCache$1.exports.get = function(path7, encoding) {
      path7 = resolve3(path7);
      if (cache[path7]) {
        return convert(cache[path7].content, encoding);
      }
      return null;
    };
    readCache$1.exports.clear = function() {
      cache = /* @__PURE__ */ Object.create(null);
    };
    readCacheExports = readCache$1.exports;
    anyDataURLRegexp = /^data:text\/css(?:;(base64|plain))?,/i;
    base64DataURLRegexp = /^data:text\/css;base64,/i;
    plainDataURLRegexp = /^data:text\/css;plain,/i;
    dataUrl = {
      isValid,
      contents
    };
    readCache = readCacheExports;
    dataURL$1 = dataUrl;
    loadContent$1 = function loadContent(filename) {
      if (dataURL$1.isValid(filename)) {
        return dataURL$1.contents(filename);
      }
      return readCache(filename, "utf-8");
    };
    valueParser = lib;
    ({ stringify: stringify2 } = valueParser);
    parseStatements$1 = function parseStatements(result, styles, conditions, from) {
      const statements = [];
      let nodes = [];
      styles.each((node3) => {
        let stmt;
        if (node3.type === "atrule") {
          if (node3.name === "import")
            stmt = parseImport(result, node3, conditions, from);
          else if (node3.name === "charset")
            stmt = parseCharset(result, node3, conditions, from);
        }
        if (stmt) {
          if (nodes.length) {
            statements.push({
              type: "nodes",
              nodes,
              conditions: [...conditions],
              from
            });
            nodes = [];
          }
          statements.push(stmt);
        } else nodes.push(node3);
      });
      if (nodes.length) {
        statements.push({
          type: "nodes",
          nodes,
          conditions: [...conditions],
          from
        });
      }
      return statements;
    };
    path$2 = require$$0;
    processContent$1 = function processContent(result, content, filename, options2, postcss2) {
      const { plugins: plugins2 } = options2;
      const ext2 = path$2.extname(filename);
      const parserList = [];
      if (ext2 === ".sss") {
        if (!sugarss) {
          try {
            sugarss = __require("sugarss");
          } catch {
          }
        }
        if (sugarss)
          return runPostcss(postcss2, content, filename, plugins2, [sugarss]);
      }
      if (result.opts.syntax?.parse) {
        parserList.push(result.opts.syntax.parse);
      }
      if (result.opts.parser) parserList.push(result.opts.parser);
      parserList.push(null);
      return runPostcss(postcss2, content, filename, plugins2, parserList);
    };
    path$1 = require$$0;
    dataURL = dataUrl;
    parseStatements2 = parseStatements$1;
    processContent2 = processContent$1;
    resolveId$1 = (id3) => id3;
    formatImportPrelude2 = formatImportPrelude$2;
    parseStyles_1 = parseStyles$1;
    path3 = require$$0;
    applyConditions2 = applyConditions$1;
    applyRaws2 = applyRaws$1;
    applyStyles2 = applyStyles$1;
    loadContent2 = loadContent$1;
    parseStyles = parseStyles_1;
    resolveId = (id3) => id3;
    AtImport.postcss = true;
    postcssImport = AtImport;
    index = /* @__PURE__ */ getDefaultExportFromCjs(postcssImport);
    index$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: index
    }, [postcssImport]);
  }
});

// https://esm.sh/v135/picocolors@1.1.0/denonext/picocolors.mjs
var picocolors_exports = {};
__export(picocolors_exports, {
  bgBlack: () => J,
  bgBlackBright: () => te,
  bgBlue: () => O,
  bgBlueBright: () => he,
  bgCyan: () => Q,
  bgCyanBright: () => ne,
  bgGreen: () => L,
  bgGreenBright: () => le2,
  bgMagenta: () => P,
  bgMagentaBright: () => be,
  bgRed: () => K,
  bgRedBright: () => ie,
  bgWhite: () => T,
  bgWhiteBright: () => Be,
  bgYellow: () => N,
  bgYellowBright: () => ae,
  black: () => j,
  blackBright: () => U,
  blue: () => D,
  blueBright: () => $,
  bold: () => v,
  createColors: () => oe,
  cyan: () => F,
  cyanBright: () => ge,
  default: () => ue2,
  dim: () => G,
  gray: () => I,
  green: () => z,
  greenBright: () => X,
  hidden: () => Y,
  inverse: () => W,
  isColorSupported: () => x,
  italic: () => M,
  magenta: () => E,
  magentaBright: () => ee,
  red: () => q,
  redBright: () => V,
  reset: () => _,
  strikethrough: () => S,
  underline: () => R,
  white: () => H,
  whiteBright: () => re,
  yellow: () => A,
  yellowBright: () => Z
});
var y, b, w, k, m, p, f, C, h, l, d, B, i, s, x, _, v, G, M, R, W, Y, S, j, q, z, A, D, E, F, H, I, J, K, L, N, O, P, Q, T, U, V, X, Z, $, ee, ge, re, te, ie, le2, ae, he, be, ne, Be, oe, c, de, ue2;
var init_picocolors = __esm({
  "https://esm.sh/v135/picocolors@1.1.0/denonext/picocolors.mjs"() {
    y = Object.create;
    b = Object.defineProperty;
    w = Object.getOwnPropertyDescriptor;
    k = Object.getOwnPropertyNames;
    m = Object.getPrototypeOf;
    p = Object.prototype.hasOwnProperty;
    f = (r9, g16) => () => (g16 || r9((g16 = { exports: {} }).exports, g16), g16.exports);
    C = (r9, g16) => {
      for (var t in g16) b(r9, t, { get: g16[t], enumerable: true });
    };
    h = (r9, g16, t, o10) => {
      if (g16 && typeof g16 == "object" || typeof g16 == "function") for (let a20 of k(g16)) !p.call(r9, a20) && a20 !== t && b(r9, a20, { get: () => g16[a20], enumerable: !(o10 = w(g16, a20)) || o10.enumerable });
      return r9;
    };
    l = (r9, g16, t) => (h(r9, g16, "default"), t && h(t, g16, "default"));
    d = (r9, g16, t) => (t = r9 != null ? y(m(r9)) : {}, h(g16 || !r9 || !r9.__esModule ? b(t, "default", { value: r9, enumerable: true }) : t, r9));
    B = f((se3, n14) => {
      var e2 = String, u17 = function() {
        return { isColorSupported: false, reset: e2, bold: e2, dim: e2, italic: e2, underline: e2, inverse: e2, hidden: e2, strikethrough: e2, black: e2, red: e2, green: e2, yellow: e2, blue: e2, magenta: e2, cyan: e2, white: e2, gray: e2, bgBlack: e2, bgRed: e2, bgGreen: e2, bgYellow: e2, bgBlue: e2, bgMagenta: e2, bgCyan: e2, bgWhite: e2, blackBright: e2, redBright: e2, greenBright: e2, yellowBright: e2, blueBright: e2, magentaBright: e2, cyanBright: e2, whiteBright: e2, bgBlackBright: e2, bgRedBright: e2, bgGreenBright: e2, bgYellowBright: e2, bgBlueBright: e2, bgMagentaBright: e2, bgCyanBright: e2, bgWhiteBright: e2 };
      };
      n14.exports = u17();
      n14.exports.createColors = u17;
    });
    i = {};
    C(i, { bgBlack: () => J, bgBlackBright: () => te, bgBlue: () => O, bgBlueBright: () => he, bgCyan: () => Q, bgCyanBright: () => ne, bgGreen: () => L, bgGreenBright: () => le2, bgMagenta: () => P, bgMagentaBright: () => be, bgRed: () => K, bgRedBright: () => ie, bgWhite: () => T, bgWhiteBright: () => Be, bgYellow: () => N, bgYellowBright: () => ae, black: () => j, blackBright: () => U, blue: () => D, blueBright: () => $, bold: () => v, createColors: () => oe, cyan: () => F, cyanBright: () => ge, default: () => ue2, dim: () => G, gray: () => I, green: () => z, greenBright: () => X, hidden: () => Y, inverse: () => W, isColorSupported: () => x, italic: () => M, magenta: () => E, magentaBright: () => ee, red: () => q, redBright: () => V, reset: () => _, strikethrough: () => S, underline: () => R, white: () => H, whiteBright: () => re, yellow: () => A, yellowBright: () => Z });
    s = d(B());
    l(i, d(B()));
    ({ isColorSupported: x, reset: _, bold: v, dim: G, italic: M, underline: R, inverse: W, hidden: Y, strikethrough: S, black: j, red: q, green: z, yellow: A, blue: D, magenta: E, cyan: F, white: H, gray: I, bgBlack: J, bgRed: K, bgGreen: L, bgYellow: N, bgBlue: O, bgMagenta: P, bgCyan: Q, bgWhite: T, blackBright: U, redBright: V, greenBright: X, yellowBright: Z, blueBright: $, magentaBright: ee, cyanBright: ge, whiteBright: re, bgBlackBright: te, bgRedBright: ie, bgGreenBright: le2, bgYellowBright: ae, bgBlueBright: he, bgMagentaBright: be, bgCyanBright: ne, bgWhiteBright: Be, createColors: oe } = s);
    ({ default: c, ...de } = s);
    ue2 = c !== void 0 ? c : de;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/tokenize.js
var tokenize_exports = {};
__export(tokenize_exports, {
  default: () => j2
});
var K2, U2, F2, W2, G2, Y2, v2, M2, T2, S2, x2, I2, C2, z2, H2, X2, j2;
var init_tokenize = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/tokenize.js"() {
    K2 = Object.create;
    U2 = Object.defineProperty;
    F2 = Object.getOwnPropertyDescriptor;
    W2 = Object.getOwnPropertyNames;
    G2 = Object.getPrototypeOf;
    Y2 = Object.prototype.hasOwnProperty;
    v2 = (r9, o10) => () => (o10 || r9((o10 = { exports: {} }).exports, o10), o10.exports);
    M2 = (r9, o10) => {
      for (var n14 in o10) U2(r9, n14, { get: o10[n14], enumerable: true });
    };
    T2 = (r9, o10, n14, c16) => {
      if (o10 && typeof o10 == "object" || typeof o10 == "function") for (let E11 of W2(o10)) !Y2.call(r9, E11) && E11 !== n14 && U2(r9, E11, { get: () => o10[E11], enumerable: !(c16 = F2(o10, E11)) || c16.enumerable });
      return r9;
    };
    S2 = (r9, o10, n14) => (T2(r9, o10, "default"), n14 && T2(n14, o10, "default"));
    x2 = (r9, o10, n14) => (n14 = r9 != null ? K2(G2(r9)) : {}, T2(o10 || !r9 || !r9.__esModule ? U2(n14, "default", { value: r9, enumerable: true }) : n14, r9));
    I2 = v2((J7, b18) => {
      "use strict";
      var O11 = /[\t\n\f\r "#'()/;[\\\]{}]/g, L8 = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, q16 = /.[\r\n"'(/\\]/, B10 = /[\da-f]/i;
      b18.exports = function(o10, n14 = {}) {
        let c16 = o10.css.valueOf(), E11 = n14.ignoreErrors, s12, _22, h20, e2, P11, a20, A15, d20, l10, g16, k13 = c16.length, t = 0, N12 = [], f15 = [];
        function w13() {
          return t;
        }
        function u17(i14) {
          throw o10.error("Unclosed " + i14, t);
        }
        function D8() {
          return f15.length === 0 && t >= k13;
        }
        function Q3(i14) {
          if (f15.length) return f15.pop();
          if (t >= k13) return;
          let R8 = i14 ? i14.ignoreUnclosed : false;
          switch (s12 = c16.charCodeAt(t), s12) {
            case 10:
            case 32:
            case 9:
            case 13:
            case 12: {
              e2 = t;
              do
                e2 += 1, s12 = c16.charCodeAt(e2);
              while (s12 === 32 || s12 === 10 || s12 === 9 || s12 === 13 || s12 === 12);
              a20 = ["space", c16.slice(t, e2)], t = e2 - 1;
              break;
            }
            case 91:
            case 93:
            case 123:
            case 125:
            case 58:
            case 59:
            case 41: {
              let p20 = String.fromCharCode(s12);
              a20 = [p20, p20, t];
              break;
            }
            case 40: {
              if (g16 = N12.length ? N12.pop()[1] : "", l10 = c16.charCodeAt(t + 1), g16 === "url" && l10 !== 39 && l10 !== 34 && l10 !== 32 && l10 !== 10 && l10 !== 9 && l10 !== 12 && l10 !== 13) {
                e2 = t;
                do {
                  if (A15 = false, e2 = c16.indexOf(")", e2 + 1), e2 === -1) if (E11 || R8) {
                    e2 = t;
                    break;
                  } else u17("bracket");
                  for (d20 = e2; c16.charCodeAt(d20 - 1) === 92; ) d20 -= 1, A15 = !A15;
                } while (A15);
                a20 = ["brackets", c16.slice(t, e2 + 1), t, e2], t = e2;
              } else e2 = c16.indexOf(")", t + 1), _22 = c16.slice(t, e2 + 1), e2 === -1 || q16.test(_22) ? a20 = ["(", "(", t] : (a20 = ["brackets", _22, t, e2], t = e2);
              break;
            }
            case 39:
            case 34: {
              P11 = s12 === 39 ? "'" : '"', e2 = t;
              do {
                if (A15 = false, e2 = c16.indexOf(P11, e2 + 1), e2 === -1) if (E11 || R8) {
                  e2 = t + 1;
                  break;
                } else u17("string");
                for (d20 = e2; c16.charCodeAt(d20 - 1) === 92; ) d20 -= 1, A15 = !A15;
              } while (A15);
              a20 = ["string", c16.slice(t, e2 + 1), t, e2], t = e2;
              break;
            }
            case 64: {
              O11.lastIndex = t + 1, O11.test(c16), O11.lastIndex === 0 ? e2 = c16.length - 1 : e2 = O11.lastIndex - 2, a20 = ["at-word", c16.slice(t, e2 + 1), t, e2], t = e2;
              break;
            }
            case 92: {
              for (e2 = t, h20 = true; c16.charCodeAt(e2 + 1) === 92; ) e2 += 1, h20 = !h20;
              if (s12 = c16.charCodeAt(e2 + 1), h20 && s12 !== 47 && s12 !== 32 && s12 !== 10 && s12 !== 9 && s12 !== 13 && s12 !== 12 && (e2 += 1, B10.test(c16.charAt(e2)))) {
                for (; B10.test(c16.charAt(e2 + 1)); ) e2 += 1;
                c16.charCodeAt(e2 + 1) === 32 && (e2 += 1);
              }
              a20 = ["word", c16.slice(t, e2 + 1), t, e2], t = e2;
              break;
            }
            default: {
              s12 === 47 && c16.charCodeAt(t + 1) === 42 ? (e2 = c16.indexOf("*/", t + 2) + 1, e2 === 0 && (E11 || R8 ? e2 = c16.length : u17("comment")), a20 = ["comment", c16.slice(t, e2 + 1), t, e2], t = e2) : (L8.lastIndex = t + 1, L8.test(c16), L8.lastIndex === 0 ? e2 = c16.length - 1 : e2 = L8.lastIndex - 2, a20 = ["word", c16.slice(t, e2 + 1), t, e2], N12.push(a20), t = e2);
              break;
            }
          }
          return t++, a20;
        }
        function m23(i14) {
          f15.push(i14);
        }
        return { back: m23, endOfFile: D8, nextToken: Q3, position: w13 };
      };
    });
    C2 = {};
    M2(C2, { default: () => j2 });
    z2 = x2(I2());
    S2(C2, x2(I2()));
    ({ default: H2, ...X2 } = z2);
    j2 = H2 !== void 0 ? H2 : X2;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/terminal-highlight.js
var terminal_highlight_exports = {};
__export(terminal_highlight_exports, {
  default: () => z3,
  registerInput: () => O2
});
var require5, h2, c2, x3, _2, I3, T3, f2, H3, b2, s2, a, y2, u, i2, m2, O2, d2, j3, z3;
var init_terminal_highlight = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/terminal-highlight.js"() {
    init_picocolors();
    init_tokenize();
    require5 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "picocolors":
          return e2(picocolors_exports);
        case "postcss/lib/tokenize":
          return e2(tokenize_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    h2 = Object.create;
    c2 = Object.defineProperty;
    x3 = Object.getOwnPropertyDescriptor;
    _2 = Object.getOwnPropertyNames;
    I3 = Object.getPrototypeOf;
    T3 = Object.prototype.hasOwnProperty;
    f2 = ((e2) => typeof require5 < "u" ? require5 : typeof Proxy < "u" ? new Proxy(e2, { get: (t, n14) => (typeof require5 < "u" ? require5 : t)[n14] }) : e2)(function(e2) {
      if (typeof require5 < "u") return require5.apply(this, arguments);
      throw Error('Dynamic require of "' + e2 + '" is not supported');
    });
    H3 = (e2, t) => () => (t || e2((t = { exports: {} }).exports, t), t.exports);
    b2 = (e2, t) => {
      for (var n14 in t) c2(e2, n14, { get: t[n14], enumerable: true });
    };
    s2 = (e2, t, n14, l10) => {
      if (t && typeof t == "object" || typeof t == "function") for (let o10 of _2(t)) !T3.call(e2, o10) && o10 !== n14 && c2(e2, o10, { get: () => t[o10], enumerable: !(l10 = x3(t, o10)) || l10.enumerable });
      return e2;
    };
    a = (e2, t, n14) => (s2(e2, t, "default"), n14 && s2(n14, t, "default"));
    y2 = (e2, t, n14) => (n14 = e2 != null ? h2(I3(e2)) : {}, s2(t || !e2 || !e2.__esModule ? c2(n14, "default", { value: e2, enumerable: true }) : n14, e2));
    u = H3((M6, w13) => {
      "use strict";
      var r9 = f2("picocolors"), E11 = f2("postcss/lib/tokenize"), g16;
      function q16(e2) {
        g16 = e2;
      }
      var F5 = { ";": r9.yellow, ":": r9.yellow, "(": r9.cyan, ")": r9.cyan, "[": r9.yellow, "]": r9.yellow, "{": r9.yellow, "}": r9.yellow, "at-word": r9.cyan, brackets: r9.cyan, call: r9.cyan, class: r9.yellow, comment: r9.gray, hash: r9.magenta, string: r9.green };
      function G4([e2, t], n14) {
        if (e2 === "word") {
          if (t[0] === ".") return "class";
          if (t[0] === "#") return "hash";
        }
        if (!n14.endOfFile()) {
          let l10 = n14.nextToken();
          if (n14.back(l10), l10[0] === "brackets" || l10[0] === "(") return "call";
        }
        return e2;
      }
      function p20(e2) {
        let t = E11(new g16(e2), { ignoreErrors: true }), n14 = "";
        for (; !t.endOfFile(); ) {
          let l10 = t.nextToken(), o10 = F5[G4(l10, t)];
          o10 ? n14 += l10[1].split(/\r?\n/).map((k13) => o10(k13)).join(`
`) : n14 += l10[1];
        }
        return n14;
      }
      p20.registerInput = q16;
      w13.exports = p20;
    });
    i2 = {};
    b2(i2, { default: () => z3, registerInput: () => O2 });
    m2 = y2(u());
    a(i2, y2(u()));
    ({ registerInput: O2 } = m2);
    ({ default: d2, ...j3 } = m2);
    z3 = d2 !== void 0 ? d2 : j3;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/css-syntax-error.js
var css_syntax_error_exports = {};
__export(css_syntax_error_exports, {
  default: () => J2
});
var require6, W3, p2, v3, z4, A2, B2, b3, D2, F3, g, u2, C3, x4, a2, G3, L2, I4, J2;
var init_css_syntax_error = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/css-syntax-error.js"() {
    init_picocolors();
    init_terminal_highlight();
    require6 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "picocolors":
          return e2(picocolors_exports);
        case "postcss/lib/terminal-highlight":
          return e2(terminal_highlight_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    W3 = Object.create;
    p2 = Object.defineProperty;
    v3 = Object.getOwnPropertyDescriptor;
    z4 = Object.getOwnPropertyNames;
    A2 = Object.getPrototypeOf;
    B2 = Object.prototype.hasOwnProperty;
    b3 = ((t) => typeof require6 < "u" ? require6 : typeof Proxy < "u" ? new Proxy(t, { get: (e2, i14) => (typeof require6 < "u" ? require6 : e2)[i14] }) : t)(function(t) {
      if (typeof require6 < "u") return require6.apply(this, arguments);
      throw Error('Dynamic require of "' + t + '" is not supported');
    });
    D2 = (t, e2) => () => (e2 || t((e2 = { exports: {} }).exports, e2), e2.exports);
    F3 = (t, e2) => {
      for (var i14 in e2) p2(t, i14, { get: e2[i14], enumerable: true });
    };
    g = (t, e2, i14, s12) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let r9 of z4(e2)) !B2.call(t, r9) && r9 !== i14 && p2(t, r9, { get: () => e2[r9], enumerable: !(s12 = v3(e2, r9)) || s12.enumerable });
      return t;
    };
    u2 = (t, e2, i14) => (g(t, e2, "default"), i14 && g(i14, e2, "default"));
    C3 = (t, e2, i14) => (i14 = t != null ? W3(A2(t)) : {}, g(e2 || !t || !t.__esModule ? p2(i14, "default", { value: t, enumerable: true }) : i14, t));
    x4 = D2((N12, E11) => {
      "use strict";
      var y20 = b3("picocolors"), _22 = b3("postcss/lib/terminal-highlight"), c16 = class t extends Error {
        constructor(e2, i14, s12, r9, h20, o10) {
          super(e2), this.name = "CssSyntaxError", this.reason = e2, h20 && (this.file = h20), r9 && (this.source = r9), o10 && (this.plugin = o10), typeof i14 < "u" && typeof s12 < "u" && (typeof i14 == "number" ? (this.line = i14, this.column = s12) : (this.line = i14.line, this.column = i14.column, this.endLine = s12.line, this.endColumn = s12.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, t);
        }
        setMessage() {
          this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
        }
        showSourceCode(e2) {
          if (!this.source) return "";
          let i14 = this.source;
          e2 == null && (e2 = y20.isColorSupported);
          let s12 = (n14) => n14, r9 = (n14) => n14, h20 = (n14) => n14;
          if (e2) {
            let { bold: n14, gray: m23, red: d20 } = y20.createColors(true);
            r9 = (l10) => n14(d20(l10)), s12 = (l10) => m23(l10), _22 && (h20 = (l10) => _22(l10));
          }
          let o10 = i14.split(/\r?\n/), S16 = Math.max(this.line - 3, 0), M6 = Math.min(this.line + 2, o10.length), k13 = String(M6).length;
          return o10.slice(S16, M6).map((n14, m23) => {
            let d20 = S16 + 1 + m23, l10 = " " + (" " + d20).slice(-k13) + " | ";
            if (d20 === this.line) {
              if (n14.length > 160) {
                let f15 = 20, w13 = Math.max(0, this.column - f15), T9 = Math.max(this.column + f15, this.endColumn + f15), j16 = n14.slice(w13, T9), H5 = s12(l10.replace(/\d/g, " ")) + n14.slice(0, Math.min(this.column - 1, f15 - 1)).replace(/[^\t]/g, " ");
                return r9(">") + s12(l10) + h20(j16) + `
 ` + H5 + r9("^");
              }
              let q16 = s12(l10.replace(/\d/g, " ")) + n14.slice(0, this.column - 1).replace(/[^\t]/g, " ");
              return r9(">") + s12(l10) + h20(n14) + `
 ` + q16 + r9("^");
            }
            return " " + s12(l10) + h20(n14);
          }).join(`
`);
        }
        toString() {
          let e2 = this.showSourceCode();
          return e2 && (e2 = `

` + e2 + `
`), this.name + ": " + this.message + e2;
        }
      };
      E11.exports = c16;
      c16.default = c16;
    });
    a2 = {};
    F3(a2, { default: () => J2 });
    G3 = C3(x4());
    u2(a2, C3(x4()));
    ({ default: L2, ...I4 } = G3);
    J2 = L2 !== void 0 ? L2 : I4;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/stringifier.js
var stringifier_exports = {};
__export(stringifier_exports, {
  default: () => x5
});
var g2, p3, k2, C4, v4, S3, B3, D3, o, n, b4, h3, s3, _3, y3, A3, x5;
var init_stringifier = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/stringifier.js"() {
    g2 = Object.create;
    p3 = Object.defineProperty;
    k2 = Object.getOwnPropertyDescriptor;
    C4 = Object.getOwnPropertyNames;
    v4 = Object.getPrototypeOf;
    S3 = Object.prototype.hasOwnProperty;
    B3 = (a20, e2) => () => (e2 || a20((e2 = { exports: {} }).exports, e2), e2.exports);
    D3 = (a20, e2) => {
      for (var t in e2) p3(a20, t, { get: e2[t], enumerable: true });
    };
    o = (a20, e2, t, r9) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let l10 of C4(e2)) !S3.call(a20, l10) && l10 !== t && p3(a20, l10, { get: () => e2[l10], enumerable: !(r9 = k2(e2, l10)) || r9.enumerable });
      return a20;
    };
    n = (a20, e2, t) => (o(a20, e2, "default"), t && o(t, e2, "default"));
    b4 = (a20, e2, t) => (t = a20 != null ? g2(v4(a20)) : {}, o(e2 || !a20 || !a20.__esModule ? p3(t, "default", { value: a20, enumerable: true }) : t, a20));
    h3 = B3(($6, m23) => {
      "use strict";
      var c16 = { after: `
`, beforeClose: `
`, beforeComment: `
`, beforeDecl: `
`, beforeOpen: " ", beforeRule: `
`, colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: false };
      function R8(a20) {
        return a20[0].toUpperCase() + a20.slice(1);
      }
      var w13 = class {
        constructor(e2) {
          this.builder = e2;
        }
        atrule(e2, t) {
          let r9 = "@" + e2.name, l10 = e2.params ? this.rawValue(e2, "params") : "";
          if (typeof e2.raws.afterName < "u" ? r9 += e2.raws.afterName : l10 && (r9 += " "), e2.nodes) this.block(e2, r9 + l10);
          else {
            let f15 = (e2.raws.between || "") + (t ? ";" : "");
            this.builder(r9 + l10 + f15, e2);
          }
        }
        beforeAfter(e2, t) {
          let r9;
          e2.type === "decl" ? r9 = this.raw(e2, null, "beforeDecl") : e2.type === "comment" ? r9 = this.raw(e2, null, "beforeComment") : t === "before" ? r9 = this.raw(e2, null, "beforeRule") : r9 = this.raw(e2, null, "beforeClose");
          let l10 = e2.parent, f15 = 0;
          for (; l10 && l10.type !== "root"; ) f15 += 1, l10 = l10.parent;
          if (r9.includes(`
`)) {
            let i14 = this.raw(e2, null, "indent");
            if (i14.length) for (let u17 = 0; u17 < f15; u17++) r9 += i14;
          }
          return r9;
        }
        block(e2, t) {
          let r9 = this.raw(e2, "between", "beforeOpen");
          this.builder(t + r9 + "{", e2, "start");
          let l10;
          e2.nodes && e2.nodes.length ? (this.body(e2), l10 = this.raw(e2, "after")) : l10 = this.raw(e2, "after", "emptyBody"), l10 && this.builder(l10), this.builder("}", e2, "end");
        }
        body(e2) {
          let t = e2.nodes.length - 1;
          for (; t > 0 && e2.nodes[t].type === "comment"; ) t -= 1;
          let r9 = this.raw(e2, "semicolon");
          for (let l10 = 0; l10 < e2.nodes.length; l10++) {
            let f15 = e2.nodes[l10], i14 = this.raw(f15, "before");
            i14 && this.builder(i14), this.stringify(f15, t !== l10 || r9);
          }
        }
        comment(e2) {
          let t = this.raw(e2, "left", "commentLeft"), r9 = this.raw(e2, "right", "commentRight");
          this.builder("/*" + t + e2.text + r9 + "*/", e2);
        }
        decl(e2, t) {
          let r9 = this.raw(e2, "between", "colon"), l10 = e2.prop + r9 + this.rawValue(e2, "value");
          e2.important && (l10 += e2.raws.important || " !important"), t && (l10 += ";"), this.builder(l10, e2);
        }
        document(e2) {
          this.body(e2);
        }
        raw(e2, t, r9) {
          let l10;
          if (r9 || (r9 = t), t && (l10 = e2.raws[t], typeof l10 < "u")) return l10;
          let f15 = e2.parent;
          if (r9 === "before" && (!f15 || f15.type === "root" && f15.first === e2 || f15 && f15.type === "document")) return "";
          if (!f15) return c16[r9];
          let i14 = e2.root();
          if (i14.rawCache || (i14.rawCache = {}), typeof i14.rawCache[r9] < "u") return i14.rawCache[r9];
          if (r9 === "before" || r9 === "after") return this.beforeAfter(e2, r9);
          {
            let u17 = "raw" + R8(r9);
            this[u17] ? l10 = this[u17](i14, e2) : i14.walk((d20) => {
              if (l10 = d20.raws[t], typeof l10 < "u") return false;
            });
          }
          return typeof l10 > "u" && (l10 = c16[r9]), i14.rawCache[r9] = l10, l10;
        }
        rawBeforeClose(e2) {
          let t;
          return e2.walk((r9) => {
            if (r9.nodes && r9.nodes.length > 0 && typeof r9.raws.after < "u") return t = r9.raws.after, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), false;
          }), t && (t = t.replace(/\S/g, "")), t;
        }
        rawBeforeComment(e2, t) {
          let r9;
          return e2.walkComments((l10) => {
            if (typeof l10.raws.before < "u") return r9 = l10.raws.before, r9.includes(`
`) && (r9 = r9.replace(/[^\n]+$/, "")), false;
          }), typeof r9 > "u" ? r9 = this.raw(t, null, "beforeDecl") : r9 && (r9 = r9.replace(/\S/g, "")), r9;
        }
        rawBeforeDecl(e2, t) {
          let r9;
          return e2.walkDecls((l10) => {
            if (typeof l10.raws.before < "u") return r9 = l10.raws.before, r9.includes(`
`) && (r9 = r9.replace(/[^\n]+$/, "")), false;
          }), typeof r9 > "u" ? r9 = this.raw(t, null, "beforeRule") : r9 && (r9 = r9.replace(/\S/g, "")), r9;
        }
        rawBeforeOpen(e2) {
          let t;
          return e2.walk((r9) => {
            if (r9.type !== "decl" && (t = r9.raws.between, typeof t < "u")) return false;
          }), t;
        }
        rawBeforeRule(e2) {
          let t;
          return e2.walk((r9) => {
            if (r9.nodes && (r9.parent !== e2 || e2.first !== r9) && typeof r9.raws.before < "u") return t = r9.raws.before, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), false;
          }), t && (t = t.replace(/\S/g, "")), t;
        }
        rawColon(e2) {
          let t;
          return e2.walkDecls((r9) => {
            if (typeof r9.raws.between < "u") return t = r9.raws.between.replace(/[^\s:]/g, ""), false;
          }), t;
        }
        rawEmptyBody(e2) {
          let t;
          return e2.walk((r9) => {
            if (r9.nodes && r9.nodes.length === 0 && (t = r9.raws.after, typeof t < "u")) return false;
          }), t;
        }
        rawIndent(e2) {
          if (e2.raws.indent) return e2.raws.indent;
          let t;
          return e2.walk((r9) => {
            let l10 = r9.parent;
            if (l10 && l10 !== e2 && l10.parent && l10.parent === e2 && typeof r9.raws.before < "u") {
              let f15 = r9.raws.before.split(`
`);
              return t = f15[f15.length - 1], t = t.replace(/\S/g, ""), false;
            }
          }), t;
        }
        rawSemicolon(e2) {
          let t;
          return e2.walk((r9) => {
            if (r9.nodes && r9.nodes.length && r9.last.type === "decl" && (t = r9.raws.semicolon, typeof t < "u")) return false;
          }), t;
        }
        rawValue(e2, t) {
          let r9 = e2[t], l10 = e2.raws[t];
          return l10 && l10.value === r9 ? l10.raw : r9;
        }
        root(e2) {
          this.body(e2), e2.raws.after && this.builder(e2.raws.after);
        }
        rule(e2) {
          this.block(e2, this.rawValue(e2, "selector")), e2.raws.ownSemicolon && this.builder(e2.raws.ownSemicolon, e2, "end");
        }
        stringify(e2, t) {
          if (!this[e2.type]) throw new Error("Unknown AST node type " + e2.type + ". Maybe you need to change PostCSS stringifier.");
          this[e2.type](e2, t);
        }
      };
      m23.exports = w13;
      w13.default = w13;
    });
    s3 = {};
    D3(s3, { default: () => x5 });
    _3 = b4(h3());
    n(s3, b4(h3()));
    ({ default: y3, ...A3 } = _3);
    x5 = y3 !== void 0 ? y3 : A3;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/stringify.js
var stringify_exports = {};
__export(stringify_exports, {
  default: () => k3
});
var require7, p4, o2, c3, g3, x6, y4, q2, w2, S4, n2, f3, _4, d3, i3, h4, m3, j4, k3;
var init_stringify = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/stringify.js"() {
    init_stringifier();
    require7 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/stringifier":
          return e2(stringifier_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    p4 = Object.create;
    o2 = Object.defineProperty;
    c3 = Object.getOwnPropertyDescriptor;
    g3 = Object.getOwnPropertyNames;
    x6 = Object.getPrototypeOf;
    y4 = Object.prototype.hasOwnProperty;
    q2 = ((t) => typeof require7 < "u" ? require7 : typeof Proxy < "u" ? new Proxy(t, { get: (e2, r9) => (typeof require7 < "u" ? require7 : e2)[r9] }) : t)(function(t) {
      if (typeof require7 < "u") return require7.apply(this, arguments);
      throw Error('Dynamic require of "' + t + '" is not supported');
    });
    w2 = (t, e2) => () => (e2 || t((e2 = { exports: {} }).exports, e2), e2.exports);
    S4 = (t, e2) => {
      for (var r9 in e2) o2(t, r9, { get: e2[r9], enumerable: true });
    };
    n2 = (t, e2, r9, l10) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let s12 of g3(e2)) !y4.call(t, s12) && s12 !== r9 && o2(t, s12, { get: () => e2[s12], enumerable: !(l10 = c3(e2, s12)) || l10.enumerable });
      return t;
    };
    f3 = (t, e2, r9) => (n2(t, e2, "default"), r9 && n2(r9, e2, "default"));
    _4 = (t, e2, r9) => (r9 = t != null ? p4(x6(t)) : {}, n2(e2 || !t || !t.__esModule ? o2(r9, "default", { value: t, enumerable: true }) : r9, t));
    d3 = w2((z11, a20) => {
      "use strict";
      var b18 = q2("postcss/lib/stringifier");
      function u17(t, e2) {
        new b18(e2).stringify(t);
      }
      a20.exports = u17;
      u17.default = u17;
    });
    i3 = {};
    S4(i3, { default: () => k3 });
    h4 = _4(d3());
    f3(i3, _4(d3()));
    ({ default: m3, ...j4 } = h4);
    k3 = m3 !== void 0 ? m3 : j4;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/symbols.js
var symbols_exports = {};
__export(symbols_exports, {
  default: () => k4,
  isClean: () => g4,
  my: () => h5
});
var _5, a3, x7, y5, c4, C5, b5, S5, m4, r, i4, d4, s4, u3, g4, h5, p5, j5, k4;
var init_symbols = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/symbols.js"() {
    _5 = Object.create;
    a3 = Object.defineProperty;
    x7 = Object.getOwnPropertyDescriptor;
    y5 = Object.getOwnPropertyNames;
    c4 = Object.getPrototypeOf;
    C5 = Object.prototype.hasOwnProperty;
    b5 = (t, e2) => () => (e2 || t((e2 = { exports: {} }).exports, e2), e2.exports);
    S5 = (t, e2) => {
      for (var o10 in e2) a3(t, o10, { get: e2[o10], enumerable: true });
    };
    m4 = (t, e2, o10, f15) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let l10 of y5(e2)) !C5.call(t, l10) && l10 !== o10 && a3(t, l10, { get: () => e2[l10], enumerable: !(f15 = x7(e2, l10)) || f15.enumerable });
      return t;
    };
    r = (t, e2, o10) => (m4(t, e2, "default"), o10 && m4(o10, e2, "default"));
    i4 = (t, e2, o10) => (o10 = t != null ? _5(c4(t)) : {}, m4(e2 || !t || !t.__esModule ? a3(o10, "default", { value: t, enumerable: true }) : o10, t));
    d4 = b5((v15, n14) => {
      "use strict";
      n14.exports.isClean = Symbol("isClean");
      n14.exports.my = Symbol("my");
    });
    s4 = {};
    S5(s4, { default: () => k4, isClean: () => g4, my: () => h5 });
    u3 = i4(d4());
    r(s4, i4(d4()));
    ({ isClean: g4, my: h5 } = u3);
    ({ default: p5, ...j5 } = u3);
    k4 = p5 !== void 0 ? p5 : j5;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/node.js
var node_exports = {};
__export(node_exports, {
  default: () => v5
});
var require8, S6, x8, g5, k5, C6, P2, d5, b6, A4, m5, h6, w3, p6, a4, $2, I5, q3, v5;
var init_node = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/node.js"() {
    init_css_syntax_error();
    init_stringifier();
    init_stringify();
    init_symbols();
    require8 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/css-syntax-error":
          return e2(css_syntax_error_exports);
        case "postcss/lib/stringifier":
          return e2(stringifier_exports);
        case "postcss/lib/stringify":
          return e2(stringify_exports);
        case "postcss/lib/symbols":
          return e2(symbols_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    S6 = Object.create;
    x8 = Object.defineProperty;
    g5 = Object.getOwnPropertyDescriptor;
    k5 = Object.getOwnPropertyNames;
    C6 = Object.getPrototypeOf;
    P2 = Object.prototype.hasOwnProperty;
    d5 = ((r9) => typeof require8 < "u" ? require8 : typeof Proxy < "u" ? new Proxy(r9, { get: (e2, t) => (typeof require8 < "u" ? require8 : e2)[t] }) : r9)(function(r9) {
      if (typeof require8 < "u") return require8.apply(this, arguments);
      throw Error('Dynamic require of "' + r9 + '" is not supported');
    });
    b6 = (r9, e2) => () => (e2 || r9((e2 = { exports: {} }).exports, e2), e2.exports);
    A4 = (r9, e2) => {
      for (var t in e2) x8(r9, t, { get: e2[t], enumerable: true });
    };
    m5 = (r9, e2, t, i14) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let n14 of k5(e2)) !P2.call(r9, n14) && n14 !== t && x8(r9, n14, { get: () => e2[n14], enumerable: !(i14 = g5(e2, n14)) || i14.enumerable });
      return r9;
    };
    h6 = (r9, e2, t) => (m5(r9, e2, "default"), t && m5(t, e2, "default"));
    w3 = (r9, e2, t) => (t = r9 != null ? S6(C6(r9)) : {}, m5(e2 || !r9 || !r9.__esModule ? x8(t, "default", { value: r9, enumerable: true }) : t, r9));
    p6 = b6((D8, O11) => {
      "use strict";
      var N12 = d5("postcss/lib/css-syntax-error"), B10 = d5("postcss/lib/stringifier"), _22 = d5("postcss/lib/stringify"), { isClean: f15, my: J7 } = d5("postcss/lib/symbols");
      function y20(r9, e2) {
        let t = new r9.constructor();
        for (let i14 in r9) {
          if (!Object.prototype.hasOwnProperty.call(r9, i14) || i14 === "proxyCache") continue;
          let n14 = r9[i14], l10 = typeof n14;
          i14 === "parent" && l10 === "object" ? e2 && (t[i14] = e2) : i14 === "source" ? t[i14] = n14 : Array.isArray(n14) ? t[i14] = n14.map((s12) => y20(s12, t)) : (l10 === "object" && n14 !== null && (n14 = y20(n14)), t[i14] = n14);
        }
        return t;
      }
      var c16 = class {
        constructor(e2 = {}) {
          this.raws = {}, this[f15] = false, this[J7] = true;
          for (let t in e2) if (t === "nodes") {
            this.nodes = [];
            for (let i14 of e2[t]) typeof i14.clone == "function" ? this.append(i14.clone()) : this.append(i14);
          } else this[t] = e2[t];
        }
        addToError(e2) {
          if (e2.postcssNode = this, e2.stack && this.source && /\n\s{4}at /.test(e2.stack)) {
            let t = this.source;
            e2.stack = e2.stack.replace(/\n\s{4}at /, `$&${t.input.from}:${t.start.line}:${t.start.column}$&`);
          }
          return e2;
        }
        after(e2) {
          return this.parent.insertAfter(this, e2), this;
        }
        assign(e2 = {}) {
          for (let t in e2) this[t] = e2[t];
          return this;
        }
        before(e2) {
          return this.parent.insertBefore(this, e2), this;
        }
        cleanRaws(e2) {
          delete this.raws.before, delete this.raws.after, e2 || delete this.raws.between;
        }
        clone(e2 = {}) {
          let t = y20(this);
          for (let i14 in e2) t[i14] = e2[i14];
          return t;
        }
        cloneAfter(e2 = {}) {
          let t = this.clone(e2);
          return this.parent.insertAfter(this, t), t;
        }
        cloneBefore(e2 = {}) {
          let t = this.clone(e2);
          return this.parent.insertBefore(this, t), t;
        }
        error(e2, t = {}) {
          if (this.source) {
            let { end: i14, start: n14 } = this.rangeBy(t);
            return this.source.input.error(e2, { column: n14.column, line: n14.line }, { column: i14.column, line: i14.line }, t);
          }
          return new N12(e2);
        }
        getProxyProcessor() {
          return { get(e2, t) {
            return t === "proxyOf" ? e2 : t === "root" ? () => e2.root().toProxy() : e2[t];
          }, set(e2, t, i14) {
            return e2[t] === i14 || (e2[t] = i14, (t === "prop" || t === "value" || t === "name" || t === "params" || t === "important" || t === "text") && e2.markDirty()), true;
          } };
        }
        markClean() {
          this[f15] = true;
        }
        markDirty() {
          if (this[f15]) {
            this[f15] = false;
            let e2 = this;
            for (; e2 = e2.parent; ) e2[f15] = false;
          }
        }
        next() {
          if (!this.parent) return;
          let e2 = this.parent.index(this);
          return this.parent.nodes[e2 + 1];
        }
        positionBy(e2, t) {
          let i14 = this.source.start;
          if (e2.index) i14 = this.positionInside(e2.index, t);
          else if (e2.word) {
            t = this.toString();
            let n14 = t.indexOf(e2.word);
            n14 !== -1 && (i14 = this.positionInside(n14, t));
          }
          return i14;
        }
        positionInside(e2, t) {
          let i14 = t || this.toString(), n14 = this.source.start.column, l10 = this.source.start.line;
          for (let s12 = 0; s12 < e2; s12++) i14[s12] === `
` ? (n14 = 1, l10 += 1) : n14 += 1;
          return { column: n14, line: l10 };
        }
        prev() {
          if (!this.parent) return;
          let e2 = this.parent.index(this);
          return this.parent.nodes[e2 - 1];
        }
        rangeBy(e2) {
          let t = { column: this.source.start.column, line: this.source.start.line }, i14 = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: t.column + 1, line: t.line };
          if (e2.word) {
            let n14 = this.toString(), l10 = n14.indexOf(e2.word);
            l10 !== -1 && (t = this.positionInside(l10, n14), i14 = this.positionInside(l10 + e2.word.length, n14));
          } else e2.start ? t = { column: e2.start.column, line: e2.start.line } : e2.index && (t = this.positionInside(e2.index)), e2.end ? i14 = { column: e2.end.column, line: e2.end.line } : typeof e2.endIndex == "number" ? i14 = this.positionInside(e2.endIndex) : e2.index && (i14 = this.positionInside(e2.index + 1));
          return (i14.line < t.line || i14.line === t.line && i14.column <= t.column) && (i14 = { column: t.column + 1, line: t.line }), { end: i14, start: t };
        }
        raw(e2, t) {
          return new B10().raw(this, e2, t);
        }
        remove() {
          return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
        }
        replaceWith(...e2) {
          if (this.parent) {
            let t = this, i14 = false;
            for (let n14 of e2) n14 === this ? i14 = true : i14 ? (this.parent.insertAfter(t, n14), t = n14) : this.parent.insertBefore(t, n14);
            i14 || this.remove();
          }
          return this;
        }
        root() {
          let e2 = this;
          for (; e2.parent && e2.parent.type !== "document"; ) e2 = e2.parent;
          return e2;
        }
        toJSON(e2, t) {
          let i14 = {}, n14 = t == null;
          t = t || /* @__PURE__ */ new Map();
          let l10 = 0;
          for (let s12 in this) {
            if (!Object.prototype.hasOwnProperty.call(this, s12) || s12 === "parent" || s12 === "proxyCache") continue;
            let o10 = this[s12];
            if (Array.isArray(o10)) i14[s12] = o10.map((u17) => typeof u17 == "object" && u17.toJSON ? u17.toJSON(null, t) : u17);
            else if (typeof o10 == "object" && o10.toJSON) i14[s12] = o10.toJSON(null, t);
            else if (s12 === "source") {
              let u17 = t.get(o10.input);
              u17 == null && (u17 = l10, t.set(o10.input, l10), l10++), i14[s12] = { end: o10.end, inputId: u17, start: o10.start };
            } else i14[s12] = o10;
          }
          return n14 && (i14.inputs = [...t.keys()].map((s12) => s12.toJSON())), i14;
        }
        toProxy() {
          return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
        }
        toString(e2 = _22) {
          e2.stringify && (e2 = e2.stringify);
          let t = "";
          return e2(this, (i14) => {
            t += i14;
          }), t;
        }
        warn(e2, t, i14) {
          let n14 = { node: this };
          for (let l10 in i14) n14[l10] = i14[l10];
          return e2.warn(t, n14);
        }
        get proxyOf() {
          return this;
        }
      };
      O11.exports = c16;
      c16.default = c16;
    });
    a4 = {};
    A4(a4, { default: () => v5 });
    $2 = w3(p6());
    h6(a4, w3(p6()));
    ({ default: I5, ...q3 } = $2);
    v5 = I5 !== void 0 ? I5 : q3;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/comment.js
var comment_exports = {};
__export(comment_exports, {
  default: () => v6
});
var require9, n3, l2, m6, x9, h7, q4, y6, N2, b7, f4, o3, p7, a5, s5, j6, i5, k6, v6;
var init_comment = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/comment.js"() {
    init_node();
    require9 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/node":
          return e2(node_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    n3 = Object.create;
    l2 = Object.defineProperty;
    m6 = Object.getOwnPropertyDescriptor;
    x9 = Object.getOwnPropertyNames;
    h7 = Object.getPrototypeOf;
    q4 = Object.prototype.hasOwnProperty;
    y6 = ((t) => typeof require9 < "u" ? require9 : typeof Proxy < "u" ? new Proxy(t, { get: (e2, r9) => (typeof require9 < "u" ? require9 : e2)[r9] }) : t)(function(t) {
      if (typeof require9 < "u") return require9.apply(this, arguments);
      throw Error('Dynamic require of "' + t + '" is not supported');
    });
    N2 = (t, e2) => () => (e2 || t((e2 = { exports: {} }).exports, e2), e2.exports);
    b7 = (t, e2) => {
      for (var r9 in e2) l2(t, r9, { get: e2[r9], enumerable: true });
    };
    f4 = (t, e2, r9, c16) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let u17 of x9(e2)) !q4.call(t, u17) && u17 !== r9 && l2(t, u17, { get: () => e2[u17], enumerable: !(c16 = m6(e2, u17)) || c16.enumerable });
      return t;
    };
    o3 = (t, e2, r9) => (f4(t, e2, "default"), r9 && f4(r9, e2, "default"));
    p7 = (t, e2, r9) => (r9 = t != null ? n3(h7(t)) : {}, f4(e2 || !t || !t.__esModule ? l2(r9, "default", { value: t, enumerable: true }) : r9, t));
    a5 = N2((z11, _22) => {
      "use strict";
      var g16 = y6("postcss/lib/node"), d20 = class extends g16 {
        constructor(e2) {
          super(e2), this.type = "comment";
        }
      };
      _22.exports = d20;
      d20.default = d20;
    });
    s5 = {};
    b7(s5, { default: () => v6 });
    j6 = p7(a5());
    o3(s5, p7(a5()));
    ({ default: i5, ...k6 } = j6);
    v6 = i5 !== void 0 ? i5 : k6;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/declaration.js
var declaration_exports = {};
__export(declaration_exports, {
  default: () => W4
});
var require10, f5, n4, v7, h8, m7, x10, g6, y7, b8, u4, i6, _6, d6, o4, N3, c5, S7, W4;
var init_declaration = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/declaration.js"() {
    init_node();
    require10 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/node":
          return e2(node_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    f5 = Object.create;
    n4 = Object.defineProperty;
    v7 = Object.getOwnPropertyDescriptor;
    h8 = Object.getOwnPropertyNames;
    m7 = Object.getPrototypeOf;
    x10 = Object.prototype.hasOwnProperty;
    g6 = ((t) => typeof require10 < "u" ? require10 : typeof Proxy < "u" ? new Proxy(t, { get: (e2, r9) => (typeof require10 < "u" ? require10 : e2)[r9] }) : t)(function(t) {
      if (typeof require10 < "u") return require10.apply(this, arguments);
      throw Error('Dynamic require of "' + t + '" is not supported');
    });
    y7 = (t, e2) => () => (e2 || t((e2 = { exports: {} }).exports, e2), e2.exports);
    b8 = (t, e2) => {
      for (var r9 in e2) n4(t, r9, { get: e2[r9], enumerable: true });
    };
    u4 = (t, e2, r9, l10) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let p20 of h8(e2)) !x10.call(t, p20) && p20 !== r9 && n4(t, p20, { get: () => e2[p20], enumerable: !(l10 = v7(e2, p20)) || l10.enumerable });
      return t;
    };
    i6 = (t, e2, r9) => (u4(t, e2, "default"), r9 && u4(r9, e2, "default"));
    _6 = (t, e2, r9) => (r9 = t != null ? f5(m7(t)) : {}, u4(e2 || !t || !t.__esModule ? n4(r9, "default", { value: t, enumerable: true }) : r9, t));
    d6 = y7((j16, a20) => {
      "use strict";
      var q16 = g6("postcss/lib/node"), s12 = class extends q16 {
        constructor(e2) {
          e2 && typeof e2.value < "u" && typeof e2.value != "string" && (e2 = { ...e2, value: String(e2.value) }), super(e2), this.type = "decl";
        }
        get variable() {
          return this.prop.startsWith("--") || this.prop[0] === "$";
        }
      };
      a20.exports = s12;
      s12.default = s12;
    });
    o4 = {};
    b8(o4, { default: () => W4 });
    N3 = _6(d6());
    i6(o4, _6(d6()));
    ({ default: c5, ...S7 } = N3);
    W4 = c5 !== void 0 ? c5 : S7;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/container.js
var container_exports = {};
__export(container_exports, {
  default: () => W5
});
var require11, j7, p8, z5, _7, q5, I6, y8, S8, T4, h9, l3, w4, m8, u5, N4, C7, U3, W5;
var init_container = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/container.js"() {
    init_comment();
    init_declaration();
    init_node();
    init_symbols();
    require11 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/comment":
          return e2(comment_exports);
        case "postcss/lib/declaration":
          return e2(declaration_exports);
        case "postcss/lib/node":
          return e2(node_exports);
        case "postcss/lib/symbols":
          return e2(symbols_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    j7 = Object.create;
    p8 = Object.defineProperty;
    z5 = Object.getOwnPropertyDescriptor;
    _7 = Object.getOwnPropertyNames;
    q5 = Object.getPrototypeOf;
    I6 = Object.prototype.hasOwnProperty;
    y8 = ((i14) => typeof require11 < "u" ? require11 : typeof Proxy < "u" ? new Proxy(i14, { get: (e2, t) => (typeof require11 < "u" ? require11 : e2)[t] }) : i14)(function(i14) {
      if (typeof require11 < "u") return require11.apply(this, arguments);
      throw Error('Dynamic require of "' + i14 + '" is not supported');
    });
    S8 = (i14, e2) => () => (e2 || i14((e2 = { exports: {} }).exports, e2), e2.exports);
    T4 = (i14, e2) => {
      for (var t in e2) p8(i14, t, { get: e2[t], enumerable: true });
    };
    h9 = (i14, e2, t, s12) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let r9 of _7(e2)) !I6.call(i14, r9) && r9 !== t && p8(i14, r9, { get: () => e2[r9], enumerable: !(s12 = z5(e2, r9)) || s12.enumerable });
      return i14;
    };
    l3 = (i14, e2, t) => (h9(i14, e2, "default"), t && h9(t, e2, "default"));
    w4 = (i14, e2, t) => (t = i14 != null ? j7(q5(i14)) : {}, h9(e2 || !i14 || !i14.__esModule ? p8(t, "default", { value: i14, enumerable: true }) : t, i14));
    m8 = S8((F5, A15) => {
      "use strict";
      var O11 = y8("postcss/lib/comment"), g16 = y8("postcss/lib/declaration"), V2 = y8("postcss/lib/node"), { isClean: v15, my: k13 } = y8("postcss/lib/symbols"), x22, R8, P11, d20;
      function D8(i14) {
        return i14.map((e2) => (e2.nodes && (e2.nodes = D8(e2.nodes)), delete e2.source, e2));
      }
      function E11(i14) {
        if (i14[v15] = false, i14.proxyOf.nodes) for (let e2 of i14.proxyOf.nodes) E11(e2);
      }
      var f15 = class i14 extends V2 {
        append(...e2) {
          for (let t of e2) {
            let s12 = this.normalize(t, this.last);
            for (let r9 of s12) this.proxyOf.nodes.push(r9);
          }
          return this.markDirty(), this;
        }
        cleanRaws(e2) {
          if (super.cleanRaws(e2), this.nodes) for (let t of this.nodes) t.cleanRaws(e2);
        }
        each(e2) {
          if (!this.proxyOf.nodes) return;
          let t = this.getIterator(), s12, r9;
          for (; this.indexes[t] < this.proxyOf.nodes.length && (s12 = this.indexes[t], r9 = e2(this.proxyOf.nodes[s12], s12), r9 !== false); ) this.indexes[t] += 1;
          return delete this.indexes[t], r9;
        }
        every(e2) {
          return this.nodes.every(e2);
        }
        getIterator() {
          this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
          let e2 = this.lastEach;
          return this.indexes[e2] = 0, e2;
        }
        getProxyProcessor() {
          return { get(e2, t) {
            return t === "proxyOf" ? e2 : e2[t] ? t === "each" || typeof t == "string" && t.startsWith("walk") ? (...s12) => e2[t](...s12.map((r9) => typeof r9 == "function" ? (n14, o10) => r9(n14.toProxy(), o10) : r9)) : t === "every" || t === "some" ? (s12) => e2[t]((r9, ...n14) => s12(r9.toProxy(), ...n14)) : t === "root" ? () => e2.root().toProxy() : t === "nodes" ? e2.nodes.map((s12) => s12.toProxy()) : t === "first" || t === "last" ? e2[t].toProxy() : e2[t] : e2[t];
          }, set(e2, t, s12) {
            return e2[t] === s12 || (e2[t] = s12, (t === "name" || t === "params" || t === "selector") && e2.markDirty()), true;
          } };
        }
        index(e2) {
          return typeof e2 == "number" ? e2 : (e2.proxyOf && (e2 = e2.proxyOf), this.proxyOf.nodes.indexOf(e2));
        }
        insertAfter(e2, t) {
          let s12 = this.index(e2), r9 = this.normalize(t, this.proxyOf.nodes[s12]).reverse();
          s12 = this.index(e2);
          for (let o10 of r9) this.proxyOf.nodes.splice(s12 + 1, 0, o10);
          let n14;
          for (let o10 in this.indexes) n14 = this.indexes[o10], s12 < n14 && (this.indexes[o10] = n14 + r9.length);
          return this.markDirty(), this;
        }
        insertBefore(e2, t) {
          let s12 = this.index(e2), r9 = s12 === 0 ? "prepend" : false, n14 = this.normalize(t, this.proxyOf.nodes[s12], r9).reverse();
          s12 = this.index(e2);
          for (let a20 of n14) this.proxyOf.nodes.splice(s12, 0, a20);
          let o10;
          for (let a20 in this.indexes) o10 = this.indexes[a20], s12 <= o10 && (this.indexes[a20] = o10 + n14.length);
          return this.markDirty(), this;
        }
        normalize(e2, t) {
          if (typeof e2 == "string") e2 = D8(R8(e2).nodes);
          else if (typeof e2 > "u") e2 = [];
          else if (Array.isArray(e2)) {
            e2 = e2.slice(0);
            for (let r9 of e2) r9.parent && r9.parent.removeChild(r9, "ignore");
          } else if (e2.type === "root" && this.type !== "document") {
            e2 = e2.nodes.slice(0);
            for (let r9 of e2) r9.parent && r9.parent.removeChild(r9, "ignore");
          } else if (e2.type) e2 = [e2];
          else if (e2.prop) {
            if (typeof e2.value > "u") throw new Error("Value field is missed in node creation");
            typeof e2.value != "string" && (e2.value = String(e2.value)), e2 = [new g16(e2)];
          } else if (e2.selector || e2.selectors) e2 = [new d20(e2)];
          else if (e2.name) e2 = [new x22(e2)];
          else if (e2.text) e2 = [new O11(e2)];
          else throw new Error("Unknown node type in node creation");
          return e2.map((r9) => (r9[k13] || i14.rebuild(r9), r9 = r9.proxyOf, r9.parent && r9.parent.removeChild(r9), r9[v15] && E11(r9), r9.raws || (r9.raws = {}), typeof r9.raws.before > "u" && t && typeof t.raws.before < "u" && (r9.raws.before = t.raws.before.replace(/\S/g, "")), r9.parent = this.proxyOf, r9));
        }
        prepend(...e2) {
          e2 = e2.reverse();
          for (let t of e2) {
            let s12 = this.normalize(t, this.first, "prepend").reverse();
            for (let r9 of s12) this.proxyOf.nodes.unshift(r9);
            for (let r9 in this.indexes) this.indexes[r9] = this.indexes[r9] + s12.length;
          }
          return this.markDirty(), this;
        }
        push(e2) {
          return e2.parent = this, this.proxyOf.nodes.push(e2), this;
        }
        removeAll() {
          for (let e2 of this.proxyOf.nodes) e2.parent = void 0;
          return this.proxyOf.nodes = [], this.markDirty(), this;
        }
        removeChild(e2) {
          e2 = this.index(e2), this.proxyOf.nodes[e2].parent = void 0, this.proxyOf.nodes.splice(e2, 1);
          let t;
          for (let s12 in this.indexes) t = this.indexes[s12], t >= e2 && (this.indexes[s12] = t - 1);
          return this.markDirty(), this;
        }
        replaceValues(e2, t, s12) {
          return s12 || (s12 = t, t = {}), this.walkDecls((r9) => {
            t.props && !t.props.includes(r9.prop) || t.fast && !r9.value.includes(t.fast) || (r9.value = r9.value.replace(e2, s12));
          }), this.markDirty(), this;
        }
        some(e2) {
          return this.nodes.some(e2);
        }
        walk(e2) {
          return this.each((t, s12) => {
            let r9;
            try {
              r9 = e2(t, s12);
            } catch (n14) {
              throw t.addToError(n14);
            }
            return r9 !== false && t.walk && (r9 = t.walk(e2)), r9;
          });
        }
        walkAtRules(e2, t) {
          return t ? e2 instanceof RegExp ? this.walk((s12, r9) => {
            if (s12.type === "atrule" && e2.test(s12.name)) return t(s12, r9);
          }) : this.walk((s12, r9) => {
            if (s12.type === "atrule" && s12.name === e2) return t(s12, r9);
          }) : (t = e2, this.walk((s12, r9) => {
            if (s12.type === "atrule") return t(s12, r9);
          }));
        }
        walkComments(e2) {
          return this.walk((t, s12) => {
            if (t.type === "comment") return e2(t, s12);
          });
        }
        walkDecls(e2, t) {
          return t ? e2 instanceof RegExp ? this.walk((s12, r9) => {
            if (s12.type === "decl" && e2.test(s12.prop)) return t(s12, r9);
          }) : this.walk((s12, r9) => {
            if (s12.type === "decl" && s12.prop === e2) return t(s12, r9);
          }) : (t = e2, this.walk((s12, r9) => {
            if (s12.type === "decl") return t(s12, r9);
          }));
        }
        walkRules(e2, t) {
          return t ? e2 instanceof RegExp ? this.walk((s12, r9) => {
            if (s12.type === "rule" && e2.test(s12.selector)) return t(s12, r9);
          }) : this.walk((s12, r9) => {
            if (s12.type === "rule" && s12.selector === e2) return t(s12, r9);
          }) : (t = e2, this.walk((s12, r9) => {
            if (s12.type === "rule") return t(s12, r9);
          }));
        }
        get first() {
          if (this.proxyOf.nodes) return this.proxyOf.nodes[0];
        }
        get last() {
          if (this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
        }
      };
      f15.registerParse = (i14) => {
        R8 = i14;
      };
      f15.registerRule = (i14) => {
        d20 = i14;
      };
      f15.registerAtRule = (i14) => {
        x22 = i14;
      };
      f15.registerRoot = (i14) => {
        P11 = i14;
      };
      A15.exports = f15;
      f15.default = f15;
      f15.rebuild = (i14) => {
        i14.type === "atrule" ? Object.setPrototypeOf(i14, x22.prototype) : i14.type === "rule" ? Object.setPrototypeOf(i14, d20.prototype) : i14.type === "decl" ? Object.setPrototypeOf(i14, g16.prototype) : i14.type === "comment" ? Object.setPrototypeOf(i14, O11.prototype) : i14.type === "root" && Object.setPrototypeOf(i14, P11.prototype), i14[k13] = true, i14.nodes && i14.nodes.forEach((e2) => {
          f15.rebuild(e2);
        });
      };
    });
    u5 = {};
    T4(u5, { default: () => W5 });
    N4 = w4(m8());
    l3(u5, w4(m8()));
    ({ default: C7, ...U3 } = N4);
    W5 = C7 !== void 0 ? C7 : U3;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/at-rule.js
var at_rule_exports = {};
__export(at_rule_exports, {
  default: () => k7
});
var require12, c6, u6, h10, m9, y9, O3, g7, q6, C8, d7, p9, a6, i7, s6, b9, _8, j8, k7;
var init_at_rule = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/at-rule.js"() {
    init_container();
    require12 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/container":
          return e2(container_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    c6 = Object.create;
    u6 = Object.defineProperty;
    h10 = Object.getOwnPropertyDescriptor;
    m9 = Object.getOwnPropertyNames;
    y9 = Object.getPrototypeOf;
    O3 = Object.prototype.hasOwnProperty;
    g7 = ((r9) => typeof require12 < "u" ? require12 : typeof Proxy < "u" ? new Proxy(r9, { get: (e2, t) => (typeof require12 < "u" ? require12 : e2)[t] }) : r9)(function(r9) {
      if (typeof require12 < "u") return require12.apply(this, arguments);
      throw Error('Dynamic require of "' + r9 + '" is not supported');
    });
    q6 = (r9, e2) => () => (e2 || r9((e2 = { exports: {} }).exports, e2), e2.exports);
    C8 = (r9, e2) => {
      for (var t in e2) u6(r9, t, { get: e2[t], enumerable: true });
    };
    d7 = (r9, e2, t, f15) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let o10 of m9(e2)) !O3.call(r9, o10) && o10 !== t && u6(r9, o10, { get: () => e2[o10], enumerable: !(f15 = h10(e2, o10)) || f15.enumerable });
      return r9;
    };
    p9 = (r9, e2, t) => (d7(r9, e2, "default"), t && d7(t, e2, "default"));
    a6 = (r9, e2, t) => (t = r9 != null ? c6(y9(r9)) : {}, d7(e2 || !r9 || !r9.__esModule ? u6(t, "default", { value: r9, enumerable: true }) : t, r9));
    i7 = q6((w13, x22) => {
      "use strict";
      var l10 = g7("postcss/lib/container"), n14 = class extends l10 {
        constructor(e2) {
          super(e2), this.type = "atrule";
        }
        append(...e2) {
          return this.proxyOf.nodes || (this.nodes = []), super.append(...e2);
        }
        prepend(...e2) {
          return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e2);
        }
      };
      x22.exports = n14;
      n14.default = n14;
      l10.registerAtRule(n14);
    });
    s6 = {};
    C8(s6, { default: () => k7 });
    b9 = a6(i7());
    p9(s6, a6(i7()));
    ({ default: _8, ...j8 } = b9);
    k7 = _8 !== void 0 ? _8 : j8;
  }
});

// https://esm.sh/v135/nanoid@3.3.7/denonext/non-secure.js
var non_secure_exports = {};
__export(non_secure_exports, {
  customAlphabet: () => h11,
  nanoid: () => a7
});
var i8, h11, a7;
var init_non_secure = __esm({
  "https://esm.sh/v135/nanoid@3.3.7/denonext/non-secure.js"() {
    i8 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    h11 = (t, e2 = 21) => (l10 = e2) => {
      let r9 = "", n14 = l10;
      for (; n14--; ) r9 += t[Math.random() * t.length | 0];
      return r9;
    };
    a7 = (t = 21) => {
      let e2 = "", l10 = t;
      for (; l10--; ) e2 += i8[Math.random() * 64 | 0];
      return e2;
    };
  }
});

// https://esm.sh/v135/source-map-js@1.2.1/denonext/source-map-js.mjs
var source_map_js_exports = {};
__export(source_map_js_exports, {
  SourceMapConsumer: () => _r,
  SourceMapGenerator: () => vr,
  SourceNode: () => pr,
  default: () => Sr2
});
var Fe, X3, Ue, ze2, Be2, Qe, w5, We2, J3, N5, ce, he2, H4, T5, te2, Ae2, oe2, Ee, Re, xe, De, le3, b10, Pe, vr, _r, pr, qe2, mr, Sr2;
var init_source_map_js = __esm({
  "https://esm.sh/v135/source-map-js@1.2.1/denonext/source-map-js.mjs"() {
    Fe = Object.create;
    X3 = Object.defineProperty;
    Ue = Object.getOwnPropertyDescriptor;
    ze2 = Object.getOwnPropertyNames;
    Be2 = Object.getPrototypeOf;
    Qe = Object.prototype.hasOwnProperty;
    w5 = (t, e2) => () => (e2 || t((e2 = { exports: {} }).exports, e2), e2.exports);
    We2 = (t, e2) => {
      for (var n14 in e2) X3(t, n14, { get: e2[n14], enumerable: true });
    };
    J3 = (t, e2, n14, r9) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let o10 of ze2(e2)) !Qe.call(t, o10) && o10 !== n14 && X3(t, o10, { get: () => e2[o10], enumerable: !(r9 = Ue(e2, o10)) || r9.enumerable });
      return t;
    };
    N5 = (t, e2, n14) => (J3(t, e2, "default"), n14 && J3(n14, e2, "default"));
    ce = (t, e2, n14) => (n14 = t != null ? Fe(Be2(t)) : {}, J3(e2 || !t || !t.__esModule ? X3(n14, "default", { value: t, enumerable: true }) : n14, t));
    he2 = w5((Z3) => {
      var fe2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      Z3.encode = function(t) {
        if (0 <= t && t < fe2.length) return fe2[t];
        throw new TypeError("Must be between 0 and 63: " + t);
      };
      Z3.decode = function(t) {
        var e2 = 65, n14 = 90, r9 = 97, o10 = 122, i14 = 48, s12 = 57, u17 = 43, l10 = 47, a20 = 26, c16 = 52;
        return e2 <= t && t <= n14 ? t - e2 : r9 <= t && t <= o10 ? t - r9 + a20 : i14 <= t && t <= s12 ? t - i14 + c16 : t == u17 ? 62 : t == l10 ? 63 : -1;
      };
    });
    H4 = w5((Y5) => {
      var de3 = he2(), K4 = 5, ge3 = 1 << K4, ve = ge3 - 1, _e = ge3;
      function $e(t) {
        return t < 0 ? (-t << 1) + 1 : (t << 1) + 0;
      }
      function Ve2(t) {
        var e2 = (t & 1) === 1, n14 = t >> 1;
        return e2 ? -n14 : n14;
      }
      Y5.encode = function(e2) {
        var n14 = "", r9, o10 = $e(e2);
        do
          r9 = o10 & ve, o10 >>>= K4, o10 > 0 && (r9 |= _e), n14 += de3.encode(r9);
        while (o10 > 0);
        return n14;
      };
      Y5.decode = function(e2, n14, r9) {
        var o10 = e2.length, i14 = 0, s12 = 0, u17, l10;
        do {
          if (n14 >= o10) throw new Error("Expected more digits in base 64 VLQ value.");
          if (l10 = de3.decode(e2.charCodeAt(n14++)), l10 === -1) throw new Error("Invalid base64 digit: " + e2.charAt(n14 - 1));
          u17 = !!(l10 & _e), l10 &= ve, i14 = i14 + (l10 << s12), s12 += K4;
        } while (u17);
        r9.value = Ve2(i14), r9.rest = n14;
      };
    });
    T5 = w5((S16) => {
      function ke(t, e2, n14) {
        if (e2 in t) return t[e2];
        if (arguments.length === 3) return n14;
        throw new Error('"' + e2 + '" is a required argument.');
      }
      S16.getArg = ke;
      var pe2 = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, Je = /^data:.+\,.+$/;
      function P11(t) {
        var e2 = t.match(pe2);
        return e2 ? { scheme: e2[1], auth: e2[2], host: e2[3], port: e2[4], path: e2[5] } : null;
      }
      S16.urlParse = P11;
      function x22(t) {
        var e2 = "";
        return t.scheme && (e2 += t.scheme + ":"), e2 += "//", t.auth && (e2 += t.auth + "@"), t.host && (e2 += t.host), t.port && (e2 += ":" + t.port), t.path && (e2 += t.path), e2;
      }
      S16.urlGenerate = x22;
      var Xe = 32;
      function Ze(t) {
        var e2 = [];
        return function(n14) {
          for (var r9 = 0; r9 < e2.length; r9++) if (e2[r9].input === n14) {
            var o10 = e2[0];
            return e2[0] = e2[r9], e2[r9] = o10, e2[0].result;
          }
          var i14 = t(n14);
          return e2.unshift({ input: n14, result: i14 }), e2.length > Xe && e2.pop(), i14;
        };
      }
      var ee3 = Ze(function(e2) {
        var n14 = e2, r9 = P11(e2);
        if (r9) {
          if (!r9.path) return e2;
          n14 = r9.path;
        }
        for (var o10 = S16.isAbsolute(n14), i14 = [], s12 = 0, u17 = 0; ; ) if (s12 = u17, u17 = n14.indexOf("/", s12), u17 === -1) {
          i14.push(n14.slice(s12));
          break;
        } else for (i14.push(n14.slice(s12, u17)); u17 < n14.length && n14[u17] === "/"; ) u17++;
        for (var l10, a20 = 0, u17 = i14.length - 1; u17 >= 0; u17--) l10 = i14[u17], l10 === "." ? i14.splice(u17, 1) : l10 === ".." ? a20++ : a20 > 0 && (l10 === "" ? (i14.splice(u17 + 1, a20), a20 = 0) : (i14.splice(u17, 2), a20--));
        return n14 = i14.join("/"), n14 === "" && (n14 = o10 ? "/" : "."), r9 ? (r9.path = n14, x22(r9)) : n14;
      });
      S16.normalize = ee3;
      function me2(t, e2) {
        t === "" && (t = "."), e2 === "" && (e2 = ".");
        var n14 = P11(e2), r9 = P11(t);
        if (r9 && (t = r9.path || "/"), n14 && !n14.scheme) return r9 && (n14.scheme = r9.scheme), x22(n14);
        if (n14 || e2.match(Je)) return e2;
        if (r9 && !r9.host && !r9.path) return r9.host = e2, x22(r9);
        var o10 = e2.charAt(0) === "/" ? e2 : ee3(t.replace(/\/+$/, "") + "/" + e2);
        return r9 ? (r9.path = o10, x22(r9)) : o10;
      }
      S16.join = me2;
      S16.isAbsolute = function(t) {
        return t.charAt(0) === "/" || pe2.test(t);
      };
      function Ke(t, e2) {
        t === "" && (t = "."), t = t.replace(/\/$/, "");
        for (var n14 = 0; e2.indexOf(t + "/") !== 0; ) {
          var r9 = t.lastIndexOf("/");
          if (r9 < 0 || (t = t.slice(0, r9), t.match(/^([^\/]+:\/)?\/*$/))) return e2;
          ++n14;
        }
        return Array(n14 + 1).join("../") + e2.substr(t.length + 1);
      }
      S16.relative = Ke;
      var Se2 = function() {
        var t = /* @__PURE__ */ Object.create(null);
        return !("__proto__" in t);
      }();
      function Ce(t) {
        return t;
      }
      function Ye2(t) {
        return ye2(t) ? "$" + t : t;
      }
      S16.toSetString = Se2 ? Ce : Ye2;
      function He(t) {
        return ye2(t) ? t.slice(1) : t;
      }
      S16.fromSetString = Se2 ? Ce : He;
      function ye2(t) {
        if (!t) return false;
        var e2 = t.length;
        if (e2 < 9 || t.charCodeAt(e2 - 1) !== 95 || t.charCodeAt(e2 - 2) !== 95 || t.charCodeAt(e2 - 3) !== 111 || t.charCodeAt(e2 - 4) !== 116 || t.charCodeAt(e2 - 5) !== 111 || t.charCodeAt(e2 - 6) !== 114 || t.charCodeAt(e2 - 7) !== 112 || t.charCodeAt(e2 - 8) !== 95 || t.charCodeAt(e2 - 9) !== 95) return false;
        for (var n14 = e2 - 10; n14 >= 0; n14--) if (t.charCodeAt(n14) !== 36) return false;
        return true;
      }
      function er(t, e2, n14) {
        var r9 = O11(t.source, e2.source);
        return r9 !== 0 || (r9 = t.originalLine - e2.originalLine, r9 !== 0) || (r9 = t.originalColumn - e2.originalColumn, r9 !== 0 || n14) || (r9 = t.generatedColumn - e2.generatedColumn, r9 !== 0) || (r9 = t.generatedLine - e2.generatedLine, r9 !== 0) ? r9 : O11(t.name, e2.name);
      }
      S16.compareByOriginalPositions = er;
      function rr(t, e2, n14) {
        var r9;
        return r9 = t.originalLine - e2.originalLine, r9 !== 0 || (r9 = t.originalColumn - e2.originalColumn, r9 !== 0 || n14) || (r9 = t.generatedColumn - e2.generatedColumn, r9 !== 0) || (r9 = t.generatedLine - e2.generatedLine, r9 !== 0) ? r9 : O11(t.name, e2.name);
      }
      S16.compareByOriginalPositionsNoSource = rr;
      function nr(t, e2, n14) {
        var r9 = t.generatedLine - e2.generatedLine;
        return r9 !== 0 || (r9 = t.generatedColumn - e2.generatedColumn, r9 !== 0 || n14) || (r9 = O11(t.source, e2.source), r9 !== 0) || (r9 = t.originalLine - e2.originalLine, r9 !== 0) || (r9 = t.originalColumn - e2.originalColumn, r9 !== 0) ? r9 : O11(t.name, e2.name);
      }
      S16.compareByGeneratedPositionsDeflated = nr;
      function tr(t, e2, n14) {
        var r9 = t.generatedColumn - e2.generatedColumn;
        return r9 !== 0 || n14 || (r9 = O11(t.source, e2.source), r9 !== 0) || (r9 = t.originalLine - e2.originalLine, r9 !== 0) || (r9 = t.originalColumn - e2.originalColumn, r9 !== 0) ? r9 : O11(t.name, e2.name);
      }
      S16.compareByGeneratedPositionsDeflatedNoLine = tr;
      function O11(t, e2) {
        return t === e2 ? 0 : t === null ? 1 : e2 === null ? -1 : t > e2 ? 1 : -1;
      }
      function or(t, e2) {
        var n14 = t.generatedLine - e2.generatedLine;
        return n14 !== 0 || (n14 = t.generatedColumn - e2.generatedColumn, n14 !== 0) || (n14 = O11(t.source, e2.source), n14 !== 0) || (n14 = t.originalLine - e2.originalLine, n14 !== 0) || (n14 = t.originalColumn - e2.originalColumn, n14 !== 0) ? n14 : O11(t.name, e2.name);
      }
      S16.compareByGeneratedPositionsInflated = or;
      function ir(t) {
        return JSON.parse(t.replace(/^\)]}'[^\n]*\n/, ""));
      }
      S16.parseSourceMapInput = ir;
      function sr(t, e2, n14) {
        if (e2 = e2 || "", t && (t[t.length - 1] !== "/" && e2[0] !== "/" && (t += "/"), e2 = t + e2), n14) {
          var r9 = P11(n14);
          if (!r9) throw new Error("sourceMapURL could not be parsed");
          if (r9.path) {
            var o10 = r9.path.lastIndexOf("/");
            o10 >= 0 && (r9.path = r9.path.substring(0, o10 + 1));
          }
          e2 = me2(x22(r9), e2);
        }
        return ee3(e2);
      }
      S16.computeSourceURL = sr;
    });
    te2 = w5((Le) => {
      var re3 = T5(), ne3 = Object.prototype.hasOwnProperty, R8 = typeof Map < "u";
      function E11() {
        this._array = [], this._set = R8 ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
      }
      E11.fromArray = function(e2, n14) {
        for (var r9 = new E11(), o10 = 0, i14 = e2.length; o10 < i14; o10++) r9.add(e2[o10], n14);
        return r9;
      };
      E11.prototype.size = function() {
        return R8 ? this._set.size : Object.getOwnPropertyNames(this._set).length;
      };
      E11.prototype.add = function(e2, n14) {
        var r9 = R8 ? e2 : re3.toSetString(e2), o10 = R8 ? this.has(e2) : ne3.call(this._set, r9), i14 = this._array.length;
        (!o10 || n14) && this._array.push(e2), o10 || (R8 ? this._set.set(e2, i14) : this._set[r9] = i14);
      };
      E11.prototype.has = function(e2) {
        if (R8) return this._set.has(e2);
        var n14 = re3.toSetString(e2);
        return ne3.call(this._set, n14);
      };
      E11.prototype.indexOf = function(e2) {
        if (R8) {
          var n14 = this._set.get(e2);
          if (n14 >= 0) return n14;
        } else {
          var r9 = re3.toSetString(e2);
          if (ne3.call(this._set, r9)) return this._set[r9];
        }
        throw new Error('"' + e2 + '" is not in the set.');
      };
      E11.prototype.at = function(e2) {
        if (e2 >= 0 && e2 < this._array.length) return this._array[e2];
        throw new Error("No element indexed by " + e2);
      };
      E11.prototype.toArray = function() {
        return this._array.slice();
      };
      Le.ArraySet = E11;
    });
    Ae2 = w5((we2) => {
      var Me = T5();
      function ur(t, e2) {
        var n14 = t.generatedLine, r9 = e2.generatedLine, o10 = t.generatedColumn, i14 = e2.generatedColumn;
        return r9 > n14 || r9 == n14 && i14 >= o10 || Me.compareByGeneratedPositionsInflated(t, e2) <= 0;
      }
      function B10() {
        this._array = [], this._sorted = true, this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      B10.prototype.unsortedForEach = function(e2, n14) {
        this._array.forEach(e2, n14);
      };
      B10.prototype.add = function(e2) {
        ur(this._last, e2) ? (this._last = e2, this._array.push(e2)) : (this._sorted = false, this._array.push(e2));
      };
      B10.prototype.toArray = function() {
        return this._sorted || (this._array.sort(Me.compareByGeneratedPositionsInflated), this._sorted = true), this._array;
      };
      we2.MappingList = B10;
    });
    oe2 = w5((Oe) => {
      var j16 = H4(), p20 = T5(), Q3 = te2().ArraySet, lr = Ae2().MappingList;
      function M6(t) {
        t || (t = {}), this._file = p20.getArg(t, "file", null), this._sourceRoot = p20.getArg(t, "sourceRoot", null), this._skipValidation = p20.getArg(t, "skipValidation", false), this._ignoreInvalidMapping = p20.getArg(t, "ignoreInvalidMapping", false), this._sources = new Q3(), this._names = new Q3(), this._mappings = new lr(), this._sourcesContents = null;
      }
      M6.prototype._version = 3;
      M6.fromSourceMap = function(e2, n14) {
        var r9 = e2.sourceRoot, o10 = new M6(Object.assign(n14 || {}, { file: e2.file, sourceRoot: r9 }));
        return e2.eachMapping(function(i14) {
          var s12 = { generated: { line: i14.generatedLine, column: i14.generatedColumn } };
          i14.source != null && (s12.source = i14.source, r9 != null && (s12.source = p20.relative(r9, s12.source)), s12.original = { line: i14.originalLine, column: i14.originalColumn }, i14.name != null && (s12.name = i14.name)), o10.addMapping(s12);
        }), e2.sources.forEach(function(i14) {
          var s12 = i14;
          r9 !== null && (s12 = p20.relative(r9, i14)), o10._sources.has(s12) || o10._sources.add(s12);
          var u17 = e2.sourceContentFor(i14);
          u17 != null && o10.setSourceContent(i14, u17);
        }), o10;
      };
      M6.prototype.addMapping = function(e2) {
        var n14 = p20.getArg(e2, "generated"), r9 = p20.getArg(e2, "original", null), o10 = p20.getArg(e2, "source", null), i14 = p20.getArg(e2, "name", null);
        !this._skipValidation && this._validateMapping(n14, r9, o10, i14) === false || (o10 != null && (o10 = String(o10), this._sources.has(o10) || this._sources.add(o10)), i14 != null && (i14 = String(i14), this._names.has(i14) || this._names.add(i14)), this._mappings.add({ generatedLine: n14.line, generatedColumn: n14.column, originalLine: r9 != null && r9.line, originalColumn: r9 != null && r9.column, source: o10, name: i14 }));
      };
      M6.prototype.setSourceContent = function(e2, n14) {
        var r9 = e2;
        this._sourceRoot != null && (r9 = p20.relative(this._sourceRoot, r9)), n14 != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[p20.toSetString(r9)] = n14) : this._sourcesContents && (delete this._sourcesContents[p20.toSetString(r9)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
      };
      M6.prototype.applySourceMap = function(e2, n14, r9) {
        var o10 = n14;
        if (n14 == null) {
          if (e2.file == null) throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
          o10 = e2.file;
        }
        var i14 = this._sourceRoot;
        i14 != null && (o10 = p20.relative(i14, o10));
        var s12 = new Q3(), u17 = new Q3();
        this._mappings.unsortedForEach(function(l10) {
          if (l10.source === o10 && l10.originalLine != null) {
            var a20 = e2.originalPositionFor({ line: l10.originalLine, column: l10.originalColumn });
            a20.source != null && (l10.source = a20.source, r9 != null && (l10.source = p20.join(r9, l10.source)), i14 != null && (l10.source = p20.relative(i14, l10.source)), l10.originalLine = a20.line, l10.originalColumn = a20.column, a20.name != null && (l10.name = a20.name));
          }
          var c16 = l10.source;
          c16 != null && !s12.has(c16) && s12.add(c16);
          var d20 = l10.name;
          d20 != null && !u17.has(d20) && u17.add(d20);
        }, this), this._sources = s12, this._names = u17, e2.sources.forEach(function(l10) {
          var a20 = e2.sourceContentFor(l10);
          a20 != null && (r9 != null && (l10 = p20.join(r9, l10)), i14 != null && (l10 = p20.relative(i14, l10)), this.setSourceContent(l10, a20));
        }, this);
      };
      M6.prototype._validateMapping = function(e2, n14, r9, o10) {
        if (n14 && typeof n14.line != "number" && typeof n14.column != "number") {
          var i14 = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
          if (this._ignoreInvalidMapping) return typeof console < "u" && console.warn && console.warn(i14), false;
          throw new Error(i14);
        }
        if (!(e2 && "line" in e2 && "column" in e2 && e2.line > 0 && e2.column >= 0 && !n14 && !r9 && !o10)) {
          if (e2 && "line" in e2 && "column" in e2 && n14 && "line" in n14 && "column" in n14 && e2.line > 0 && e2.column >= 0 && n14.line > 0 && n14.column >= 0 && r9) return;
          var i14 = "Invalid mapping: " + JSON.stringify({ generated: e2, source: r9, original: n14, name: o10 });
          if (this._ignoreInvalidMapping) return typeof console < "u" && console.warn && console.warn(i14), false;
          throw new Error(i14);
        }
      };
      M6.prototype._serializeMappings = function() {
        for (var e2 = 0, n14 = 1, r9 = 0, o10 = 0, i14 = 0, s12 = 0, u17 = "", l10, a20, c16, d20, h20 = this._mappings.toArray(), g16 = 0, _22 = h20.length; g16 < _22; g16++) {
          if (a20 = h20[g16], l10 = "", a20.generatedLine !== n14) for (e2 = 0; a20.generatedLine !== n14; ) l10 += ";", n14++;
          else if (g16 > 0) {
            if (!p20.compareByGeneratedPositionsInflated(a20, h20[g16 - 1])) continue;
            l10 += ",";
          }
          l10 += j16.encode(a20.generatedColumn - e2), e2 = a20.generatedColumn, a20.source != null && (d20 = this._sources.indexOf(a20.source), l10 += j16.encode(d20 - s12), s12 = d20, l10 += j16.encode(a20.originalLine - 1 - o10), o10 = a20.originalLine - 1, l10 += j16.encode(a20.originalColumn - r9), r9 = a20.originalColumn, a20.name != null && (c16 = this._names.indexOf(a20.name), l10 += j16.encode(c16 - i14), i14 = c16)), u17 += l10;
        }
        return u17;
      };
      M6.prototype._generateSourcesContent = function(e2, n14) {
        return e2.map(function(r9) {
          if (!this._sourcesContents) return null;
          n14 != null && (r9 = p20.relative(n14, r9));
          var o10 = p20.toSetString(r9);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, o10) ? this._sourcesContents[o10] : null;
        }, this);
      };
      M6.prototype.toJSON = function() {
        var e2 = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
        return this._file != null && (e2.file = this._file), this._sourceRoot != null && (e2.sourceRoot = this._sourceRoot), this._sourcesContents && (e2.sourcesContent = this._generateSourcesContent(e2.sources, e2.sourceRoot)), e2;
      };
      M6.prototype.toString = function() {
        return JSON.stringify(this.toJSON());
      };
      Oe.SourceMapGenerator = M6;
    });
    Ee = w5((G4) => {
      G4.GREATEST_LOWER_BOUND = 1;
      G4.LEAST_UPPER_BOUND = 2;
      function ie3(t, e2, n14, r9, o10, i14) {
        var s12 = Math.floor((e2 - t) / 2) + t, u17 = o10(n14, r9[s12], true);
        return u17 === 0 ? s12 : u17 > 0 ? e2 - s12 > 1 ? ie3(s12, e2, n14, r9, o10, i14) : i14 == G4.LEAST_UPPER_BOUND ? e2 < r9.length ? e2 : -1 : s12 : s12 - t > 1 ? ie3(t, s12, n14, r9, o10, i14) : i14 == G4.LEAST_UPPER_BOUND ? s12 : t < 0 ? -1 : t;
      }
      G4.search = function(e2, n14, r9, o10) {
        if (n14.length === 0) return -1;
        var i14 = ie3(-1, n14.length, e2, n14, r9, o10 || G4.GREATEST_LOWER_BOUND);
        if (i14 < 0) return -1;
        for (; i14 - 1 >= 0 && r9(n14[i14], n14[i14 - 1], true) === 0; ) --i14;
        return i14;
      };
    });
    Re = w5((Ne) => {
      function ar(t) {
        function e2(o10, i14, s12) {
          var u17 = o10[i14];
          o10[i14] = o10[s12], o10[s12] = u17;
        }
        function n14(o10, i14) {
          return Math.round(o10 + Math.random() * (i14 - o10));
        }
        function r9(o10, i14, s12, u17) {
          if (s12 < u17) {
            var l10 = n14(s12, u17), a20 = s12 - 1;
            e2(o10, l10, u17);
            for (var c16 = o10[u17], d20 = s12; d20 < u17; d20++) i14(o10[d20], c16, false) <= 0 && (a20 += 1, e2(o10, a20, d20));
            e2(o10, a20 + 1, d20);
            var h20 = a20 + 1;
            r9(o10, i14, s12, h20 - 1), r9(o10, i14, h20 + 1, u17);
          }
        }
        return r9;
      }
      function cr2(t) {
        let e2 = ar.toString();
        return new Function(`return ${e2}`)()(t);
      }
      var be2 = /* @__PURE__ */ new WeakMap();
      Ne.quickSort = function(t, e2, n14 = 0) {
        let r9 = be2.get(e2);
        r9 === void 0 && (r9 = cr2(e2), be2.set(e2, r9)), r9(t, e2, n14, t.length - 1);
      };
    });
    xe = w5((W9) => {
      var f15 = T5(), ue4 = Ee(), D8 = te2().ArraySet, fr = H4(), F5 = Re().quickSort;
      function v15(t, e2) {
        var n14 = t;
        return typeof t == "string" && (n14 = f15.parseSourceMapInput(t)), n14.sections != null ? new A15(n14, e2) : new C19(n14, e2);
      }
      v15.fromSourceMap = function(t, e2) {
        return C19.fromSourceMap(t, e2);
      };
      v15.prototype._version = 3;
      v15.prototype.__generatedMappings = null;
      Object.defineProperty(v15.prototype, "_generatedMappings", { configurable: true, enumerable: true, get: function() {
        return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
      } });
      v15.prototype.__originalMappings = null;
      Object.defineProperty(v15.prototype, "_originalMappings", { configurable: true, enumerable: true, get: function() {
        return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
      } });
      v15.prototype._charIsMappingSeparator = function(e2, n14) {
        var r9 = e2.charAt(n14);
        return r9 === ";" || r9 === ",";
      };
      v15.prototype._parseMappings = function(e2, n14) {
        throw new Error("Subclasses must implement _parseMappings");
      };
      v15.GENERATED_ORDER = 1;
      v15.ORIGINAL_ORDER = 2;
      v15.GREATEST_LOWER_BOUND = 1;
      v15.LEAST_UPPER_BOUND = 2;
      v15.prototype.eachMapping = function(e2, n14, r9) {
        var o10 = n14 || null, i14 = r9 || v15.GENERATED_ORDER, s12;
        switch (i14) {
          case v15.GENERATED_ORDER:
            s12 = this._generatedMappings;
            break;
          case v15.ORIGINAL_ORDER:
            s12 = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
        for (var u17 = this.sourceRoot, l10 = e2.bind(o10), a20 = this._names, c16 = this._sources, d20 = this._sourceMapURL, h20 = 0, g16 = s12.length; h20 < g16; h20++) {
          var _22 = s12[h20], m23 = _22.source === null ? null : c16.at(_22.source);
          m23 !== null && (m23 = f15.computeSourceURL(u17, m23, d20)), l10({ source: m23, generatedLine: _22.generatedLine, generatedColumn: _22.generatedColumn, originalLine: _22.originalLine, originalColumn: _22.originalColumn, name: _22.name === null ? null : a20.at(_22.name) });
        }
      };
      v15.prototype.allGeneratedPositionsFor = function(e2) {
        var n14 = f15.getArg(e2, "line"), r9 = { source: f15.getArg(e2, "source"), originalLine: n14, originalColumn: f15.getArg(e2, "column", 0) };
        if (r9.source = this._findSourceIndex(r9.source), r9.source < 0) return [];
        var o10 = [], i14 = this._findMapping(r9, this._originalMappings, "originalLine", "originalColumn", f15.compareByOriginalPositions, ue4.LEAST_UPPER_BOUND);
        if (i14 >= 0) {
          var s12 = this._originalMappings[i14];
          if (e2.column === void 0) for (var u17 = s12.originalLine; s12 && s12.originalLine === u17; ) o10.push({ line: f15.getArg(s12, "generatedLine", null), column: f15.getArg(s12, "generatedColumn", null), lastColumn: f15.getArg(s12, "lastGeneratedColumn", null) }), s12 = this._originalMappings[++i14];
          else for (var l10 = s12.originalColumn; s12 && s12.originalLine === n14 && s12.originalColumn == l10; ) o10.push({ line: f15.getArg(s12, "generatedLine", null), column: f15.getArg(s12, "generatedColumn", null), lastColumn: f15.getArg(s12, "lastGeneratedColumn", null) }), s12 = this._originalMappings[++i14];
        }
        return o10;
      };
      W9.SourceMapConsumer = v15;
      function C19(t, e2) {
        var n14 = t;
        typeof t == "string" && (n14 = f15.parseSourceMapInput(t));
        var r9 = f15.getArg(n14, "version"), o10 = f15.getArg(n14, "sources"), i14 = f15.getArg(n14, "names", []), s12 = f15.getArg(n14, "sourceRoot", null), u17 = f15.getArg(n14, "sourcesContent", null), l10 = f15.getArg(n14, "mappings"), a20 = f15.getArg(n14, "file", null);
        if (r9 != this._version) throw new Error("Unsupported version: " + r9);
        s12 && (s12 = f15.normalize(s12)), o10 = o10.map(String).map(f15.normalize).map(function(c16) {
          return s12 && f15.isAbsolute(s12) && f15.isAbsolute(c16) ? f15.relative(s12, c16) : c16;
        }), this._names = D8.fromArray(i14.map(String), true), this._sources = D8.fromArray(o10, true), this._absoluteSources = this._sources.toArray().map(function(c16) {
          return f15.computeSourceURL(s12, c16, e2);
        }), this.sourceRoot = s12, this.sourcesContent = u17, this._mappings = l10, this._sourceMapURL = e2, this.file = a20;
      }
      C19.prototype = Object.create(v15.prototype);
      C19.prototype.consumer = v15;
      C19.prototype._findSourceIndex = function(t) {
        var e2 = t;
        if (this.sourceRoot != null && (e2 = f15.relative(this.sourceRoot, e2)), this._sources.has(e2)) return this._sources.indexOf(e2);
        var n14;
        for (n14 = 0; n14 < this._absoluteSources.length; ++n14) if (this._absoluteSources[n14] == t) return n14;
        return -1;
      };
      C19.fromSourceMap = function(e2, n14) {
        var r9 = Object.create(C19.prototype), o10 = r9._names = D8.fromArray(e2._names.toArray(), true), i14 = r9._sources = D8.fromArray(e2._sources.toArray(), true);
        r9.sourceRoot = e2._sourceRoot, r9.sourcesContent = e2._generateSourcesContent(r9._sources.toArray(), r9.sourceRoot), r9.file = e2._file, r9._sourceMapURL = n14, r9._absoluteSources = r9._sources.toArray().map(function(g16) {
          return f15.computeSourceURL(r9.sourceRoot, g16, n14);
        });
        for (var s12 = e2._mappings.toArray().slice(), u17 = r9.__generatedMappings = [], l10 = r9.__originalMappings = [], a20 = 0, c16 = s12.length; a20 < c16; a20++) {
          var d20 = s12[a20], h20 = new Ie();
          h20.generatedLine = d20.generatedLine, h20.generatedColumn = d20.generatedColumn, d20.source && (h20.source = i14.indexOf(d20.source), h20.originalLine = d20.originalLine, h20.originalColumn = d20.originalColumn, d20.name && (h20.name = o10.indexOf(d20.name)), l10.push(h20)), u17.push(h20);
        }
        return F5(r9.__originalMappings, f15.compareByOriginalPositions), r9;
      };
      C19.prototype._version = 3;
      Object.defineProperty(C19.prototype, "sources", { get: function() {
        return this._absoluteSources.slice();
      } });
      function Ie() {
        this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
      }
      var se3 = f15.compareByGeneratedPositionsDeflatedNoLine;
      function Ge(t, e2) {
        let n14 = t.length, r9 = t.length - e2;
        if (!(r9 <= 1)) if (r9 == 2) {
          let o10 = t[e2], i14 = t[e2 + 1];
          se3(o10, i14) > 0 && (t[e2] = i14, t[e2 + 1] = o10);
        } else if (r9 < 20) for (let o10 = e2; o10 < n14; o10++) for (let i14 = o10; i14 > e2; i14--) {
          let s12 = t[i14 - 1], u17 = t[i14];
          if (se3(s12, u17) <= 0) break;
          t[i14 - 1] = u17, t[i14] = s12;
        }
        else F5(t, se3, e2);
      }
      C19.prototype._parseMappings = function(e2, n14) {
        var r9 = 1, o10 = 0, i14 = 0, s12 = 0, u17 = 0, l10 = 0, a20 = e2.length, c16 = 0, d20 = {}, h20 = {}, g16 = [], _22 = [], m23, je, y20, I12, ae3;
        let k13 = 0;
        for (; c16 < a20; ) if (e2.charAt(c16) === ";") r9++, c16++, o10 = 0, Ge(_22, k13), k13 = _22.length;
        else if (e2.charAt(c16) === ",") c16++;
        else {
          for (m23 = new Ie(), m23.generatedLine = r9, I12 = c16; I12 < a20 && !this._charIsMappingSeparator(e2, I12); I12++) ;
          for (je = e2.slice(c16, I12), y20 = []; c16 < I12; ) fr.decode(e2, c16, h20), ae3 = h20.value, c16 = h20.rest, y20.push(ae3);
          if (y20.length === 2) throw new Error("Found a source, but no line and column");
          if (y20.length === 3) throw new Error("Found a source and line, but no column");
          if (m23.generatedColumn = o10 + y20[0], o10 = m23.generatedColumn, y20.length > 1 && (m23.source = u17 + y20[1], u17 += y20[1], m23.originalLine = i14 + y20[2], i14 = m23.originalLine, m23.originalLine += 1, m23.originalColumn = s12 + y20[3], s12 = m23.originalColumn, y20.length > 4 && (m23.name = l10 + y20[4], l10 += y20[4])), _22.push(m23), typeof m23.originalLine == "number") {
            let z11 = m23.source;
            for (; g16.length <= z11; ) g16.push(null);
            g16[z11] === null && (g16[z11] = []), g16[z11].push(m23);
          }
        }
        Ge(_22, k13), this.__generatedMappings = _22;
        for (var U6 = 0; U6 < g16.length; U6++) g16[U6] != null && F5(g16[U6], f15.compareByOriginalPositionsNoSource);
        this.__originalMappings = [].concat(...g16);
      };
      C19.prototype._findMapping = function(e2, n14, r9, o10, i14, s12) {
        if (e2[r9] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + e2[r9]);
        if (e2[o10] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + e2[o10]);
        return ue4.search(e2, n14, i14, s12);
      };
      C19.prototype.computeColumnSpans = function() {
        for (var e2 = 0; e2 < this._generatedMappings.length; ++e2) {
          var n14 = this._generatedMappings[e2];
          if (e2 + 1 < this._generatedMappings.length) {
            var r9 = this._generatedMappings[e2 + 1];
            if (n14.generatedLine === r9.generatedLine) {
              n14.lastGeneratedColumn = r9.generatedColumn - 1;
              continue;
            }
          }
          n14.lastGeneratedColumn = 1 / 0;
        }
      };
      C19.prototype.originalPositionFor = function(e2) {
        var n14 = { generatedLine: f15.getArg(e2, "line"), generatedColumn: f15.getArg(e2, "column") }, r9 = this._findMapping(n14, this._generatedMappings, "generatedLine", "generatedColumn", f15.compareByGeneratedPositionsDeflated, f15.getArg(e2, "bias", v15.GREATEST_LOWER_BOUND));
        if (r9 >= 0) {
          var o10 = this._generatedMappings[r9];
          if (o10.generatedLine === n14.generatedLine) {
            var i14 = f15.getArg(o10, "source", null);
            i14 !== null && (i14 = this._sources.at(i14), i14 = f15.computeSourceURL(this.sourceRoot, i14, this._sourceMapURL));
            var s12 = f15.getArg(o10, "name", null);
            return s12 !== null && (s12 = this._names.at(s12)), { source: i14, line: f15.getArg(o10, "originalLine", null), column: f15.getArg(o10, "originalColumn", null), name: s12 };
          }
        }
        return { source: null, line: null, column: null, name: null };
      };
      C19.prototype.hasContentsOfAllSources = function() {
        return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(e2) {
          return e2 == null;
        }) : false;
      };
      C19.prototype.sourceContentFor = function(e2, n14) {
        if (!this.sourcesContent) return null;
        var r9 = this._findSourceIndex(e2);
        if (r9 >= 0) return this.sourcesContent[r9];
        var o10 = e2;
        this.sourceRoot != null && (o10 = f15.relative(this.sourceRoot, o10));
        var i14;
        if (this.sourceRoot != null && (i14 = f15.urlParse(this.sourceRoot))) {
          var s12 = o10.replace(/^file:\/\//, "");
          if (i14.scheme == "file" && this._sources.has(s12)) return this.sourcesContent[this._sources.indexOf(s12)];
          if ((!i14.path || i14.path == "/") && this._sources.has("/" + o10)) return this.sourcesContent[this._sources.indexOf("/" + o10)];
        }
        if (n14) return null;
        throw new Error('"' + o10 + '" is not in the SourceMap.');
      };
      C19.prototype.generatedPositionFor = function(e2) {
        var n14 = f15.getArg(e2, "source");
        if (n14 = this._findSourceIndex(n14), n14 < 0) return { line: null, column: null, lastColumn: null };
        var r9 = { source: n14, originalLine: f15.getArg(e2, "line"), originalColumn: f15.getArg(e2, "column") }, o10 = this._findMapping(r9, this._originalMappings, "originalLine", "originalColumn", f15.compareByOriginalPositions, f15.getArg(e2, "bias", v15.GREATEST_LOWER_BOUND));
        if (o10 >= 0) {
          var i14 = this._originalMappings[o10];
          if (i14.source === r9.source) return { line: f15.getArg(i14, "generatedLine", null), column: f15.getArg(i14, "generatedColumn", null), lastColumn: f15.getArg(i14, "lastGeneratedColumn", null) };
        }
        return { line: null, column: null, lastColumn: null };
      };
      W9.BasicSourceMapConsumer = C19;
      function A15(t, e2) {
        var n14 = t;
        typeof t == "string" && (n14 = f15.parseSourceMapInput(t));
        var r9 = f15.getArg(n14, "version"), o10 = f15.getArg(n14, "sections");
        if (r9 != this._version) throw new Error("Unsupported version: " + r9);
        this._sources = new D8(), this._names = new D8();
        var i14 = { line: -1, column: 0 };
        this._sections = o10.map(function(s12) {
          if (s12.url) throw new Error("Support for url field in sections not implemented.");
          var u17 = f15.getArg(s12, "offset"), l10 = f15.getArg(u17, "line"), a20 = f15.getArg(u17, "column");
          if (l10 < i14.line || l10 === i14.line && a20 < i14.column) throw new Error("Section offsets must be ordered and non-overlapping.");
          return i14 = u17, { generatedOffset: { generatedLine: l10 + 1, generatedColumn: a20 + 1 }, consumer: new v15(f15.getArg(s12, "map"), e2) };
        });
      }
      A15.prototype = Object.create(v15.prototype);
      A15.prototype.constructor = v15;
      A15.prototype._version = 3;
      Object.defineProperty(A15.prototype, "sources", { get: function() {
        for (var t = [], e2 = 0; e2 < this._sections.length; e2++) for (var n14 = 0; n14 < this._sections[e2].consumer.sources.length; n14++) t.push(this._sections[e2].consumer.sources[n14]);
        return t;
      } });
      A15.prototype.originalPositionFor = function(e2) {
        var n14 = { generatedLine: f15.getArg(e2, "line"), generatedColumn: f15.getArg(e2, "column") }, r9 = ue4.search(n14, this._sections, function(i14, s12) {
          var u17 = i14.generatedLine - s12.generatedOffset.generatedLine;
          return u17 || i14.generatedColumn - s12.generatedOffset.generatedColumn;
        }), o10 = this._sections[r9];
        return o10 ? o10.consumer.originalPositionFor({ line: n14.generatedLine - (o10.generatedOffset.generatedLine - 1), column: n14.generatedColumn - (o10.generatedOffset.generatedLine === n14.generatedLine ? o10.generatedOffset.generatedColumn - 1 : 0), bias: e2.bias }) : { source: null, line: null, column: null, name: null };
      };
      A15.prototype.hasContentsOfAllSources = function() {
        return this._sections.every(function(e2) {
          return e2.consumer.hasContentsOfAllSources();
        });
      };
      A15.prototype.sourceContentFor = function(e2, n14) {
        for (var r9 = 0; r9 < this._sections.length; r9++) {
          var o10 = this._sections[r9], i14 = o10.consumer.sourceContentFor(e2, true);
          if (i14 || i14 === "") return i14;
        }
        if (n14) return null;
        throw new Error('"' + e2 + '" is not in the SourceMap.');
      };
      A15.prototype.generatedPositionFor = function(e2) {
        for (var n14 = 0; n14 < this._sections.length; n14++) {
          var r9 = this._sections[n14];
          if (r9.consumer._findSourceIndex(f15.getArg(e2, "source")) !== -1) {
            var o10 = r9.consumer.generatedPositionFor(e2);
            if (o10) {
              var i14 = { line: o10.line + (r9.generatedOffset.generatedLine - 1), column: o10.column + (r9.generatedOffset.generatedLine === o10.line ? r9.generatedOffset.generatedColumn - 1 : 0) };
              return i14;
            }
          }
        }
        return { line: null, column: null };
      };
      A15.prototype._parseMappings = function(e2, n14) {
        this.__generatedMappings = [], this.__originalMappings = [];
        for (var r9 = 0; r9 < this._sections.length; r9++) for (var o10 = this._sections[r9], i14 = o10.consumer._generatedMappings, s12 = 0; s12 < i14.length; s12++) {
          var u17 = i14[s12], l10 = o10.consumer._sources.at(u17.source);
          l10 !== null && (l10 = f15.computeSourceURL(o10.consumer.sourceRoot, l10, this._sourceMapURL)), this._sources.add(l10), l10 = this._sources.indexOf(l10);
          var a20 = null;
          u17.name && (a20 = o10.consumer._names.at(u17.name), this._names.add(a20), a20 = this._names.indexOf(a20));
          var c16 = { source: l10, generatedLine: u17.generatedLine + (o10.generatedOffset.generatedLine - 1), generatedColumn: u17.generatedColumn + (o10.generatedOffset.generatedLine === u17.generatedLine ? o10.generatedOffset.generatedColumn - 1 : 0), originalLine: u17.originalLine, originalColumn: u17.originalColumn, name: a20 };
          this.__generatedMappings.push(c16), typeof c16.originalLine == "number" && this.__originalMappings.push(c16);
        }
        F5(this.__generatedMappings, f15.compareByGeneratedPositionsDeflated), F5(this.__originalMappings, f15.compareByOriginalPositions);
      };
      W9.IndexedSourceMapConsumer = A15;
    });
    De = w5((Te) => {
      var hr = oe2().SourceMapGenerator, $6 = T5(), dr = /(\r?\n)/, gr = 10, q16 = "$$$isSourceNode$$$";
      function L8(t, e2, n14, r9, o10) {
        this.children = [], this.sourceContents = {}, this.line = t ?? null, this.column = e2 ?? null, this.source = n14 ?? null, this.name = o10 ?? null, this[q16] = true, r9 != null && this.add(r9);
      }
      L8.fromStringWithSourceMap = function(e2, n14, r9) {
        var o10 = new L8(), i14 = e2.split(dr), s12 = 0, u17 = function() {
          var h20 = _22(), g16 = _22() || "";
          return h20 + g16;
          function _22() {
            return s12 < i14.length ? i14[s12++] : void 0;
          }
        }, l10 = 1, a20 = 0, c16 = null;
        return n14.eachMapping(function(h20) {
          if (c16 !== null) if (l10 < h20.generatedLine) d20(c16, u17()), l10++, a20 = 0;
          else {
            var g16 = i14[s12] || "", _22 = g16.substr(0, h20.generatedColumn - a20);
            i14[s12] = g16.substr(h20.generatedColumn - a20), a20 = h20.generatedColumn, d20(c16, _22), c16 = h20;
            return;
          }
          for (; l10 < h20.generatedLine; ) o10.add(u17()), l10++;
          if (a20 < h20.generatedColumn) {
            var g16 = i14[s12] || "";
            o10.add(g16.substr(0, h20.generatedColumn)), i14[s12] = g16.substr(h20.generatedColumn), a20 = h20.generatedColumn;
          }
          c16 = h20;
        }, this), s12 < i14.length && (c16 && d20(c16, u17()), o10.add(i14.splice(s12).join(""))), n14.sources.forEach(function(h20) {
          var g16 = n14.sourceContentFor(h20);
          g16 != null && (r9 != null && (h20 = $6.join(r9, h20)), o10.setSourceContent(h20, g16));
        }), o10;
        function d20(h20, g16) {
          if (h20 === null || h20.source === void 0) o10.add(g16);
          else {
            var _22 = r9 ? $6.join(r9, h20.source) : h20.source;
            o10.add(new L8(h20.originalLine, h20.originalColumn, _22, g16, h20.name));
          }
        }
      };
      L8.prototype.add = function(e2) {
        if (Array.isArray(e2)) e2.forEach(function(n14) {
          this.add(n14);
        }, this);
        else if (e2[q16] || typeof e2 == "string") e2 && this.children.push(e2);
        else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e2);
        return this;
      };
      L8.prototype.prepend = function(e2) {
        if (Array.isArray(e2)) for (var n14 = e2.length - 1; n14 >= 0; n14--) this.prepend(e2[n14]);
        else if (e2[q16] || typeof e2 == "string") this.children.unshift(e2);
        else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e2);
        return this;
      };
      L8.prototype.walk = function(e2) {
        for (var n14, r9 = 0, o10 = this.children.length; r9 < o10; r9++) n14 = this.children[r9], n14[q16] ? n14.walk(e2) : n14 !== "" && e2(n14, { source: this.source, line: this.line, column: this.column, name: this.name });
      };
      L8.prototype.join = function(e2) {
        var n14, r9, o10 = this.children.length;
        if (o10 > 0) {
          for (n14 = [], r9 = 0; r9 < o10 - 1; r9++) n14.push(this.children[r9]), n14.push(e2);
          n14.push(this.children[r9]), this.children = n14;
        }
        return this;
      };
      L8.prototype.replaceRight = function(e2, n14) {
        var r9 = this.children[this.children.length - 1];
        return r9[q16] ? r9.replaceRight(e2, n14) : typeof r9 == "string" ? this.children[this.children.length - 1] = r9.replace(e2, n14) : this.children.push("".replace(e2, n14)), this;
      };
      L8.prototype.setSourceContent = function(e2, n14) {
        this.sourceContents[$6.toSetString(e2)] = n14;
      };
      L8.prototype.walkSourceContents = function(e2) {
        for (var n14 = 0, r9 = this.children.length; n14 < r9; n14++) this.children[n14][q16] && this.children[n14].walkSourceContents(e2);
        for (var o10 = Object.keys(this.sourceContents), n14 = 0, r9 = o10.length; n14 < r9; n14++) e2($6.fromSetString(o10[n14]), this.sourceContents[o10[n14]]);
      };
      L8.prototype.toString = function() {
        var e2 = "";
        return this.walk(function(n14) {
          e2 += n14;
        }), e2;
      };
      L8.prototype.toStringWithSourceMap = function(e2) {
        var n14 = { code: "", line: 1, column: 0 }, r9 = new hr(e2), o10 = false, i14 = null, s12 = null, u17 = null, l10 = null;
        return this.walk(function(a20, c16) {
          n14.code += a20, c16.source !== null && c16.line !== null && c16.column !== null ? ((i14 !== c16.source || s12 !== c16.line || u17 !== c16.column || l10 !== c16.name) && r9.addMapping({ source: c16.source, original: { line: c16.line, column: c16.column }, generated: { line: n14.line, column: n14.column }, name: c16.name }), i14 = c16.source, s12 = c16.line, u17 = c16.column, l10 = c16.name, o10 = true) : o10 && (r9.addMapping({ generated: { line: n14.line, column: n14.column } }), i14 = null, o10 = false);
          for (var d20 = 0, h20 = a20.length; d20 < h20; d20++) a20.charCodeAt(d20) === gr ? (n14.line++, n14.column = 0, d20 + 1 === h20 ? (i14 = null, o10 = false) : o10 && r9.addMapping({ source: c16.source, original: { line: c16.line, column: c16.column }, generated: { line: n14.line, column: n14.column }, name: c16.name })) : n14.column++;
        }), this.walkSourceContents(function(a20, c16) {
          r9.setSourceContent(a20, c16);
        }), { code: n14.code, map: r9 };
      };
      Te.SourceNode = L8;
    });
    le3 = w5((V2) => {
      V2.SourceMapGenerator = oe2().SourceMapGenerator;
      V2.SourceMapConsumer = xe().SourceMapConsumer;
      V2.SourceNode = De().SourceNode;
    });
    b10 = {};
    We2(b10, { SourceMapConsumer: () => _r, SourceMapGenerator: () => vr, SourceNode: () => pr, default: () => Sr2 });
    Pe = ce(le3());
    N5(b10, ce(le3()));
    ({ SourceMapGenerator: vr, SourceMapConsumer: _r, SourceNode: pr } = Pe);
    ({ default: qe2, ...mr } = Pe);
    Sr2 = qe2 !== void 0 ? qe2 : mr;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/previous-map.js
var previous_map_exports = {};
__export(previous_map_exports, {
  default: () => O4
});
import { Buffer as __Buffer$2 } from "node:buffer";
import * as __0$2 from "node:fs";
import * as __1$2 from "node:path";
var require13, M3, u7, C9, F4, j9, _9, f6, A5, R2, l4, a8, p10, h12, o5, B4, U4, E2, O4;
var init_previous_map = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/previous-map.js"() {
    init_source_map_js();
    require13 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "fs":
          return e2(__0$2);
        case "path":
          return e2(__1$2);
        case "source-map-js":
          return e2(source_map_js_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    M3 = Object.create;
    u7 = Object.defineProperty;
    C9 = Object.getOwnPropertyDescriptor;
    F4 = Object.getOwnPropertyNames;
    j9 = Object.getPrototypeOf;
    _9 = Object.prototype.hasOwnProperty;
    f6 = ((n14) => typeof require13 < "u" ? require13 : typeof Proxy < "u" ? new Proxy(n14, { get: (t, e2) => (typeof require13 < "u" ? require13 : t)[e2] }) : n14)(function(n14) {
      if (typeof require13 < "u") return require13.apply(this, arguments);
      throw Error('Dynamic require of "' + n14 + '" is not supported');
    });
    A5 = (n14, t) => () => (t || n14((t = { exports: {} }).exports, t), t.exports);
    R2 = (n14, t) => {
      for (var e2 in t) u7(n14, e2, { get: t[e2], enumerable: true });
    };
    l4 = (n14, t, e2, i14) => {
      if (t && typeof t == "object" || typeof t == "function") for (let r9 of F4(t)) !_9.call(n14, r9) && r9 !== e2 && u7(n14, r9, { get: () => t[r9], enumerable: !(i14 = C9(t, r9)) || i14.enumerable });
      return n14;
    };
    a8 = (n14, t, e2) => (l4(n14, t, "default"), e2 && l4(e2, t, "default"));
    p10 = (n14, t, e2) => (e2 = n14 != null ? M3(j9(n14)) : {}, l4(t || !n14 || !n14.__esModule ? u7(e2, "default", { value: n14, enumerable: true }) : e2, n14));
    h12 = A5((G4, S16) => {
      "use strict";
      var { existsSync: I12, readFileSync: L8 } = f6("fs"), { dirname: c16, join: q16 } = f6("path"), { SourceMapConsumer: g16, SourceMapGenerator: b18 } = f6("source-map-js");
      function x22(n14) {
        return __Buffer$2 ? __Buffer$2.from(n14, "base64").toString() : window.atob(n14);
      }
      var s12 = class {
        constructor(t, e2) {
          if (e2.map === false) return;
          this.loadAnnotation(t), this.inline = this.startWith(this.annotation, "data:");
          let i14 = e2.map ? e2.map.prev : void 0, r9 = this.loadMap(e2.from, i14);
          !this.mapFile && e2.from && (this.mapFile = e2.from), this.mapFile && (this.root = c16(this.mapFile)), r9 && (this.text = r9);
        }
        consumer() {
          return this.consumerCache || (this.consumerCache = new g16(this.text)), this.consumerCache;
        }
        decodeInline(t) {
          let e2 = /^data:application\/json;charset=utf-?8;base64,/, i14 = /^data:application\/json;base64,/, r9 = /^data:application\/json;charset=utf-?8,/, w13 = /^data:application\/json,/, m23 = t.match(r9) || t.match(w13);
          if (m23) return decodeURIComponent(t.substr(m23[0].length));
          let d20 = t.match(e2) || t.match(i14);
          if (d20) return x22(t.substr(d20[0].length));
          let y20 = t.match(/data:application\/json;([^,]+),/)[1];
          throw new Error("Unsupported source map encoding " + y20);
        }
        getAnnotationURL(t) {
          return t.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
        }
        isMap(t) {
          return typeof t != "object" ? false : typeof t.mappings == "string" || typeof t._mappings == "string" || Array.isArray(t.sections);
        }
        loadAnnotation(t) {
          let e2 = t.match(/\/\*\s*# sourceMappingURL=/g);
          if (!e2) return;
          let i14 = t.lastIndexOf(e2.pop()), r9 = t.indexOf("*/", i14);
          i14 > -1 && r9 > -1 && (this.annotation = this.getAnnotationURL(t.substring(i14, r9)));
        }
        loadFile(t) {
          if (this.root = c16(t), I12(t)) return this.mapFile = t, L8(t, "utf-8").toString().trim();
        }
        loadMap(t, e2) {
          if (e2 === false) return false;
          if (e2) {
            if (typeof e2 == "string") return e2;
            if (typeof e2 == "function") {
              let i14 = e2(t);
              if (i14) {
                let r9 = this.loadFile(i14);
                if (!r9) throw new Error("Unable to load previous source map: " + i14.toString());
                return r9;
              }
            } else {
              if (e2 instanceof g16) return b18.fromSourceMap(e2).toString();
              if (e2 instanceof b18) return e2.toString();
              if (this.isMap(e2)) return JSON.stringify(e2);
              throw new Error("Unsupported previous source map format: " + e2.toString());
            }
          } else {
            if (this.inline) return this.decodeInline(this.annotation);
            if (this.annotation) {
              let i14 = this.annotation;
              return t && (i14 = q16(c16(t), i14)), this.loadFile(i14);
            }
          }
        }
        startWith(t, e2) {
          return t ? t.substr(0, e2.length) === e2 : false;
        }
        withContent() {
          return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
        }
      };
      S16.exports = s12;
      s12.default = s12;
    });
    o5 = {};
    R2(o5, { default: () => O4 });
    B4 = p10(h12());
    a8(o5, p10(h12()));
    ({ default: U4, ...E2 } = B4);
    O4 = U4 !== void 0 ? U4 : E2;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/input.js
var input_exports = {};
__export(input_exports, {
  default: () => $3
});
import * as __1$3 from "node:path";
import * as __3$2 from "node:url";
var require14, P3, C10, _10, B5, E3, A6, a9, U5, j10, S9, c7, y10, v8, m10, J4, R3, N6, $3;
var init_input = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/input.js"() {
    init_non_secure();
    init_source_map_js();
    init_css_syntax_error();
    init_previous_map();
    init_terminal_highlight();
    require14 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "nanoid/non-secure":
          return c16(non_secure_exports);
        case "path":
          return e2(__1$3);
        case "source-map-js":
          return e2(source_map_js_exports);
        case "url":
          return e2(__3$2);
        case "postcss/lib/css-syntax-error":
          return e2(css_syntax_error_exports);
        case "postcss/lib/previous-map":
          return e2(previous_map_exports);
        case "postcss/lib/terminal-highlight":
          return e2(terminal_highlight_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    P3 = Object.create;
    C10 = Object.defineProperty;
    _10 = Object.getOwnPropertyDescriptor;
    B5 = Object.getOwnPropertyNames;
    E3 = Object.getPrototypeOf;
    A6 = Object.prototype.hasOwnProperty;
    a9 = ((s12) => typeof require14 < "u" ? require14 : typeof Proxy < "u" ? new Proxy(s12, { get: (e2, i14) => (typeof require14 < "u" ? require14 : e2)[i14] }) : s12)(function(s12) {
      if (typeof require14 < "u") return require14.apply(this, arguments);
      throw Error('Dynamic require of "' + s12 + '" is not supported');
    });
    U5 = (s12, e2) => () => (e2 || s12((e2 = { exports: {} }).exports, e2), e2.exports);
    j10 = (s12, e2) => {
      for (var i14 in e2) C10(s12, i14, { get: e2[i14], enumerable: true });
    };
    S9 = (s12, e2, i14, t) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let l10 of B5(e2)) !A6.call(s12, l10) && l10 !== i14 && C10(s12, l10, { get: () => e2[l10], enumerable: !(t = _10(e2, l10)) || t.enumerable });
      return s12;
    };
    c7 = (s12, e2, i14) => (S9(s12, e2, "default"), i14 && S9(i14, e2, "default"));
    y10 = (s12, e2, i14) => (i14 = s12 != null ? P3(E3(s12)) : {}, S9(e2 || !s12 || !s12.__esModule ? C10(i14, "default", { value: s12, enumerable: true }) : i14, s12));
    v8 = U5((D8, M6) => {
      "use strict";
      var { nanoid: I12 } = a9("nanoid/non-secure"), { isAbsolute: F5, resolve: O11 } = a9("path"), { SourceMapConsumer: T9, SourceMapGenerator: k13 } = a9("source-map-js"), { fileURLToPath: x22, pathToFileURL: g16 } = a9("url"), L8 = a9("postcss/lib/css-syntax-error"), G4 = a9("postcss/lib/previous-map"), b18 = a9("postcss/lib/terminal-highlight"), w13 = Symbol("fromOffsetCache"), H5 = !!(T9 && k13), q16 = !!(O11 && F5), p20 = class {
        constructor(e2, i14 = {}) {
          if (e2 === null || typeof e2 > "u" || typeof e2 == "object" && !e2.toString) throw new Error(`PostCSS received ${e2} instead of CSS string`);
          if (this.css = e2.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, i14.from && (!q16 || /^\w+:\/\//.test(i14.from) || F5(i14.from) ? this.file = i14.from : this.file = O11(i14.from)), q16 && H5) {
            let t = new G4(this.css, i14);
            if (t.text) {
              this.map = t;
              let l10 = t.consumer().file;
              !this.file && l10 && (this.file = this.mapResolve(l10));
            }
          }
          this.file || (this.id = "<input css " + I12(6) + ">"), this.map && (this.map.file = this.from);
        }
        error(e2, i14, t, l10 = {}) {
          let n14, r9, f15;
          if (i14 && typeof i14 == "object") {
            let u17 = i14, h20 = t;
            if (typeof u17.offset == "number") {
              let d20 = this.fromOffset(u17.offset);
              i14 = d20.line, t = d20.col;
            } else i14 = u17.line, t = u17.column;
            if (typeof h20.offset == "number") {
              let d20 = this.fromOffset(h20.offset);
              r9 = d20.line, n14 = d20.col;
            } else r9 = h20.line, n14 = h20.column;
          } else if (!t) {
            let u17 = this.fromOffset(i14);
            i14 = u17.line, t = u17.col;
          }
          let o10 = this.origin(i14, t, r9, n14);
          return o10 ? f15 = new L8(e2, o10.endLine === void 0 ? o10.line : { column: o10.column, line: o10.line }, o10.endLine === void 0 ? o10.column : { column: o10.endColumn, line: o10.endLine }, o10.source, o10.file, l10.plugin) : f15 = new L8(e2, r9 === void 0 ? i14 : { column: t, line: i14 }, r9 === void 0 ? t : { column: n14, line: r9 }, this.css, this.file, l10.plugin), f15.input = { column: t, endColumn: n14, endLine: r9, line: i14, source: this.css }, this.file && (g16 && (f15.input.url = g16(this.file).toString()), f15.input.file = this.file), f15;
        }
        fromOffset(e2) {
          let i14, t;
          if (this[w13]) t = this[w13];
          else {
            let n14 = this.css.split(`
`);
            t = new Array(n14.length);
            let r9 = 0;
            for (let f15 = 0, o10 = n14.length; f15 < o10; f15++) t[f15] = r9, r9 += n14[f15].length + 1;
            this[w13] = t;
          }
          i14 = t[t.length - 1];
          let l10 = 0;
          if (e2 >= i14) l10 = t.length - 1;
          else {
            let n14 = t.length - 2, r9;
            for (; l10 < n14; ) if (r9 = l10 + (n14 - l10 >> 1), e2 < t[r9]) n14 = r9 - 1;
            else if (e2 >= t[r9 + 1]) l10 = r9 + 1;
            else {
              l10 = r9;
              break;
            }
          }
          return { col: e2 - t[l10] + 1, line: l10 + 1 };
        }
        mapResolve(e2) {
          return /^\w+:\/\//.test(e2) ? e2 : O11(this.map.consumer().sourceRoot || this.map.root || ".", e2);
        }
        origin(e2, i14, t, l10) {
          if (!this.map) return false;
          let n14 = this.map.consumer(), r9 = n14.originalPositionFor({ column: i14, line: e2 });
          if (!r9.source) return false;
          let f15;
          typeof t == "number" && (f15 = n14.originalPositionFor({ column: l10, line: t }));
          let o10;
          F5(r9.source) ? o10 = g16(r9.source) : o10 = new URL(r9.source, this.map.consumer().sourceRoot || g16(this.map.mapFile));
          let u17 = { column: r9.column, endColumn: f15 && f15.column, endLine: f15 && f15.line, line: r9.line, url: o10.toString() };
          if (o10.protocol === "file:") if (x22) u17.file = x22(o10);
          else throw new Error("file: protocol is not available in this PostCSS build");
          let h20 = n14.sourceContentFor(r9.source);
          return h20 && (u17.source = h20), u17;
        }
        toJSON() {
          let e2 = {};
          for (let i14 of ["hasBOM", "css", "file", "id"]) this[i14] != null && (e2[i14] = this[i14]);
          return this.map && (e2.map = { ...this.map }, e2.map.consumerCache && (e2.map.consumerCache = void 0)), e2;
        }
        get from() {
          return this.file || this.id;
        }
      };
      M6.exports = p20;
      p20.default = p20;
      b18 && b18.registerInput && b18.registerInput(p20);
    });
    m10 = {};
    j10(m10, { default: () => $3 });
    J4 = y10(v8());
    c7(m10, y10(v8()));
    ({ default: R3, ...N6 } = J4);
    $3 = R3 !== void 0 ? R3 : N6;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/root.js
var root_exports = {};
__export(root_exports, {
  default: () => q7
});
var require15, x11, l5, y11, z6, _11, m11, C11, R4, v9, d8, f7, a10, u8, n5, L3, g8, P4, q7;
var init_root = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/root.js"() {
    init_container();
    require15 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/container":
          return e2(container_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    x11 = Object.create;
    l5 = Object.defineProperty;
    y11 = Object.getOwnPropertyDescriptor;
    z6 = Object.getOwnPropertyNames;
    _11 = Object.getPrototypeOf;
    m11 = Object.prototype.hasOwnProperty;
    C11 = ((r9) => typeof require15 < "u" ? require15 : typeof Proxy < "u" ? new Proxy(r9, { get: (e2, t) => (typeof require15 < "u" ? require15 : e2)[t] }) : r9)(function(r9) {
      if (typeof require15 < "u") return require15.apply(this, arguments);
      throw Error('Dynamic require of "' + r9 + '" is not supported');
    });
    R4 = (r9, e2) => () => (e2 || r9((e2 = { exports: {} }).exports, e2), e2.exports);
    v9 = (r9, e2) => {
      for (var t in e2) l5(r9, t, { get: e2[t], enumerable: true });
    };
    d8 = (r9, e2, t, i14) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let s12 of z6(e2)) !m11.call(r9, s12) && s12 !== t && l5(r9, s12, { get: () => e2[s12], enumerable: !(i14 = y11(e2, s12)) || i14.enumerable });
      return r9;
    };
    f7 = (r9, e2, t) => (d8(r9, e2, "default"), t && d8(t, e2, "default"));
    a10 = (r9, e2, t) => (t = r9 != null ? x11(_11(r9)) : {}, d8(e2 || !r9 || !r9.__esModule ? l5(t, "default", { value: r9, enumerable: true }) : t, r9));
    u8 = R4((k13, c16) => {
      "use strict";
      var h20 = C11("postcss/lib/container"), w13, b18, o10 = class extends h20 {
        constructor(e2) {
          super(e2), this.type = "root", this.nodes || (this.nodes = []);
        }
        normalize(e2, t, i14) {
          let s12 = super.normalize(e2);
          if (t) {
            if (i14 === "prepend") this.nodes.length > 1 ? t.raws.before = this.nodes[1].raws.before : delete t.raws.before;
            else if (this.first !== t) for (let p20 of s12) p20.raws.before = t.raws.before;
          }
          return s12;
        }
        removeChild(e2, t) {
          let i14 = this.index(e2);
          return !t && i14 === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[i14].raws.before), super.removeChild(e2);
        }
        toResult(e2 = {}) {
          return new w13(new b18(), this, e2).stringify();
        }
      };
      o10.registerLazyResult = (r9) => {
        w13 = r9;
      };
      o10.registerProcessor = (r9) => {
        b18 = r9;
      };
      c16.exports = o10;
      o10.default = o10;
      h20.registerRoot(o10);
    });
    n5 = {};
    v9(n5, { default: () => q7 });
    L3 = a10(u8());
    f7(n5, a10(u8()));
    ({ default: g8, ...P4 } = L3);
    q7 = g8 !== void 0 ? g8 : P4;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/list.js
var list_exports = {};
__export(list_exports, {
  comma: () => A7,
  default: () => E4,
  space: () => B6,
  split: () => C12
});
var b11, d9, g9, j11, k8, q8, w6, z7, m12, i9, h13, _12, r2, y12, A7, B6, C12, v10, D4, E4;
var init_list = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/list.js"() {
    b11 = Object.create;
    d9 = Object.defineProperty;
    g9 = Object.getOwnPropertyDescriptor;
    j11 = Object.getOwnPropertyNames;
    k8 = Object.getPrototypeOf;
    q8 = Object.prototype.hasOwnProperty;
    w6 = (t, e2) => () => (e2 || t((e2 = { exports: {} }).exports, e2), e2.exports);
    z7 = (t, e2) => {
      for (var l10 in e2) d9(t, l10, { get: e2[l10], enumerable: true });
    };
    m12 = (t, e2, l10, u17) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let s12 of j11(e2)) !q8.call(t, s12) && s12 !== l10 && d9(t, s12, { get: () => e2[s12], enumerable: !(u17 = g9(e2, s12)) || u17.enumerable });
      return t;
    };
    i9 = (t, e2, l10) => (m12(t, e2, "default"), l10 && m12(l10, e2, "default"));
    h13 = (t, e2, l10) => (l10 = t != null ? b11(k8(t)) : {}, m12(e2 || !t || !t.__esModule ? d9(l10, "default", { value: t, enumerable: true }) : l10, t));
    _12 = w6((G4, Q3) => {
      "use strict";
      var a20 = { comma(t) {
        return a20.split(t, [","], true);
      }, space(t) {
        let e2 = [" ", `
`, "	"];
        return a20.split(t, e2);
      }, split(t, e2, l10) {
        let u17 = [], s12 = "", o10 = false, p20 = 0, c16 = false, x22 = "", n14 = false;
        for (let f15 of t) n14 ? n14 = false : f15 === "\\" ? n14 = true : c16 ? f15 === x22 && (c16 = false) : f15 === '"' || f15 === "'" ? (c16 = true, x22 = f15) : f15 === "(" ? p20 += 1 : f15 === ")" ? p20 > 0 && (p20 -= 1) : p20 === 0 && e2.includes(f15) && (o10 = true), o10 ? (s12 !== "" && u17.push(s12.trim()), s12 = "", o10 = false) : s12 += f15;
        return (l10 || s12 !== "") && u17.push(s12.trim()), u17;
      } };
      Q3.exports = a20;
      a20.default = a20;
    });
    r2 = {};
    z7(r2, { comma: () => A7, default: () => E4, space: () => B6, split: () => C12 });
    y12 = h13(_12());
    i9(r2, h13(_12()));
    ({ comma: A7, space: B6, split: C12 } = y12);
    ({ default: v10, ...D4 } = y12);
    E4 = v10 !== void 0 ? v10 : D4;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/rule.js
var rule_exports = {};
__export(rule_exports, {
  default: () => k9
});
var require16, _13, u9, x12, b12, g10, q9, d10, w7, j12, n6, o6, h14, a11, r3, C13, p11, O5, k9;
var init_rule = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/rule.js"() {
    init_container();
    init_list();
    require16 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/container":
          return e2(container_exports);
        case "postcss/lib/list":
          return e2(list_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    _13 = Object.create;
    u9 = Object.defineProperty;
    x12 = Object.getOwnPropertyDescriptor;
    b12 = Object.getOwnPropertyNames;
    g10 = Object.getPrototypeOf;
    q9 = Object.prototype.hasOwnProperty;
    d10 = ((t) => typeof require16 < "u" ? require16 : typeof Proxy < "u" ? new Proxy(t, { get: (e2, s12) => (typeof require16 < "u" ? require16 : e2)[s12] }) : t)(function(t) {
      if (typeof require16 < "u") return require16.apply(this, arguments);
      throw Error('Dynamic require of "' + t + '" is not supported');
    });
    w7 = (t, e2) => () => (e2 || t((e2 = { exports: {} }).exports, e2), e2.exports);
    j12 = (t, e2) => {
      for (var s12 in e2) u9(t, s12, { get: e2[s12], enumerable: true });
    };
    n6 = (t, e2, s12, c16) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let i14 of b12(e2)) !q9.call(t, i14) && i14 !== s12 && u9(t, i14, { get: () => e2[i14], enumerable: !(c16 = x12(e2, i14)) || c16.enumerable });
      return t;
    };
    o6 = (t, e2, s12) => (n6(t, e2, "default"), s12 && n6(s12, e2, "default"));
    h14 = (t, e2, s12) => (s12 = t != null ? _13(g10(t)) : {}, n6(e2 || !t || !t.__esModule ? u9(s12, "default", { value: t, enumerable: true }) : s12, t));
    a11 = w7((z11, m23) => {
      "use strict";
      var f15 = d10("postcss/lib/container"), y20 = d10("postcss/lib/list"), l10 = class extends f15 {
        constructor(e2) {
          super(e2), this.type = "rule", this.nodes || (this.nodes = []);
        }
        get selectors() {
          return y20.comma(this.selector);
        }
        set selectors(e2) {
          let s12 = this.selector ? this.selector.match(/,\s*/) : null, c16 = s12 ? s12[0] : "," + this.raw("between", "beforeOpen");
          this.selector = e2.join(c16);
        }
      };
      m23.exports = l10;
      l10.default = l10;
      f15.registerRule(l10);
    });
    r3 = {};
    j12(r3, { default: () => k9 });
    C13 = h14(a11());
    o6(r3, h14(a11()));
    ({ default: p11, ...O5 } = C13);
    k9 = p11 !== void 0 ? p11 : O5;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/fromJSON.js
var fromJSON_exports = {};
__export(fromJSON_exports, {
  default: () => N7
});
var require17, c8, s7, w8, q10, x13, A8, l6, I7, R5, a12, i10, m13, d11, n7, J5, y13, M4, N7;
var init_fromJSON = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/fromJSON.js"() {
    init_at_rule();
    init_comment();
    init_declaration();
    init_input();
    init_previous_map();
    init_root();
    init_rule();
    require17 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/at-rule":
          return e2(at_rule_exports);
        case "postcss/lib/comment":
          return e2(comment_exports);
        case "postcss/lib/declaration":
          return e2(declaration_exports);
        case "postcss/lib/input":
          return e2(input_exports);
        case "postcss/lib/previous-map":
          return e2(previous_map_exports);
        case "postcss/lib/root":
          return e2(root_exports);
        case "postcss/lib/rule":
          return e2(rule_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    c8 = Object.create;
    s7 = Object.defineProperty;
    w8 = Object.getOwnPropertyDescriptor;
    q10 = Object.getOwnPropertyNames;
    x13 = Object.getPrototypeOf;
    A8 = Object.prototype.hasOwnProperty;
    l6 = ((e2) => typeof require17 < "u" ? require17 : typeof Proxy < "u" ? new Proxy(e2, { get: (r9, u17) => (typeof require17 < "u" ? require17 : r9)[u17] }) : e2)(function(e2) {
      if (typeof require17 < "u") return require17.apply(this, arguments);
      throw Error('Dynamic require of "' + e2 + '" is not supported');
    });
    I7 = (e2, r9) => () => (r9 || e2((r9 = { exports: {} }).exports, r9), r9.exports);
    R5 = (e2, r9) => {
      for (var u17 in r9) s7(e2, u17, { get: r9[u17], enumerable: true });
    };
    a12 = (e2, r9, u17, t) => {
      if (r9 && typeof r9 == "object" || typeof r9 == "function") for (let o10 of q10(r9)) !A8.call(e2, o10) && o10 !== u17 && s7(e2, o10, { get: () => r9[o10], enumerable: !(t = w8(r9, o10)) || t.enumerable });
      return e2;
    };
    i10 = (e2, r9, u17) => (a12(e2, r9, "default"), u17 && a12(u17, r9, "default"));
    m13 = (e2, r9, u17) => (u17 = e2 != null ? c8(x13(e2)) : {}, a12(r9 || !e2 || !e2.__esModule ? s7(u17, "default", { value: e2, enumerable: true }) : u17, e2));
    d11 = I7((P11, _22) => {
      "use strict";
      var h20 = l6("postcss/lib/at-rule"), k13 = l6("postcss/lib/comment"), v15 = l6("postcss/lib/declaration"), C19 = l6("postcss/lib/input"), D8 = l6("postcss/lib/previous-map"), E11 = l6("postcss/lib/root"), H5 = l6("postcss/lib/rule");
      function f15(e2, r9) {
        if (Array.isArray(e2)) return e2.map((o10) => f15(o10));
        let { inputs: u17, ...t } = e2;
        if (u17) {
          r9 = [];
          for (let o10 of u17) {
            let p20 = { ...o10, __proto__: C19.prototype };
            p20.map && (p20.map = { ...p20.map, __proto__: D8.prototype }), r9.push(p20);
          }
        }
        if (t.nodes && (t.nodes = e2.nodes.map((o10) => f15(o10, r9))), t.source) {
          let { inputId: o10, ...p20 } = t.source;
          t.source = p20, o10 != null && (t.source.input = r9[o10]);
        }
        if (t.type === "root") return new E11(t);
        if (t.type === "decl") return new v15(t);
        if (t.type === "rule") return new H5(t);
        if (t.type === "comment") return new k13(t);
        if (t.type === "atrule") return new h20(t);
        throw new Error("Unknown node type: " + e2.type);
      }
      _22.exports = f15;
      f15.default = f15;
    });
    n7 = {};
    R5(n7, { default: () => N7 });
    J5 = m13(d11());
    i10(n7, m13(d11()));
    ({ default: y13, ...M4 } = J5);
    N7 = y13 !== void 0 ? y13 : M4;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/map-generator.js
var map_generator_exports = {};
__export(map_generator_exports, {
  default: () => T6
});
import { Buffer as __Buffer$3 } from "node:buffer";
import * as __0$3 from "node:path";
import * as __2$2 from "node:url";
var require18, b13, f8, L4, z8, A9, P5, p12, x14, B7, c9, a13, O6, d12, n8, j13, I8, E5, T6;
var init_map_generator = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/map-generator.js"() {
    init_source_map_js();
    init_input();
    require18 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "path":
          return e2(__0$3);
        case "source-map-js":
          return e2(source_map_js_exports);
        case "url":
          return e2(__2$2);
        case "postcss/lib/input":
          return e2(input_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    b13 = Object.create;
    f8 = Object.defineProperty;
    L4 = Object.getOwnPropertyDescriptor;
    z8 = Object.getOwnPropertyNames;
    A9 = Object.getPrototypeOf;
    P5 = Object.prototype.hasOwnProperty;
    p12 = ((o10) => typeof require18 < "u" ? require18 : typeof Proxy < "u" ? new Proxy(o10, { get: (t, e2) => (typeof require18 < "u" ? require18 : t)[e2] }) : o10)(function(o10) {
      if (typeof require18 < "u") return require18.apply(this, arguments);
      throw Error('Dynamic require of "' + o10 + '" is not supported');
    });
    x14 = (o10, t) => () => (t || o10((t = { exports: {} }).exports, t), t.exports);
    B7 = (o10, t) => {
      for (var e2 in t) f8(o10, e2, { get: t[e2], enumerable: true });
    };
    c9 = (o10, t, e2, s12) => {
      if (t && typeof t == "object" || typeof t == "function") for (let i14 of z8(t)) !P5.call(o10, i14) && i14 !== e2 && f8(o10, i14, { get: () => t[i14], enumerable: !(s12 = L4(t, i14)) || s12.enumerable });
      return o10;
    };
    a13 = (o10, t, e2) => (c9(o10, t, "default"), e2 && c9(e2, t, "default"));
    O6 = (o10, t, e2) => (e2 = o10 != null ? b13(A9(o10)) : {}, c9(t || !o10 || !o10.__esModule ? f8(e2, "default", { value: o10, enumerable: true }) : e2, o10));
    d12 = x14((D8, R8) => {
      "use strict";
      var { dirname: h20, relative: C19, resolve: w13, sep: y20 } = p12("path"), { SourceMapConsumer: F5, SourceMapGenerator: u17 } = p12("source-map-js"), { pathToFileURL: S16 } = p12("url"), _22 = p12("postcss/lib/input"), q16 = !!(F5 && u17), k13 = !!(h20 && w13 && C19 && y20), g16 = class {
        constructor(t, e2, s12, i14) {
          this.stringify = t, this.mapOpts = s12.map || {}, this.root = e2, this.opts = s12, this.css = i14, this.originalCSS = i14, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
        }
        addAnnotation() {
          let t;
          this.isInline() ? t = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? t = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? t = this.mapOpts.annotation(this.opts.to, this.root) : t = this.outputFile() + ".map";
          let e2 = `
`;
          this.css.includes(`\r
`) && (e2 = `\r
`), this.css += e2 + "/*# sourceMappingURL=" + t + " */";
        }
        applyPrevMaps() {
          for (let t of this.previous()) {
            let e2 = this.toUrl(this.path(t.file)), s12 = t.root || h20(t.file), i14;
            this.mapOpts.sourcesContent === false ? (i14 = new F5(t.text), i14.sourcesContent && (i14.sourcesContent = null)) : i14 = t.consumer(), this.map.applySourceMap(i14, e2, this.toUrl(this.path(s12)));
          }
        }
        clearAnnotation() {
          if (this.mapOpts.annotation !== false) if (this.root) {
            let t;
            for (let e2 = this.root.nodes.length - 1; e2 >= 0; e2--) t = this.root.nodes[e2], t.type === "comment" && t.text.startsWith("# sourceMappingURL=") && this.root.removeChild(e2);
          } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
        }
        generate() {
          if (this.clearAnnotation(), k13 && q16 && this.isMap()) return this.generateMap();
          {
            let t = "";
            return this.stringify(this.root, (e2) => {
              t += e2;
            }), [t];
          }
        }
        generateMap() {
          if (this.root) this.generateString();
          else if (this.previous().length === 1) {
            let t = this.previous()[0].consumer();
            t.file = this.outputFile(), this.map = u17.fromSourceMap(t, { ignoreInvalidMapping: true });
          } else this.map = new u17({ file: this.outputFile(), ignoreInvalidMapping: true }), this.map.addMapping({ generated: { column: 0, line: 1 }, original: { column: 0, line: 1 }, source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>" });
          return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
        }
        generateString() {
          this.css = "", this.map = new u17({ file: this.outputFile(), ignoreInvalidMapping: true });
          let t = 1, e2 = 1, s12 = "<no source>", i14 = { generated: { column: 0, line: 0 }, original: { column: 0, line: 0 }, source: "" }, v15, m23;
          this.stringify(this.root, (l10, r9, M6) => {
            if (this.css += l10, r9 && M6 !== "end" && (i14.generated.line = t, i14.generated.column = e2 - 1, r9.source && r9.source.start ? (i14.source = this.sourcePath(r9), i14.original.line = r9.source.start.line, i14.original.column = r9.source.start.column - 1, this.map.addMapping(i14)) : (i14.source = s12, i14.original.line = 1, i14.original.column = 0, this.map.addMapping(i14))), m23 = l10.match(/\n/g), m23 ? (t += m23.length, v15 = l10.lastIndexOf(`
`), e2 = l10.length - v15) : e2 += l10.length, r9 && M6 !== "start") {
              let U6 = r9.parent || { raws: {} };
              (!(r9.type === "decl" || r9.type === "atrule" && !r9.nodes) || r9 !== U6.last || U6.raws.semicolon) && (r9.source && r9.source.end ? (i14.source = this.sourcePath(r9), i14.original.line = r9.source.end.line, i14.original.column = r9.source.end.column - 1, i14.generated.line = t, i14.generated.column = e2 - 2, this.map.addMapping(i14)) : (i14.source = s12, i14.original.line = 1, i14.original.column = 0, i14.generated.line = t, i14.generated.column = e2 - 1, this.map.addMapping(i14)));
            }
          });
        }
        isAnnotation() {
          return this.isInline() ? true : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((t) => t.annotation) : true;
        }
        isInline() {
          if (typeof this.mapOpts.inline < "u") return this.mapOpts.inline;
          let t = this.mapOpts.annotation;
          return typeof t < "u" && t !== true ? false : this.previous().length ? this.previous().some((e2) => e2.inline) : true;
        }
        isMap() {
          return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
        }
        isSourcesContent() {
          return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((t) => t.withContent()) : true;
        }
        outputFile() {
          return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
        }
        path(t) {
          if (this.mapOpts.absolute || t.charCodeAt(0) === 60 || /^\w+:\/\//.test(t)) return t;
          let e2 = this.memoizedPaths.get(t);
          if (e2) return e2;
          let s12 = this.opts.to ? h20(this.opts.to) : ".";
          typeof this.mapOpts.annotation == "string" && (s12 = h20(w13(s12, this.mapOpts.annotation)));
          let i14 = C19(s12, t);
          return this.memoizedPaths.set(t, i14), i14;
        }
        previous() {
          if (!this.previousMaps) if (this.previousMaps = [], this.root) this.root.walk((t) => {
            if (t.source && t.source.input.map) {
              let e2 = t.source.input.map;
              this.previousMaps.includes(e2) || this.previousMaps.push(e2);
            }
          });
          else {
            let t = new _22(this.originalCSS, this.opts);
            t.map && this.previousMaps.push(t.map);
          }
          return this.previousMaps;
        }
        setSourcesContent() {
          let t = {};
          if (this.root) this.root.walk((e2) => {
            if (e2.source) {
              let s12 = e2.source.input.from;
              if (s12 && !t[s12]) {
                t[s12] = true;
                let i14 = this.usesFileUrls ? this.toFileUrl(s12) : this.toUrl(this.path(s12));
                this.map.setSourceContent(i14, e2.source.input.css);
              }
            }
          });
          else if (this.css) {
            let e2 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
            this.map.setSourceContent(e2, this.css);
          }
        }
        sourcePath(t) {
          return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(t.source.input.from) : this.toUrl(this.path(t.source.input.from));
        }
        toBase64(t) {
          return __Buffer$3 ? __Buffer$3.from(t).toString("base64") : window.btoa(unescape(encodeURIComponent(t)));
        }
        toFileUrl(t) {
          let e2 = this.memoizedFileURLs.get(t);
          if (e2) return e2;
          if (S16) {
            let s12 = S16(t).toString();
            return this.memoizedFileURLs.set(t, s12), s12;
          } else throw new Error("`map.absolute` option is not available in this PostCSS build");
        }
        toUrl(t) {
          let e2 = this.memoizedURLs.get(t);
          if (e2) return e2;
          y20 === "\\" && (t = t.replace(/\\/g, "/"));
          let s12 = encodeURI(t).replace(/[#?]/g, encodeURIComponent);
          return this.memoizedURLs.set(t, s12), s12;
        }
      };
      R8.exports = g16;
    });
    n8 = {};
    B7(n8, { default: () => T6 });
    j13 = O6(d12());
    a13(n8, O6(d12()));
    ({ default: I8, ...E5 } = j13);
    T6 = I8 !== void 0 ? I8 : E5;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/parser.js
var parser_exports = {};
__export(parser_exports, {
  default: () => $4
});
var require19, T7, b14, W6, _14, E6, v11, m14, M5, O7, g11, d13, y14, x15, p13, L5, A10, D5, $4;
var init_parser = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/parser.js"() {
    init_at_rule();
    init_comment();
    init_declaration();
    init_root();
    init_rule();
    init_tokenize();
    require19 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/at-rule":
          return e2(at_rule_exports);
        case "postcss/lib/comment":
          return e2(comment_exports);
        case "postcss/lib/declaration":
          return e2(declaration_exports);
        case "postcss/lib/root":
          return e2(root_exports);
        case "postcss/lib/rule":
          return e2(rule_exports);
        case "postcss/lib/tokenize":
          return e2(tokenize_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    T7 = Object.create;
    b14 = Object.defineProperty;
    W6 = Object.getOwnPropertyDescriptor;
    _14 = Object.getOwnPropertyNames;
    E6 = Object.getPrototypeOf;
    v11 = Object.prototype.hasOwnProperty;
    m14 = ((o10) => typeof require19 < "u" ? require19 : typeof Proxy < "u" ? new Proxy(o10, { get: (e2, t) => (typeof require19 < "u" ? require19 : e2)[t] }) : o10)(function(o10) {
      if (typeof require19 < "u") return require19.apply(this, arguments);
      throw Error('Dynamic require of "' + o10 + '" is not supported');
    });
    M5 = (o10, e2) => () => (e2 || o10((e2 = { exports: {} }).exports, e2), e2.exports);
    O7 = (o10, e2) => {
      for (var t in e2) b14(o10, t, { get: e2[t], enumerable: true });
    };
    g11 = (o10, e2, t, s12) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let i14 of _14(e2)) !v11.call(o10, i14) && i14 !== t && b14(o10, i14, { get: () => e2[i14], enumerable: !(s12 = W6(e2, i14)) || s12.enumerable });
      return o10;
    };
    d13 = (o10, e2, t) => (g11(o10, e2, "default"), t && g11(t, e2, "default"));
    y14 = (o10, e2, t) => (t = o10 != null ? T7(E6(o10)) : {}, g11(e2 || !o10 || !o10.__esModule ? b14(t, "default", { value: o10, enumerable: true }) : t, o10));
    x15 = M5((H5, S16) => {
      "use strict";
      var q16 = m14("postcss/lib/at-rule"), R8 = m14("postcss/lib/comment"), B10 = m14("postcss/lib/declaration"), N12 = m14("postcss/lib/root"), z11 = m14("postcss/lib/rule"), U6 = m14("postcss/lib/tokenize"), C19 = { empty: true, space: true };
      function j16(o10) {
        for (let e2 = o10.length - 1; e2 >= 0; e2--) {
          let t = o10[e2], s12 = t[3] || t[2];
          if (s12) return s12;
        }
      }
      var F5 = class {
        constructor(e2) {
          this.input = e2, this.root = new N12(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = { input: e2, start: { column: 1, line: 1, offset: 0 } };
        }
        atrule(e2) {
          let t = new q16();
          t.name = e2[1].slice(1), t.name === "" && this.unnamedAtrule(t, e2), this.init(t, e2[2]);
          let s12, i14, r9, h20 = false, a20 = false, n14 = [], l10 = [];
          for (; !this.tokenizer.endOfFile(); ) {
            if (e2 = this.tokenizer.nextToken(), s12 = e2[0], s12 === "(" || s12 === "[" ? l10.push(s12 === "(" ? ")" : "]") : s12 === "{" && l10.length > 0 ? l10.push("}") : s12 === l10[l10.length - 1] && l10.pop(), l10.length === 0) if (s12 === ";") {
              t.source.end = this.getPosition(e2[2]), t.source.end.offset++, this.semicolon = true;
              break;
            } else if (s12 === "{") {
              a20 = true;
              break;
            } else if (s12 === "}") {
              if (n14.length > 0) {
                for (r9 = n14.length - 1, i14 = n14[r9]; i14 && i14[0] === "space"; ) i14 = n14[--r9];
                i14 && (t.source.end = this.getPosition(i14[3] || i14[2]), t.source.end.offset++);
              }
              this.end(e2);
              break;
            } else n14.push(e2);
            else n14.push(e2);
            if (this.tokenizer.endOfFile()) {
              h20 = true;
              break;
            }
          }
          t.raws.between = this.spacesAndCommentsFromEnd(n14), n14.length ? (t.raws.afterName = this.spacesAndCommentsFromStart(n14), this.raw(t, "params", n14), h20 && (e2 = n14[n14.length - 1], t.source.end = this.getPosition(e2[3] || e2[2]), t.source.end.offset++, this.spaces = t.raws.between, t.raws.between = "")) : (t.raws.afterName = "", t.params = ""), a20 && (t.nodes = [], this.current = t);
        }
        checkMissedSemicolon(e2) {
          let t = this.colon(e2);
          if (t === false) return;
          let s12 = 0, i14;
          for (let r9 = t - 1; r9 >= 0 && (i14 = e2[r9], !(i14[0] !== "space" && (s12 += 1, s12 === 2))); r9--) ;
          throw this.input.error("Missed semicolon", i14[0] === "word" ? i14[3] + 1 : i14[2]);
        }
        colon(e2) {
          let t = 0, s12, i14, r9;
          for (let [h20, a20] of e2.entries()) {
            if (i14 = a20, r9 = i14[0], r9 === "(" && (t += 1), r9 === ")" && (t -= 1), t === 0 && r9 === ":") if (!s12) this.doubleColon(i14);
            else {
              if (s12[0] === "word" && s12[1] === "progid") continue;
              return h20;
            }
            s12 = i14;
          }
          return false;
        }
        comment(e2) {
          let t = new R8();
          this.init(t, e2[2]), t.source.end = this.getPosition(e2[3] || e2[2]), t.source.end.offset++;
          let s12 = e2[1].slice(2, -2);
          if (/^\s*$/.test(s12)) t.text = "", t.raws.left = s12, t.raws.right = "";
          else {
            let i14 = s12.match(/^(\s*)([^]*\S)(\s*)$/);
            t.text = i14[2], t.raws.left = i14[1], t.raws.right = i14[3];
          }
        }
        createTokenizer() {
          this.tokenizer = U6(this.input);
        }
        decl(e2, t) {
          let s12 = new B10();
          this.init(s12, e2[0][2]);
          let i14 = e2[e2.length - 1];
          for (i14[0] === ";" && (this.semicolon = true, e2.pop()), s12.source.end = this.getPosition(i14[3] || i14[2] || j16(e2)), s12.source.end.offset++; e2[0][0] !== "word"; ) e2.length === 1 && this.unknownWord(e2), s12.raws.before += e2.shift()[1];
          for (s12.source.start = this.getPosition(e2[0][2]), s12.prop = ""; e2.length; ) {
            let l10 = e2[0][0];
            if (l10 === ":" || l10 === "space" || l10 === "comment") break;
            s12.prop += e2.shift()[1];
          }
          s12.raws.between = "";
          let r9;
          for (; e2.length; ) if (r9 = e2.shift(), r9[0] === ":") {
            s12.raws.between += r9[1];
            break;
          } else r9[0] === "word" && /\w/.test(r9[1]) && this.unknownWord([r9]), s12.raws.between += r9[1];
          (s12.prop[0] === "_" || s12.prop[0] === "*") && (s12.raws.before += s12.prop[0], s12.prop = s12.prop.slice(1));
          let h20 = [], a20;
          for (; e2.length && (a20 = e2[0][0], !(a20 !== "space" && a20 !== "comment")); ) h20.push(e2.shift());
          this.precheckMissedSemicolon(e2);
          for (let l10 = e2.length - 1; l10 >= 0; l10--) {
            if (r9 = e2[l10], r9[1].toLowerCase() === "!important") {
              s12.important = true;
              let f15 = this.stringFrom(e2, l10);
              f15 = this.spacesFromEnd(e2) + f15, f15 !== " !important" && (s12.raws.important = f15);
              break;
            } else if (r9[1].toLowerCase() === "important") {
              let f15 = e2.slice(0), u17 = "";
              for (let c16 = l10; c16 > 0; c16--) {
                let w13 = f15[c16][0];
                if (u17.trim().startsWith("!") && w13 !== "space") break;
                u17 = f15.pop()[1] + u17;
              }
              u17.trim().startsWith("!") && (s12.important = true, s12.raws.important = u17, e2 = f15);
            }
            if (r9[0] !== "space" && r9[0] !== "comment") break;
          }
          e2.some((l10) => l10[0] !== "space" && l10[0] !== "comment") && (s12.raws.between += h20.map((l10) => l10[1]).join(""), h20 = []), this.raw(s12, "value", h20.concat(e2), t), s12.value.includes(":") && !t && this.checkMissedSemicolon(e2);
        }
        doubleColon(e2) {
          throw this.input.error("Double colon", { offset: e2[2] }, { offset: e2[2] + e2[1].length });
        }
        emptyRule(e2) {
          let t = new z11();
          this.init(t, e2[2]), t.selector = "", t.raws.between = "", this.current = t;
        }
        end(e2) {
          this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e2[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e2);
        }
        endFile() {
          this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
        }
        freeSemicolon(e2) {
          if (this.spaces += e2[1], this.current.nodes) {
            let t = this.current.nodes[this.current.nodes.length - 1];
            t && t.type === "rule" && !t.raws.ownSemicolon && (t.raws.ownSemicolon = this.spaces, this.spaces = "");
          }
        }
        getPosition(e2) {
          let t = this.input.fromOffset(e2);
          return { column: t.col, line: t.line, offset: e2 };
        }
        init(e2, t) {
          this.current.push(e2), e2.source = { input: this.input, start: this.getPosition(t) }, e2.raws.before = this.spaces, this.spaces = "", e2.type !== "comment" && (this.semicolon = false);
        }
        other(e2) {
          let t = false, s12 = null, i14 = false, r9 = null, h20 = [], a20 = e2[1].startsWith("--"), n14 = [], l10 = e2;
          for (; l10; ) {
            if (s12 = l10[0], n14.push(l10), s12 === "(" || s12 === "[") r9 || (r9 = l10), h20.push(s12 === "(" ? ")" : "]");
            else if (a20 && i14 && s12 === "{") r9 || (r9 = l10), h20.push("}");
            else if (h20.length === 0) if (s12 === ";") if (i14) {
              this.decl(n14, a20);
              return;
            } else break;
            else if (s12 === "{") {
              this.rule(n14);
              return;
            } else if (s12 === "}") {
              this.tokenizer.back(n14.pop()), t = true;
              break;
            } else s12 === ":" && (i14 = true);
            else s12 === h20[h20.length - 1] && (h20.pop(), h20.length === 0 && (r9 = null));
            l10 = this.tokenizer.nextToken();
          }
          if (this.tokenizer.endOfFile() && (t = true), h20.length > 0 && this.unclosedBracket(r9), t && i14) {
            if (!a20) for (; n14.length && (l10 = n14[n14.length - 1][0], !(l10 !== "space" && l10 !== "comment")); ) this.tokenizer.back(n14.pop());
            this.decl(n14, a20);
          } else this.unknownWord(n14);
        }
        parse() {
          let e2;
          for (; !this.tokenizer.endOfFile(); ) switch (e2 = this.tokenizer.nextToken(), e2[0]) {
            case "space":
              this.spaces += e2[1];
              break;
            case ";":
              this.freeSemicolon(e2);
              break;
            case "}":
              this.end(e2);
              break;
            case "comment":
              this.comment(e2);
              break;
            case "at-word":
              this.atrule(e2);
              break;
            case "{":
              this.emptyRule(e2);
              break;
            default:
              this.other(e2);
              break;
          }
          this.endFile();
        }
        precheckMissedSemicolon() {
        }
        raw(e2, t, s12, i14) {
          let r9, h20, a20 = s12.length, n14 = "", l10 = true, f15, u17;
          for (let c16 = 0; c16 < a20; c16 += 1) r9 = s12[c16], h20 = r9[0], h20 === "space" && c16 === a20 - 1 && !i14 ? l10 = false : h20 === "comment" ? (u17 = s12[c16 - 1] ? s12[c16 - 1][0] : "empty", f15 = s12[c16 + 1] ? s12[c16 + 1][0] : "empty", !C19[u17] && !C19[f15] ? n14.slice(-1) === "," ? l10 = false : n14 += r9[1] : l10 = false) : n14 += r9[1];
          if (!l10) {
            let c16 = s12.reduce((w13, P11) => w13 + P11[1], "");
            e2.raws[t] = { raw: c16, value: n14 };
          }
          e2[t] = n14;
        }
        rule(e2) {
          e2.pop();
          let t = new z11();
          this.init(t, e2[0][2]), t.raws.between = this.spacesAndCommentsFromEnd(e2), this.raw(t, "selector", e2), this.current = t;
        }
        spacesAndCommentsFromEnd(e2) {
          let t, s12 = "";
          for (; e2.length && (t = e2[e2.length - 1][0], !(t !== "space" && t !== "comment")); ) s12 = e2.pop()[1] + s12;
          return s12;
        }
        spacesAndCommentsFromStart(e2) {
          let t, s12 = "";
          for (; e2.length && (t = e2[0][0], !(t !== "space" && t !== "comment")); ) s12 += e2.shift()[1];
          return s12;
        }
        spacesFromEnd(e2) {
          let t, s12 = "";
          for (; e2.length && (t = e2[e2.length - 1][0], t === "space"); ) s12 = e2.pop()[1] + s12;
          return s12;
        }
        stringFrom(e2, t) {
          let s12 = "";
          for (let i14 = t; i14 < e2.length; i14++) s12 += e2[i14][1];
          return e2.splice(t, e2.length - t), s12;
        }
        unclosedBlock() {
          let e2 = this.current.source.start;
          throw this.input.error("Unclosed block", e2.line, e2.column);
        }
        unclosedBracket(e2) {
          throw this.input.error("Unclosed bracket", { offset: e2[2] }, { offset: e2[2] + 1 });
        }
        unexpectedClose(e2) {
          throw this.input.error("Unexpected }", { offset: e2[2] }, { offset: e2[2] + 1 });
        }
        unknownWord(e2) {
          throw this.input.error("Unknown word", { offset: e2[0][2] }, { offset: e2[0][2] + e2[0][1].length });
        }
        unnamedAtrule(e2, t) {
          throw this.input.error("At-rule without name", { offset: t[2] }, { offset: t[2] + t[1].length });
        }
      };
      S16.exports = F5;
    });
    p13 = {};
    O7(p13, { default: () => $4 });
    L5 = y14(x15());
    d13(p13, y14(x15()));
    ({ default: A10, ...D5 } = L5);
    $4 = A10 !== void 0 ? A10 : D5;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/parse.js
var parse_exports = {};
__export(parse_exports, {
  default: () => P6
});
var require20, m15, u10, S10, w9, g12, _15, d14, C14, y15, n9, o7, h15, f9, a14, Y3, c10, N8, P6;
var init_parse = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/parse.js"() {
    init_container();
    init_input();
    init_parser();
    require20 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/container":
          return e2(container_exports);
        case "postcss/lib/input":
          return e2(input_exports);
        case "postcss/lib/parser":
          return e2(parser_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    m15 = Object.create;
    u10 = Object.defineProperty;
    S10 = Object.getOwnPropertyDescriptor;
    w9 = Object.getOwnPropertyNames;
    g12 = Object.getPrototypeOf;
    _15 = Object.prototype.hasOwnProperty;
    d14 = ((e2) => typeof require20 < "u" ? require20 : typeof Proxy < "u" ? new Proxy(e2, { get: (s12, t) => (typeof require20 < "u" ? require20 : s12)[t] }) : e2)(function(e2) {
      if (typeof require20 < "u") return require20.apply(this, arguments);
      throw Error('Dynamic require of "' + e2 + '" is not supported');
    });
    C14 = (e2, s12) => () => (s12 || e2((s12 = { exports: {} }).exports, s12), s12.exports);
    y15 = (e2, s12) => {
      for (var t in s12) u10(e2, t, { get: s12[t], enumerable: true });
    };
    n9 = (e2, s12, t, i14) => {
      if (s12 && typeof s12 == "object" || typeof s12 == "function") for (let r9 of w9(s12)) !_15.call(e2, r9) && r9 !== t && u10(e2, r9, { get: () => s12[r9], enumerable: !(i14 = S10(s12, r9)) || i14.enumerable });
      return e2;
    };
    o7 = (e2, s12, t) => (n9(e2, s12, "default"), t && n9(t, s12, "default"));
    h15 = (e2, s12, t) => (t = e2 != null ? m15(g12(e2)) : {}, n9(s12 || !e2 || !e2.__esModule ? u10(t, "default", { value: e2, enumerable: true }) : t, e2));
    f9 = C14((v15, l10) => {
      "use strict";
      var x22 = d14("postcss/lib/container"), q16 = d14("postcss/lib/input"), E11 = d14("postcss/lib/parser");
      function p20(e2, s12) {
        let t = new q16(e2, s12), i14 = new E11(t);
        try {
          i14.parse();
        } catch (r9) {
          throw r9;
        }
        return i14.root;
      }
      l10.exports = p20;
      p20.default = p20;
      x22.registerParse(p20);
    });
    a14 = {};
    y15(a14, { default: () => P6 });
    Y3 = h15(f9());
    o7(a14, h15(f9()));
    ({ default: c10, ...N8 } = Y3);
    P6 = c10 !== void 0 ? c10 : N8;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/warning.js
var warning_exports = {};
__export(warning_exports, {
  default: () => L6
});
var m16, l7, x16, g13, _16, p14, w10, y16, u11, s8, a15, h16, r4, B8, c11, C15, L6;
var init_warning = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/warning.js"() {
    m16 = Object.create;
    l7 = Object.defineProperty;
    x16 = Object.getOwnPropertyDescriptor;
    g13 = Object.getOwnPropertyNames;
    _16 = Object.getPrototypeOf;
    p14 = Object.prototype.hasOwnProperty;
    w10 = (i14, t) => () => (t || i14((t = { exports: {} }).exports, t), t.exports);
    y16 = (i14, t) => {
      for (var e2 in t) l7(i14, e2, { get: t[e2], enumerable: true });
    };
    u11 = (i14, t, e2, n14) => {
      if (t && typeof t == "object" || typeof t == "function") for (let o10 of g13(t)) !p14.call(i14, o10) && o10 !== e2 && l7(i14, o10, { get: () => t[o10], enumerable: !(n14 = x16(t, o10)) || n14.enumerable });
      return i14;
    };
    s8 = (i14, t, e2) => (u11(i14, t, "default"), e2 && u11(e2, t, "default"));
    a15 = (i14, t, e2) => (e2 = i14 != null ? m16(_16(i14)) : {}, u11(t || !i14 || !i14.__esModule ? l7(e2, "default", { value: i14, enumerable: true }) : e2, i14));
    h16 = w10((b18, f15) => {
      "use strict";
      var d20 = class {
        constructor(t, e2 = {}) {
          if (this.type = "warning", this.text = t, e2.node && e2.node.source) {
            let n14 = e2.node.rangeBy(e2);
            this.line = n14.start.line, this.column = n14.start.column, this.endLine = n14.end.line, this.endColumn = n14.end.column;
          }
          for (let n14 in e2) this[n14] = e2[n14];
        }
        toString() {
          return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
        }
      };
      f15.exports = d20;
      d20.default = d20;
    });
    r4 = {};
    y16(r4, { default: () => L6 });
    B8 = a15(h16());
    s8(r4, a15(h16()));
    ({ default: c11, ...C15 } = B8);
    L6 = c11 !== void 0 ? c11 : C15;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/result.js
var result_exports = {};
__export(result_exports, {
  default: () => b15
});
var require21, d15, o8, p15, m17, _17, w11, P7, x17, q11, l8, r5, h17, g14, n10, S11, f10, W7, b15;
var init_result = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/result.js"() {
    init_warning();
    require21 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/warning":
          return e2(warning_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    d15 = Object.create;
    o8 = Object.defineProperty;
    p15 = Object.getOwnPropertyDescriptor;
    m17 = Object.getOwnPropertyNames;
    _17 = Object.getPrototypeOf;
    w11 = Object.prototype.hasOwnProperty;
    P7 = ((t) => typeof require21 < "u" ? require21 : typeof Proxy < "u" ? new Proxy(t, { get: (s12, e2) => (typeof require21 < "u" ? require21 : s12)[e2] }) : t)(function(t) {
      if (typeof require21 < "u") return require21.apply(this, arguments);
      throw Error('Dynamic require of "' + t + '" is not supported');
    });
    x17 = (t, s12) => () => (s12 || t((s12 = { exports: {} }).exports, s12), s12.exports);
    q11 = (t, s12) => {
      for (var e2 in s12) o8(t, e2, { get: s12[e2], enumerable: true });
    };
    l8 = (t, s12, e2, i14) => {
      if (s12 && typeof s12 == "object" || typeof s12 == "function") for (let u17 of m17(s12)) !w11.call(t, u17) && u17 !== e2 && o8(t, u17, { get: () => s12[u17], enumerable: !(i14 = p15(s12, u17)) || i14.enumerable });
      return t;
    };
    r5 = (t, s12, e2) => (l8(t, s12, "default"), e2 && l8(e2, s12, "default"));
    h17 = (t, s12, e2) => (e2 = t != null ? d15(_17(t)) : {}, l8(s12 || !t || !t.__esModule ? o8(e2, "default", { value: t, enumerable: true }) : e2, t));
    g14 = x17((k13, c16) => {
      "use strict";
      var y20 = P7("postcss/lib/warning"), a20 = class {
        constructor(s12, e2, i14) {
          this.processor = s12, this.messages = [], this.root = e2, this.opts = i14, this.css = void 0, this.map = void 0;
        }
        toString() {
          return this.css;
        }
        warn(s12, e2 = {}) {
          e2.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (e2.plugin = this.lastPlugin.postcssPlugin);
          let i14 = new y20(s12, e2);
          return this.messages.push(i14), i14;
        }
        warnings() {
          return this.messages.filter((s12) => s12.type === "warning");
        }
        get content() {
          return this.css;
        }
      };
      c16.exports = a20;
      a20.default = a20;
    });
    n10 = {};
    q11(n10, { default: () => b15 });
    S11 = h17(g14());
    r5(n10, h17(g14()));
    ({ default: f10, ...W7 } = S11);
    b15 = f10 !== void 0 ? f10 : W7;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/warn-once.js
var warn_once_exports = {};
__export(warn_once_exports, {
  default: () => k10
});
var s9, d16, w12, x18, m18, y17, O8, b16, u12, r6, c12, i11, o9, h18, a16, j14, k10;
var init_warn_once = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/warn-once.js"() {
    s9 = Object.create;
    d16 = Object.defineProperty;
    w12 = Object.getOwnPropertyDescriptor;
    x18 = Object.getOwnPropertyNames;
    m18 = Object.getPrototypeOf;
    y17 = Object.prototype.hasOwnProperty;
    O8 = (t, e2) => () => (e2 || t((e2 = { exports: {} }).exports, e2), e2.exports);
    b16 = (t, e2) => {
      for (var n14 in e2) d16(t, n14, { get: e2[n14], enumerable: true });
    };
    u12 = (t, e2, n14, l10) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let f15 of x18(e2)) !y17.call(t, f15) && f15 !== n14 && d16(t, f15, { get: () => e2[f15], enumerable: !(l10 = w12(e2, f15)) || l10.enumerable });
      return t;
    };
    r6 = (t, e2, n14) => (u12(t, e2, "default"), n14 && u12(n14, e2, "default"));
    c12 = (t, e2, n14) => (n14 = t != null ? s9(m18(t)) : {}, u12(e2 || !t || !t.__esModule ? d16(n14, "default", { value: t, enumerable: true }) : n14, t));
    i11 = O8((v15, _22) => {
      "use strict";
      var p20 = {};
      _22.exports = function(e2) {
        p20[e2] || (p20[e2] = true, typeof console < "u" && console.warn && console.warn(e2));
      };
    });
    o9 = {};
    b16(o9, { default: () => k10 });
    h18 = c12(i11());
    r6(o9, c12(i11()));
    ({ default: a16, ...j14 } = h18);
    k10 = a16 !== void 0 ? a16 : j14;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/lazy-result.js
var lazy_result_exports = {};
__export(lazy_result_exports, {
  default: () => X4
});
var require22, D6, d17, q12, N9, k11, T8, u13, P8, j15, m19, p16, S12, I9, E7, f11, K3, _18, Q2, X4;
var init_lazy_result = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/lazy-result.js"() {
    init_container();
    init_map_generator();
    init_parse();
    init_result();
    init_root();
    init_stringify();
    init_symbols();
    init_warn_once();
    init_container();
    require22 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/container":
          return e2(container_exports);
        case "postcss/lib/map-generator":
          return e2(map_generator_exports);
        case "postcss/lib/parse":
          return e2(parse_exports);
        case "postcss/lib/result":
          return e2(result_exports);
        case "postcss/lib/root":
          return e2(root_exports);
        case "postcss/lib/stringify":
          return e2(stringify_exports);
        case "postcss/lib/symbols":
          return e2(symbols_exports);
        case "postcss/lib/warn-once":
          return e2(warn_once_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    D6 = Object.create;
    d17 = Object.defineProperty;
    q12 = Object.getOwnPropertyDescriptor;
    N9 = Object.getOwnPropertyNames;
    k11 = Object.getPrototypeOf;
    T8 = Object.prototype.hasOwnProperty;
    u13 = ((s12) => typeof require22 < "u" ? require22 : typeof Proxy < "u" ? new Proxy(s12, { get: (e2, t) => (typeof require22 < "u" ? require22 : e2)[t] }) : s12)(function(s12) {
      if (typeof require22 < "u") return require22.apply(this, arguments);
      throw Error('Dynamic require of "' + s12 + '" is not supported');
    });
    P8 = (s12, e2) => () => (e2 || s12((e2 = { exports: {} }).exports, e2), e2.exports);
    j15 = (s12, e2) => {
      for (var t in e2) d17(s12, t, { get: e2[t], enumerable: true });
    };
    m19 = (s12, e2, t, r9) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let i14 of N9(e2)) !T8.call(s12, i14) && i14 !== t && d17(s12, i14, { get: () => e2[i14], enumerable: !(r9 = q12(e2, i14)) || r9.enumerable });
      return s12;
    };
    p16 = (s12, e2, t) => (m19(s12, e2, "default"), t && m19(t, e2, "default"));
    S12 = (s12, e2, t) => (t = s12 != null ? D6(k11(s12)) : {}, m19(e2 || !s12 || !s12.__esModule ? d17(t, "default", { value: s12, enumerable: true }) : t, s12));
    I9 = P8((tt, C19) => {
      "use strict";
      var z11 = u13("postcss/lib/container"), R8, O11, c16 = class extends z11 {
        constructor(e2) {
          super({ type: "document", ...e2 }), this.nodes || (this.nodes = []);
        }
        toResult(e2 = {}) {
          return new R8(new O11(), this, e2).stringify();
        }
      };
      c16.registerLazyResult = (s12) => {
        R8 = s12;
      };
      c16.registerProcessor = (s12) => {
        O11 = s12;
      };
      C19.exports = c16;
      c16.default = c16;
    });
    E7 = P8((rt, A15) => {
      "use strict";
      var M6 = u13("postcss/lib/container"), U6 = I9(), $6 = u13("postcss/lib/map-generator"), G4 = u13("postcss/lib/parse"), b18 = u13("postcss/lib/result"), Y5 = u13("postcss/lib/root"), B10 = u13("postcss/lib/stringify"), { isClean: l10, my: H5 } = u13("postcss/lib/symbols"), et = u13("postcss/lib/warn-once"), W9 = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, Z3 = { AtRule: true, AtRuleExit: true, Comment: true, CommentExit: true, Declaration: true, DeclarationExit: true, Document: true, DocumentExit: true, Once: true, OnceExit: true, postcssPlugin: true, prepare: true, Root: true, RootExit: true, Rule: true, RuleExit: true }, J7 = { Once: true, postcssPlugin: true, prepare: true }, g16 = 0;
      function y20(s12) {
        return typeof s12 == "object" && typeof s12.then == "function";
      }
      function L8(s12) {
        let e2 = false, t = W9[s12.type];
        return s12.type === "decl" ? e2 = s12.prop.toLowerCase() : s12.type === "atrule" && (e2 = s12.name.toLowerCase()), e2 && s12.append ? [t, t + "-" + e2, g16, t + "Exit", t + "Exit-" + e2] : e2 ? [t, t + "-" + e2, t + "Exit", t + "Exit-" + e2] : s12.append ? [t, g16, t + "Exit"] : [t, t + "Exit"];
      }
      function V2(s12) {
        let e2;
        return s12.type === "document" ? e2 = ["Document", g16, "DocumentExit"] : s12.type === "root" ? e2 = ["Root", g16, "RootExit"] : e2 = L8(s12), { eventIndex: 0, events: e2, iterator: 0, node: s12, visitorIndex: 0, visitors: [] };
      }
      function w13(s12) {
        return s12[l10] = false, s12.nodes && s12.nodes.forEach((e2) => w13(e2)), s12;
      }
      var x22 = {}, h20 = class s12 {
        constructor(e2, t, r9) {
          this.stringified = false, this.processed = false;
          let i14;
          if (typeof t == "object" && t !== null && (t.type === "root" || t.type === "document")) i14 = w13(t);
          else if (t instanceof s12 || t instanceof b18) i14 = w13(t.root), t.map && (typeof r9.map > "u" && (r9.map = {}), r9.map.inline || (r9.map.inline = false), r9.map.prev = t.map);
          else {
            let n14 = G4;
            r9.syntax && (n14 = r9.syntax.parse), r9.parser && (n14 = r9.parser), n14.parse && (n14 = n14.parse);
            try {
              i14 = n14(t, r9);
            } catch (o10) {
              this.processed = true, this.error = o10;
            }
            i14 && !i14[H5] && M6.rebuild(i14);
          }
          this.result = new b18(e2, i14, r9), this.helpers = { ...x22, postcss: x22, result: this.result }, this.plugins = this.processor.plugins.map((n14) => typeof n14 == "object" && n14.prepare ? { ...n14, ...n14.prepare(this.result) } : n14);
        }
        async() {
          return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
        }
        catch(e2) {
          return this.async().catch(e2);
        }
        finally(e2) {
          return this.async().then(e2, e2);
        }
        getAsyncError() {
          throw new Error("Use process(css).then(cb) to work with async plugins");
        }
        handleError(e2, t) {
          let r9 = this.result.lastPlugin;
          try {
            t && t.addToError(e2), this.error = e2, e2.name === "CssSyntaxError" && !e2.plugin ? (e2.plugin = r9.postcssPlugin, e2.setMessage()) : r9.postcssVersion;
          } catch (i14) {
            console && console.error && console.error(i14);
          }
          return e2;
        }
        prepareVisitors() {
          this.listeners = {};
          let e2 = (t, r9, i14) => {
            this.listeners[r9] || (this.listeners[r9] = []), this.listeners[r9].push([t, i14]);
          };
          for (let t of this.plugins) if (typeof t == "object") for (let r9 in t) {
            if (!Z3[r9] && /^[A-Z]/.test(r9)) throw new Error(`Unknown event ${r9} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
            if (!J7[r9]) if (typeof t[r9] == "object") for (let i14 in t[r9]) i14 === "*" ? e2(t, r9, t[r9][i14]) : e2(t, r9 + "-" + i14.toLowerCase(), t[r9][i14]);
            else typeof t[r9] == "function" && e2(t, r9, t[r9]);
          }
          this.hasListener = Object.keys(this.listeners).length > 0;
        }
        async runAsync() {
          this.plugin = 0;
          for (let e2 = 0; e2 < this.plugins.length; e2++) {
            let t = this.plugins[e2], r9 = this.runOnRoot(t);
            if (y20(r9)) try {
              await r9;
            } catch (i14) {
              throw this.handleError(i14);
            }
          }
          if (this.prepareVisitors(), this.hasListener) {
            let e2 = this.result.root;
            for (; !e2[l10]; ) {
              e2[l10] = true;
              let t = [V2(e2)];
              for (; t.length > 0; ) {
                let r9 = this.visitTick(t);
                if (y20(r9)) try {
                  await r9;
                } catch (i14) {
                  let n14 = t[t.length - 1].node;
                  throw this.handleError(i14, n14);
                }
              }
            }
            if (this.listeners.OnceExit) for (let [t, r9] of this.listeners.OnceExit) {
              this.result.lastPlugin = t;
              try {
                if (e2.type === "document") {
                  let i14 = e2.nodes.map((n14) => r9(n14, this.helpers));
                  await Promise.all(i14);
                } else await r9(e2, this.helpers);
              } catch (i14) {
                throw this.handleError(i14);
              }
            }
          }
          return this.processed = true, this.stringify();
        }
        runOnRoot(e2) {
          this.result.lastPlugin = e2;
          try {
            if (typeof e2 == "object" && e2.Once) {
              if (this.result.root.type === "document") {
                let t = this.result.root.nodes.map((r9) => e2.Once(r9, this.helpers));
                return y20(t[0]) ? Promise.all(t) : t;
              }
              return e2.Once(this.result.root, this.helpers);
            } else if (typeof e2 == "function") return e2(this.result.root, this.result);
          } catch (t) {
            throw this.handleError(t);
          }
        }
        stringify() {
          if (this.error) throw this.error;
          if (this.stringified) return this.result;
          this.stringified = true, this.sync();
          let e2 = this.result.opts, t = B10;
          e2.syntax && (t = e2.syntax.stringify), e2.stringifier && (t = e2.stringifier), t.stringify && (t = t.stringify);
          let i14 = new $6(t, this.result.root, this.result.opts).generate();
          return this.result.css = i14[0], this.result.map = i14[1], this.result;
        }
        sync() {
          if (this.error) throw this.error;
          if (this.processed) return this.result;
          if (this.processed = true, this.processing) throw this.getAsyncError();
          for (let e2 of this.plugins) {
            let t = this.runOnRoot(e2);
            if (y20(t)) throw this.getAsyncError();
          }
          if (this.prepareVisitors(), this.hasListener) {
            let e2 = this.result.root;
            for (; !e2[l10]; ) e2[l10] = true, this.walkSync(e2);
            if (this.listeners.OnceExit) if (e2.type === "document") for (let t of e2.nodes) this.visitSync(this.listeners.OnceExit, t);
            else this.visitSync(this.listeners.OnceExit, e2);
          }
          return this.result;
        }
        then(e2, t) {
          return this.async().then(e2, t);
        }
        toString() {
          return this.css;
        }
        visitSync(e2, t) {
          for (let [r9, i14] of e2) {
            this.result.lastPlugin = r9;
            let n14;
            try {
              n14 = i14(t, this.helpers);
            } catch (o10) {
              throw this.handleError(o10, t.proxyOf);
            }
            if (t.type !== "root" && t.type !== "document" && !t.parent) return true;
            if (y20(n14)) throw this.getAsyncError();
          }
        }
        visitTick(e2) {
          let t = e2[e2.length - 1], { node: r9, visitors: i14 } = t;
          if (r9.type !== "root" && r9.type !== "document" && !r9.parent) {
            e2.pop();
            return;
          }
          if (i14.length > 0 && t.visitorIndex < i14.length) {
            let [o10, a20] = i14[t.visitorIndex];
            t.visitorIndex += 1, t.visitorIndex === i14.length && (t.visitors = [], t.visitorIndex = 0), this.result.lastPlugin = o10;
            try {
              return a20(r9.toProxy(), this.helpers);
            } catch (v15) {
              throw this.handleError(v15, r9);
            }
          }
          if (t.iterator !== 0) {
            let o10 = t.iterator, a20;
            for (; a20 = r9.nodes[r9.indexes[o10]]; ) if (r9.indexes[o10] += 1, !a20[l10]) {
              a20[l10] = true, e2.push(V2(a20));
              return;
            }
            t.iterator = 0, delete r9.indexes[o10];
          }
          let n14 = t.events;
          for (; t.eventIndex < n14.length; ) {
            let o10 = n14[t.eventIndex];
            if (t.eventIndex += 1, o10 === g16) {
              r9.nodes && r9.nodes.length && (r9[l10] = true, t.iterator = r9.getIterator());
              return;
            } else if (this.listeners[o10]) {
              t.visitors = this.listeners[o10];
              return;
            }
          }
          e2.pop();
        }
        walkSync(e2) {
          e2[l10] = true;
          let t = L8(e2);
          for (let r9 of t) if (r9 === g16) e2.nodes && e2.each((i14) => {
            i14[l10] || this.walkSync(i14);
          });
          else {
            let i14 = this.listeners[r9];
            if (i14 && this.visitSync(i14, e2.toProxy())) return;
          }
        }
        warnings() {
          return this.sync().warnings();
        }
        get content() {
          return this.stringify().content;
        }
        get css() {
          return this.stringify().css;
        }
        get map() {
          return this.stringify().map;
        }
        get messages() {
          return this.sync().messages;
        }
        get opts() {
          return this.result.opts;
        }
        get processor() {
          return this.result.processor;
        }
        get root() {
          return this.sync().root;
        }
        get [Symbol.toStringTag]() {
          return "LazyResult";
        }
      };
      h20.registerPostcss = (s12) => {
        x22 = s12;
      };
      A15.exports = h20;
      h20.default = h20;
      Y5.registerLazyResult(h20);
      U6.registerLazyResult(h20);
    });
    f11 = {};
    j15(f11, { default: () => X4 });
    K3 = S12(E7());
    p16(f11, S12(E7()));
    ({ default: _18, ...Q2 } = K3);
    X4 = _18 !== void 0 ? _18 : Q2;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/no-work-result.js
var no_work_result_exports = {};
__export(no_work_result_exports, {
  default: () => B9
});
var require23, y18, c13, q13, O9, P9, v12, u14, x19, C16, a17, n11, _19, p17, i12, N10, m20, A11, B9;
var init_no_work_result = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/no-work-result.js"() {
    init_map_generator();
    init_parse();
    init_result();
    init_stringify();
    init_warn_once();
    require23 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/map-generator":
          return e2(map_generator_exports);
        case "postcss/lib/parse":
          return e2(parse_exports);
        case "postcss/lib/result":
          return e2(result_exports);
        case "postcss/lib/stringify":
          return e2(stringify_exports);
        case "postcss/lib/warn-once":
          return e2(warn_once_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    y18 = Object.create;
    c13 = Object.defineProperty;
    q13 = Object.getOwnPropertyDescriptor;
    O9 = Object.getOwnPropertyNames;
    P9 = Object.getPrototypeOf;
    v12 = Object.prototype.hasOwnProperty;
    u14 = ((e2) => typeof require23 < "u" ? require23 : typeof Proxy < "u" ? new Proxy(e2, { get: (t, r9) => (typeof require23 < "u" ? require23 : t)[r9] }) : e2)(function(e2) {
      if (typeof require23 < "u") return require23.apply(this, arguments);
      throw Error('Dynamic require of "' + e2 + '" is not supported');
    });
    x19 = (e2, t) => () => (t || e2((t = { exports: {} }).exports, t), t.exports);
    C16 = (e2, t) => {
      for (var r9 in t) c13(e2, r9, { get: t[r9], enumerable: true });
    };
    a17 = (e2, t, r9, o10) => {
      if (t && typeof t == "object" || typeof t == "function") for (let s12 of O9(t)) !v12.call(e2, s12) && s12 !== r9 && c13(e2, s12, { get: () => t[s12], enumerable: !(o10 = q13(t, s12)) || o10.enumerable });
      return e2;
    };
    n11 = (e2, t, r9) => (a17(e2, t, "default"), r9 && a17(r9, t, "default"));
    _19 = (e2, t, r9) => (r9 = e2 != null ? y18(P9(e2)) : {}, a17(t || !e2 || !e2.__esModule ? c13(r9, "default", { value: e2, enumerable: true }) : r9, e2));
    p17 = x19((R8, d20) => {
      "use strict";
      var M6 = u14("postcss/lib/map-generator"), b18 = u14("postcss/lib/parse"), j16 = u14("postcss/lib/result"), E11 = u14("postcss/lib/stringify"), G4 = u14("postcss/lib/warn-once"), h20 = class {
        constructor(t, r9, o10) {
          r9 = r9.toString(), this.stringified = false, this._processor = t, this._css = r9, this._opts = o10, this._map = void 0;
          let s12, w13 = E11;
          this.result = new j16(this._processor, s12, this._opts), this.result.css = r9;
          let S16 = this;
          Object.defineProperty(this.result, "root", { get() {
            return S16.root;
          } });
          let l10 = new M6(w13, s12, this._opts, r9);
          if (l10.isMap()) {
            let [f15, g16] = l10.generate();
            f15 && (this.result.css = f15), g16 && (this.result.map = g16);
          } else l10.clearAnnotation(), this.result.css = l10.css;
        }
        async() {
          return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
        }
        catch(t) {
          return this.async().catch(t);
        }
        finally(t) {
          return this.async().then(t, t);
        }
        sync() {
          if (this.error) throw this.error;
          return this.result;
        }
        then(t, r9) {
          return this.async().then(t, r9);
        }
        toString() {
          return this._css;
        }
        warnings() {
          return [];
        }
        get content() {
          return this.result.css;
        }
        get css() {
          return this.result.css;
        }
        get map() {
          return this.result.map;
        }
        get messages() {
          return [];
        }
        get opts() {
          return this.result.opts;
        }
        get processor() {
          return this.result.processor;
        }
        get root() {
          if (this._root) return this._root;
          let t, r9 = b18;
          try {
            t = r9(this._css, this._opts);
          } catch (o10) {
            this.error = o10;
          }
          if (this.error) throw this.error;
          return this._root = t, t;
        }
        get [Symbol.toStringTag]() {
          return "NoWorkResult";
        }
      };
      d20.exports = h20;
      h20.default = h20;
    });
    i12 = {};
    C16(i12, { default: () => B9 });
    N10 = _19(p17());
    n11(i12, _19(p17()));
    ({ default: m20, ...A11 } = N10);
    B9 = m20 !== void 0 ? m20 : A11;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/processor.js
var processor_exports = {};
__export(processor_exports, {
  default: () => k12
});
var require24, P10, f12, _20, R6, S13, q14, a18, h19, b17, c14, u15, d18, z9, p18, n12, v13, x20, A12, k12;
var init_processor = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/processor.js"() {
    init_lazy_result();
    init_no_work_result();
    init_root();
    init_container();
    require24 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/lazy-result":
          return e2(lazy_result_exports);
        case "postcss/lib/no-work-result":
          return e2(no_work_result_exports);
        case "postcss/lib/root":
          return e2(root_exports);
        case "postcss/lib/container":
          return e2(container_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    P10 = Object.create;
    f12 = Object.defineProperty;
    _20 = Object.getOwnPropertyDescriptor;
    R6 = Object.getOwnPropertyNames;
    S13 = Object.getPrototypeOf;
    q14 = Object.prototype.hasOwnProperty;
    a18 = ((s12) => typeof require24 < "u" ? require24 : typeof Proxy < "u" ? new Proxy(s12, { get: (e2, t) => (typeof require24 < "u" ? require24 : e2)[t] }) : s12)(function(s12) {
      if (typeof require24 < "u") return require24.apply(this, arguments);
      throw Error('Dynamic require of "' + s12 + '" is not supported');
    });
    h19 = (s12, e2) => () => (e2 || s12((e2 = { exports: {} }).exports, e2), e2.exports);
    b17 = (s12, e2) => {
      for (var t in e2) f12(s12, t, { get: e2[t], enumerable: true });
    };
    c14 = (s12, e2, t, r9) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let l10 of R6(e2)) !q14.call(s12, l10) && l10 !== t && f12(s12, l10, { get: () => e2[l10], enumerable: !(r9 = _20(e2, l10)) || r9.enumerable });
      return s12;
    };
    u15 = (s12, e2, t) => (c14(s12, e2, "default"), t && c14(t, e2, "default"));
    d18 = (s12, e2, t) => (t = s12 != null ? P10(S13(s12)) : {}, c14(e2 || !s12 || !s12.__esModule ? f12(t, "default", { value: s12, enumerable: true }) : t, s12));
    z9 = h19((I12, m23) => {
      "use strict";
      var C19 = a18("postcss/lib/container"), g16, y20, i14 = class extends C19 {
        constructor(e2) {
          super({ type: "document", ...e2 }), this.nodes || (this.nodes = []);
        }
        toResult(e2 = {}) {
          return new g16(new y20(), this, e2).stringify();
        }
      };
      i14.registerLazyResult = (s12) => {
        g16 = s12;
      };
      i14.registerProcessor = (s12) => {
        y20 = s12;
      };
      m23.exports = i14;
      i14.default = i14;
    });
    p18 = h19((O11, w13) => {
      "use strict";
      var E11 = z9(), j16 = a18("postcss/lib/lazy-result"), L8 = a18("postcss/lib/no-work-result"), N12 = a18("postcss/lib/root"), o10 = class {
        constructor(e2 = []) {
          this.version = "8.4.47", this.plugins = this.normalize(e2);
        }
        normalize(e2) {
          let t = [];
          for (let r9 of e2) if (r9.postcss === true ? r9 = r9() : r9.postcss && (r9 = r9.postcss), typeof r9 == "object" && Array.isArray(r9.plugins)) t = t.concat(r9.plugins);
          else if (typeof r9 == "object" && r9.postcssPlugin) t.push(r9);
          else if (typeof r9 == "function") t.push(r9);
          else if (!(typeof r9 == "object" && (r9.parse || r9.stringify))) throw new Error(r9 + " is not a PostCSS plugin");
          return t;
        }
        process(e2, t = {}) {
          return !this.plugins.length && !t.parser && !t.stringifier && !t.syntax ? new L8(this, e2, t) : new j16(this, e2, t);
        }
        use(e2) {
          return this.plugins = this.plugins.concat(this.normalize([e2])), this;
        }
      };
      w13.exports = o10;
      o10.default = o10;
      N12.registerProcessor(o10);
      E11.registerProcessor(o10);
    });
    n12 = {};
    b17(n12, { default: () => k12 });
    v13 = d18(p18());
    u15(n12, d18(p18()));
    ({ default: x20, ...A12 } = v13);
    k12 = x20 !== void 0 ? x20 : A12;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/lib/postcss.js
import __Process$2 from "node:process";
var require25, z10, m21, L7, O10, W8, v14, s10, f13, E8, I10, q15, S14, r7, Y4, Z2, _21, $5, ee2, te3, re2, oe3, se2, ne2, ce2, ie2, le4, ue3, pe, ae2, xe2, me, fe, Re2, de2, ge2, qe3, we, ye;
var init_postcss = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/lib/postcss.js"() {
    init_at_rule();
    init_comment();
    init_container();
    init_css_syntax_error();
    init_declaration();
    init_fromJSON();
    init_input();
    init_lazy_result();
    init_list();
    init_node();
    init_parse();
    init_processor();
    init_result();
    init_root();
    init_rule();
    init_stringify();
    init_warning();
    init_container();
    require25 = (n14) => {
      const e2 = (m23) => typeof m23.default < "u" ? m23.default : m23, c16 = (m23) => Object.assign({ __esModule: true }, m23);
      switch (n14) {
        case "postcss/lib/at-rule":
          return e2(at_rule_exports);
        case "postcss/lib/comment":
          return e2(comment_exports);
        case "postcss/lib/container":
          return e2(container_exports);
        case "postcss/lib/css-syntax-error":
          return e2(css_syntax_error_exports);
        case "postcss/lib/declaration":
          return e2(declaration_exports);
        case "postcss/lib/fromJSON":
          return e2(fromJSON_exports);
        case "postcss/lib/input":
          return e2(input_exports);
        case "postcss/lib/lazy-result":
          return e2(lazy_result_exports);
        case "postcss/lib/list":
          return e2(list_exports);
        case "postcss/lib/node":
          return e2(node_exports);
        case "postcss/lib/parse":
          return e2(parse_exports);
        case "postcss/lib/processor":
          return e2(processor_exports);
        case "postcss/lib/result":
          return e2(result_exports);
        case "postcss/lib/root":
          return e2(root_exports);
        case "postcss/lib/rule":
          return e2(rule_exports);
        case "postcss/lib/stringify":
          return e2(stringify_exports);
        case "postcss/lib/warning":
          return e2(warning_exports);
        default:
          throw new Error('module "' + n14 + '" not found');
      }
    };
    z10 = Object.create;
    m21 = Object.defineProperty;
    L7 = Object.getOwnPropertyDescriptor;
    O10 = Object.getOwnPropertyNames;
    W8 = Object.getPrototypeOf;
    v14 = Object.prototype.hasOwnProperty;
    s10 = ((e2) => typeof require25 < "u" ? require25 : typeof Proxy < "u" ? new Proxy(e2, { get: (o10, c16) => (typeof require25 < "u" ? require25 : o10)[c16] }) : e2)(function(e2) {
      if (typeof require25 < "u") return require25.apply(this, arguments);
      throw Error('Dynamic require of "' + e2 + '" is not supported');
    });
    f13 = (e2, o10) => () => (o10 || e2((o10 = { exports: {} }).exports, o10), o10.exports);
    E8 = (e2, o10, c16, l10) => {
      if (o10 && typeof o10 == "object" || typeof o10 == "function") for (let n14 of O10(o10)) !v14.call(e2, n14) && n14 !== c16 && m21(e2, n14, { get: () => o10[n14], enumerable: !(l10 = L7(o10, n14)) || l10.enumerable });
      return e2;
    };
    I10 = (e2, o10, c16) => (c16 = e2 != null ? z10(W8(e2)) : {}, E8(o10 || !e2 || !e2.__esModule ? m21(c16, "default", { value: e2, enumerable: true }) : c16, e2));
    q15 = f13((U6, g16) => {
      "use strict";
      var J7 = s10("postcss/lib/container"), R8, d20, i14 = class extends J7 {
        constructor(o10) {
          super({ type: "document", ...o10 }), this.nodes || (this.nodes = []);
        }
        toResult(o10 = {}) {
          return new R8(new d20(), this, o10).stringify();
        }
      };
      i14.registerLazyResult = (e2) => {
        R8 = e2;
      };
      i14.registerProcessor = (e2) => {
        d20 = e2;
      };
      g16.exports = i14;
      i14.default = i14;
    });
    S14 = f13((X5, A15) => {
      "use strict";
      var w13 = s10("postcss/lib/at-rule"), y20 = s10("postcss/lib/comment"), G4 = s10("postcss/lib/container"), b18 = s10("postcss/lib/css-syntax-error"), C19 = s10("postcss/lib/declaration"), h20 = q15(), j16 = s10("postcss/lib/fromJSON"), M6 = s10("postcss/lib/input"), V2 = s10("postcss/lib/lazy-result"), k13 = s10("postcss/lib/list"), B10 = s10("postcss/lib/node"), F5 = s10("postcss/lib/parse"), x22 = s10("postcss/lib/processor"), H5 = s10("postcss/lib/result"), N12 = s10("postcss/lib/root"), P11 = s10("postcss/lib/rule"), K4 = s10("postcss/lib/stringify"), Q3 = s10("postcss/lib/warning");
      function t(...e2) {
        return e2.length === 1 && Array.isArray(e2[0]) && (e2 = e2[0]), new x22(e2);
      }
      t.plugin = function(o10, c16) {
        let l10 = false;
        function n14(...a20) {
          console && console.warn && !l10 && (l10 = true, console.warn(o10 + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`), __Process$2.env.LANG && __Process$2.env.LANG.startsWith("cn") && console.warn(o10 + `: 里面 postcss.plugin 被弃用. 迁移指南:
https://www.w3ctech.com/topic/2226`));
          let u17 = c16(...a20);
          return u17.postcssPlugin = o10, u17.postcssVersion = new x22().version, u17;
        }
        let p20;
        return Object.defineProperty(n14, "postcss", { get() {
          return p20 || (p20 = n14()), p20;
        } }), n14.process = function(a20, u17, D8) {
          return t([n14(D8)]).process(a20, u17);
        }, n14;
      };
      t.stringify = K4;
      t.parse = F5;
      t.fromJSON = j16;
      t.list = k13;
      t.comment = (e2) => new y20(e2);
      t.atRule = (e2) => new w13(e2);
      t.decl = (e2) => new C19(e2);
      t.rule = (e2) => new P11(e2);
      t.root = (e2) => new N12(e2);
      t.document = (e2) => new h20(e2);
      t.CssSyntaxError = b18;
      t.Declaration = C19;
      t.Container = G4;
      t.Processor = x22;
      t.Document = h20;
      t.Comment = y20;
      t.Warning = Q3;
      t.AtRule = w13;
      t.Result = H5;
      t.Input = M6;
      t.Rule = P11;
      t.Root = N12;
      t.Node = B10;
      V2.registerPostcss(t);
      A15.exports = t;
      t.default = t;
    });
    r7 = I10(S14(), 1);
    Y4 = r7.default;
    Z2 = r7.default.stringify;
    _21 = r7.default.fromJSON;
    $5 = r7.default.plugin;
    ee2 = r7.default.parse;
    te3 = r7.default.list;
    re2 = r7.default.document;
    oe3 = r7.default.comment;
    se2 = r7.default.atRule;
    ne2 = r7.default.rule;
    ce2 = r7.default.decl;
    ie2 = r7.default.root;
    le4 = r7.default.CssSyntaxError;
    ue3 = r7.default.Declaration;
    pe = r7.default.Container;
    ae2 = r7.default.Processor;
    xe2 = r7.default.Document;
    me = r7.default.Comment;
    fe = r7.default.Warning;
    Re2 = r7.default.AtRule;
    de2 = r7.default.Result;
    ge2 = r7.default.Input;
    qe3 = r7.default.Rule;
    we = r7.default.Root;
    ye = r7.default.Node;
  }
});

// https://esm.sh/v135/postcss@8.4.47/denonext/postcss.mjs
var e, r8, n13, s11, c15, p19, x21, l9, u16, m22, a19, i13, R7, d19, f14, g15, C17, y19, D7, N11, S15, A13, E9, I11, J6;
var init_postcss2 = __esm({
  "https://esm.sh/v135/postcss@8.4.47/denonext/postcss.mjs"() {
    init_postcss();
    e = Y4;
    r8 = Y4.stringify;
    n13 = Y4.fromJSON;
    s11 = Y4.plugin;
    c15 = Y4.parse;
    p19 = Y4.list;
    x21 = Y4.document;
    l9 = Y4.comment;
    u16 = Y4.atRule;
    m22 = Y4.rule;
    a19 = Y4.decl;
    i13 = Y4.root;
    R7 = Y4.CssSyntaxError;
    d19 = Y4.Declaration;
    f14 = Y4.Container;
    g15 = Y4.Processor;
    C17 = Y4.Document;
    y19 = Y4.Comment;
    D7 = Y4.Warning;
    N11 = Y4.AtRule;
    S15 = Y4.Result;
    A13 = Y4.Input;
    E9 = Y4.Rule;
    I11 = Y4.Root;
    J6 = Y4.Node;
  }
});

// https://esm.sh/postcss@8.4.47
var postcss_8_4_exports = {};
__export(postcss_8_4_exports, {
  AtRule: () => N11,
  Comment: () => y19,
  Container: () => f14,
  CssSyntaxError: () => R7,
  Declaration: () => d19,
  Document: () => C17,
  Input: () => A13,
  Node: () => J6,
  Processor: () => g15,
  Result: () => S15,
  Root: () => I11,
  Rule: () => E9,
  Warning: () => D7,
  atRule: () => u16,
  comment: () => l9,
  decl: () => a19,
  default: () => e,
  document: () => x21,
  fromJSON: () => n13,
  list: () => p19,
  parse: () => c15,
  plugin: () => s11,
  root: () => i13,
  rule: () => m22,
  stringify: () => r8
});
var init_postcss_8_4 = __esm({
  "https://esm.sh/postcss@8.4.47"() {
    init_postcss();
    init_postcss2();
    init_postcss2();
  }
});

// dist/node/chunks/dep-BASfdaBA.js
var dep_BASfdaBA_exports = {};
__export(dep_BASfdaBA_exports, {
  i: () => index$12
});
import require$$0__default2 from "node:fs";
import require$$0$1 from "node:path";
import require$$3 from "node:crypto";
import require$$0$2 from "node:util";
import { fileURLToPath as __cjs_fileURLToPath3 } from "node:url";
import { dirname as __cjs_dirname3 } from "node:path";
import { createRequire as __cjs_createRequire3 } from "node:module";
function _mergeNamespaces2(n14, m23) {
  for (var i14 = 0; i14 < m23.length; i14++) {
    var e2 = m23[i14];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (var k13 in e2) {
        if (k13 !== "default" && !(k13 in n14)) {
          n14[k13] = e2[k13];
        }
      }
    }
  }
  return n14;
}
function setFileSystem(fs5) {
  fileSystem.readFile = fs5.readFile;
  fileSystem.writeFile = fs5.writeFile;
}
function getFileSystem() {
  return fileSystem;
}
function unquote(str2) {
  if (!str2) {
    return "";
  }
  if (reg.test(str2.charAt(0))) {
    str2 = str2.substr(1);
  }
  if (reg.test(str2.charAt(str2.length - 1))) {
    str2 = str2.substr(0, str2.length - 1);
  }
  return str2;
}
function saveJSON(cssFile, json) {
  return new Promise((resolve5, reject) => {
    const {
      writeFile
    } = (0, _fs$2.getFileSystem)();
    writeFile(`${cssFile}.json`, JSON.stringify(json), (e2) => e2 ? reject(e2) : resolve5(json));
  });
}
function arrayReduce(array2, iteratee, accumulator, initAccum) {
  var index3 = -1, length = array2 ? array2.length : 0;
  while (++index3 < length) {
    accumulator = iteratee(accumulator, array2[index3], index3, array2);
  }
  return accumulator;
}
function asciiToArray(string4) {
  return string4.split("");
}
function asciiWords(string4) {
  return string4.match(reAsciiWord) || [];
}
function basePropertyOf(object2) {
  return function(key) {
    return object2 == null ? void 0 : object2[key];
  };
}
function hasUnicode(string4) {
  return reHasUnicode.test(string4);
}
function hasUnicodeWord(string4) {
  return reHasUnicodeWord.test(string4);
}
function stringToArray(string4) {
  return hasUnicode(string4) ? unicodeToArray(string4) : asciiToArray(string4);
}
function unicodeToArray(string4) {
  return string4.match(reUnicode) || [];
}
function unicodeWords(string4) {
  return string4.match(reUnicodeWord) || [];
}
function baseSlice(array2, start2, end) {
  var index3 = -1, length = array2.length;
  if (start2 < 0) {
    start2 = -start2 > length ? 0 : length + start2;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start2 > end ? 0 : end - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length);
  while (++index3 < length) {
    result[index3] = array2[index3 + start2];
  }
  return result;
}
function baseToString(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isSymbol(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
}
function castSlice(array2, start2, end) {
  var length = array2.length;
  end = end === void 0 ? length : end;
  return !start2 && end >= length ? array2 : baseSlice(array2, start2, end);
}
function createCaseFirst(methodName) {
  return function(string4) {
    string4 = toString(string4);
    var strSymbols = hasUnicode(string4) ? stringToArray(string4) : void 0;
    var chr = strSymbols ? strSymbols[0] : string4.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string4.slice(1);
    return chr[methodName]() + trailing;
  };
}
function createCompounder(callback) {
  return function(string4) {
    return arrayReduce(words(deburr(string4).replace(reApos, "")), callback, "");
  };
}
function isObjectLike(value2) {
  return !!value2 && typeof value2 == "object";
}
function isSymbol(value2) {
  return typeof value2 == "symbol" || isObjectLike(value2) && objectToString.call(value2) == symbolTag;
}
function toString(value2) {
  return value2 == null ? "" : baseToString(value2);
}
function capitalize(string4) {
  return upperFirst(toString(string4).toLowerCase());
}
function deburr(string4) {
  string4 = toString(string4);
  return string4 && string4.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
function words(string4, pattern2, guard) {
  string4 = toString(string4);
  pattern2 = pattern2;
  if (pattern2 === void 0) {
    return hasUnicodeWord(string4) ? unicodeWords(string4) : asciiWords(string4);
  }
  return string4.match(pattern2) || [];
}
function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function dashesCamelCase(string4) {
  return string4.replace(/-+(\w)/g, (_22, firstLetter) => firstLetter.toUpperCase());
}
function makeLocalsConventionReducer(localsConvention2, inputFile) {
  const isFunc = typeof localsConvention2 === "function";
  return (tokens, [className3, value2]) => {
    if (isFunc) {
      const convention = localsConvention2(className3, value2, inputFile);
      tokens[convention] = value2;
      return tokens;
    }
    switch (localsConvention2) {
      case "camelCase":
        tokens[className3] = value2;
        tokens[(0, _lodash.default)(className3)] = value2;
        break;
      case "camelCaseOnly":
        tokens[(0, _lodash.default)(className3)] = value2;
        break;
      case "dashes":
        tokens[className3] = value2;
        tokens[dashesCamelCase(className3)] = value2;
        break;
      case "dashesOnly":
        tokens[dashesCamelCase(className3)] = value2;
        break;
    }
    return tokens;
  };
}
function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function createError(node3, graph) {
  const er = new Error("Nondeterministic import's order");
  const related = graph[node3];
  const relatedNode = related.find(
    (relatedNode2) => graph[relatedNode2].indexOf(node3) > -1
  );
  er.nodes = [node3, relatedNode];
  return er;
}
function walkGraph(node3, graph, state, result, strict) {
  if (state[node3] === PERMANENT_MARKER) {
    return;
  }
  if (state[node3] === TEMPORARY_MARKER) {
    if (strict) {
      return createError(node3, graph);
    }
    return;
  }
  state[node3] = TEMPORARY_MARKER;
  const children = graph[node3];
  const length = children.length;
  for (let i14 = 0; i14 < length; ++i14) {
    const error2 = walkGraph(children[i14], graph, state, result, strict);
    if (error2 instanceof Error) {
      return error2;
    }
  }
  state[node3] = PERMANENT_MARKER;
  result.push(node3);
}
function topologicalSort$1(graph, strict) {
  const result = [];
  const state = {};
  const nodes = Object.keys(graph);
  const length = nodes.length;
  for (let i14 = 0; i14 < length; ++i14) {
    const er = walkGraph(nodes[i14], graph, state, result, strict);
    if (er instanceof Error) {
      return er;
    }
  }
  return result;
}
function addImportToGraph(importId, parentId, graph, visited) {
  const siblingsId = parentId + "_siblings";
  const visitedId = parentId + "_" + importId;
  if (visited[visitedId] !== VISITED_MARKER) {
    if (!Array.isArray(visited[siblingsId])) {
      visited[siblingsId] = [];
    }
    const siblings = visited[siblingsId];
    if (Array.isArray(graph[importId])) {
      graph[importId] = graph[importId].concat(siblings);
    } else {
      graph[importId] = siblings.slice();
    }
    visited[visitedId] = VISITED_MARKER;
    siblings.push(importId);
  }
}
function requireWasmHash() {
  if (hasRequiredWasmHash) return wasmHash.exports;
  hasRequiredWasmHash = 1;
  const MAX_SHORT_STRING = Math.floor((65536 - 64) / 4) & ~3;
  class WasmHash {
    /**
     * @param {WebAssembly.Instance} instance wasm instance
     * @param {WebAssembly.Instance[]} instancesPool pool of instances
     * @param {number} chunkSize size of data chunks passed to wasm
     * @param {number} digestSize size of digest returned by wasm
     */
    constructor(instance, instancesPool, chunkSize, digestSize) {
      const exports4 = (
        /** @type {any} */
        instance.exports
      );
      exports4.init();
      this.exports = exports4;
      this.mem = Buffer.from(exports4.memory.buffer, 0, 65536);
      this.buffered = 0;
      this.instancesPool = instancesPool;
      this.chunkSize = chunkSize;
      this.digestSize = digestSize;
    }
    reset() {
      this.buffered = 0;
      this.exports.init();
    }
    /**
     * @param {Buffer | string} data data
     * @param {BufferEncoding=} encoding encoding
     * @returns {this} itself
     */
    update(data, encoding) {
      if (typeof data === "string") {
        while (data.length > MAX_SHORT_STRING) {
          this._updateWithShortString(data.slice(0, MAX_SHORT_STRING), encoding);
          data = data.slice(MAX_SHORT_STRING);
        }
        this._updateWithShortString(data, encoding);
        return this;
      }
      this._updateWithBuffer(data);
      return this;
    }
    /**
     * @param {string} data data
     * @param {BufferEncoding=} encoding encoding
     * @returns {void}
     */
    _updateWithShortString(data, encoding) {
      const { exports: exports4, buffered, mem, chunkSize } = this;
      let endPos;
      if (data.length < 70) {
        if (!encoding || encoding === "utf-8" || encoding === "utf8") {
          endPos = buffered;
          for (let i14 = 0; i14 < data.length; i14++) {
            const cc = data.charCodeAt(i14);
            if (cc < 128) {
              mem[endPos++] = cc;
            } else if (cc < 2048) {
              mem[endPos] = cc >> 6 | 192;
              mem[endPos + 1] = cc & 63 | 128;
              endPos += 2;
            } else {
              endPos += mem.write(data.slice(i14), endPos, encoding);
              break;
            }
          }
        } else if (encoding === "latin1") {
          endPos = buffered;
          for (let i14 = 0; i14 < data.length; i14++) {
            const cc = data.charCodeAt(i14);
            mem[endPos++] = cc;
          }
        } else {
          endPos = buffered + mem.write(data, buffered, encoding);
        }
      } else {
        endPos = buffered + mem.write(data, buffered, encoding);
      }
      if (endPos < chunkSize) {
        this.buffered = endPos;
      } else {
        const l10 = endPos & ~(this.chunkSize - 1);
        exports4.update(l10);
        const newBuffered = endPos - l10;
        this.buffered = newBuffered;
        if (newBuffered > 0) {
          mem.copyWithin(0, l10, endPos);
        }
      }
    }
    /**
     * @param {Buffer} data data
     * @returns {void}
     */
    _updateWithBuffer(data) {
      const { exports: exports4, buffered, mem } = this;
      const length = data.length;
      if (buffered + length < this.chunkSize) {
        data.copy(mem, buffered, 0, length);
        this.buffered += length;
      } else {
        const l10 = buffered + length & ~(this.chunkSize - 1);
        if (l10 > 65536) {
          let i14 = 65536 - buffered;
          data.copy(mem, buffered, 0, i14);
          exports4.update(65536);
          const stop = l10 - buffered - 65536;
          while (i14 < stop) {
            data.copy(mem, 0, i14, i14 + 65536);
            exports4.update(65536);
            i14 += 65536;
          }
          data.copy(mem, 0, i14, l10 - buffered);
          exports4.update(l10 - buffered - i14);
        } else {
          data.copy(mem, buffered, 0, l10 - buffered);
          exports4.update(l10);
        }
        const newBuffered = length + buffered - l10;
        this.buffered = newBuffered;
        if (newBuffered > 0) {
          data.copy(mem, 0, length - newBuffered, length);
        }
      }
    }
    digest(type) {
      const { exports: exports4, buffered, mem, digestSize } = this;
      exports4.final(buffered);
      this.instancesPool.push(this);
      const hex = mem.toString("latin1", 0, digestSize);
      if (type === "hex") {
        return hex;
      }
      if (type === "binary" || !type) {
        return Buffer.from(hex, "hex");
      }
      return Buffer.from(hex, "hex").toString(type);
    }
  }
  const create = (wasmModule2, instancesPool, chunkSize, digestSize) => {
    if (instancesPool.length > 0) {
      const old = instancesPool.pop();
      old.reset();
      return old;
    } else {
      return new WasmHash(
        new WebAssembly.Instance(wasmModule2),
        instancesPool,
        chunkSize,
        digestSize
      );
    }
  };
  wasmHash.exports = create;
  wasmHash.exports.MAX_SHORT_STRING = MAX_SHORT_STRING;
  return wasmHash.exports;
}
function requireXxhash64() {
  if (hasRequiredXxhash64) return xxhash64_1;
  hasRequiredXxhash64 = 1;
  const create = requireWasmHash();
  const xxhash64 = new WebAssembly.Module(
    Buffer.from(
      // 1173 bytes
      "AGFzbQEAAAABCAJgAX8AYAAAAwQDAQAABQMBAAEGGgV+AUIAC34BQgALfgFCAAt+AUIAC34BQgALByIEBGluaXQAAAZ1cGRhdGUAAQVmaW5hbAACBm1lbW9yeQIACrUIAzAAQtbrgu7q/Yn14AAkAELP1tO+0ser2UIkAUIAJAJC+erQ0OfJoeThACQDQgAkBAvUAQIBfwR+IABFBEAPCyMEIACtfCQEIwAhAiMBIQMjAiEEIwMhBQNAIAIgASkDAELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiECIAMgASkDCELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEDIAQgASkDEELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEEIAUgASkDGELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEFIAAgAUEgaiIBSw0ACyACJAAgAyQBIAQkAiAFJAMLqwYCAX8EfiMEQgBSBH4jACICQgGJIwEiA0IHiXwjAiIEQgyJfCMDIgVCEol8IAJCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0gA0LP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+hUKHla+vmLbem55/fkKdo7Xqg7GNivoAfSAEQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IAVCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0FQsXP2bLx5brqJwsjBCAArXx8IQIDQCABQQhqIABNBEAgAiABKQMAQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQhuJQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IQIgAUEIaiEBDAELCyABQQRqIABNBEACfyACIAE1AgBCh5Wvr5i23puef36FQheJQs/W077Sx6vZQn5C+fPd8Zn2masWfCECIAFBBGoLIQELA0AgACABRwRAIAIgATEAAELFz9my8eW66id+hUILiUKHla+vmLbem55/fiECIAFBAWohAQwBCwtBACACIAJCIYiFQs/W077Sx6vZQn4iAiACQh2IhUL5893xmfaZqxZ+IgIgAkIgiIUiAkIgiCIDQv//A4NCIIYgA0KAgPz/D4NCEIiEIgNC/4GAgPAfg0IQhiADQoD+g4CA4D+DQgiIhCIDQo+AvIDwgcAHg0IIhiADQvCBwIeAnoD4AINCBIiEIgNChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IANCsODAgYOGjJgwhHw3AwBBCCACQv////8PgyICQv//A4NCIIYgAkKAgPz/D4NCEIiEIgJC/4GAgPAfg0IQhiACQoD+g4CA4D+DQgiIhCICQo+AvIDwgcAHg0IIhiACQvCBwIeAnoD4AINCBIiEIgJChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IAJCsODAgYOGjJgwhHw3AwAL",
      "base64"
    )
  );
  xxhash64_1 = create.bind(null, xxhash64, [], 32, 16);
  return xxhash64_1;
}
function requireBatchedHash() {
  if (hasRequiredBatchedHash) return BatchedHash_1;
  hasRequiredBatchedHash = 1;
  const MAX_SHORT_STRING = requireWasmHash().MAX_SHORT_STRING;
  class BatchedHash2 {
    constructor(hash3) {
      this.string = void 0;
      this.encoding = void 0;
      this.hash = hash3;
    }
    /**
     * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
     * @param {string|Buffer} data data
     * @param {string=} inputEncoding data encoding
     * @returns {this} updated hash
     */
    update(data, inputEncoding) {
      if (this.string !== void 0) {
        if (typeof data === "string" && inputEncoding === this.encoding && this.string.length + data.length < MAX_SHORT_STRING) {
          this.string += data;
          return this;
        }
        this.hash.update(this.string, this.encoding);
        this.string = void 0;
      }
      if (typeof data === "string") {
        if (data.length < MAX_SHORT_STRING && // base64 encoding is not valid since it may contain padding chars
        (!inputEncoding || !inputEncoding.startsWith("ba"))) {
          this.string = data;
          this.encoding = inputEncoding;
        } else {
          this.hash.update(data, inputEncoding);
        }
      } else {
        this.hash.update(data);
      }
      return this;
    }
    /**
     * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
     * @param {string=} encoding encoding of the return value
     * @returns {string|Buffer} digest
     */
    digest(encoding) {
      if (this.string !== void 0) {
        this.hash.update(this.string, this.encoding);
      }
      return this.hash.digest(encoding);
    }
  }
  BatchedHash_1 = BatchedHash2;
  return BatchedHash_1;
}
function requireMd4() {
  if (hasRequiredMd4) return md4_1;
  hasRequiredMd4 = 1;
  const create = requireWasmHash();
  const md4 = new WebAssembly.Module(
    Buffer.from(
      // 2150 bytes
      "AGFzbQEAAAABCAJgAX8AYAAAAwUEAQAAAAUDAQABBhoFfwFBAAt/AUEAC38BQQALfwFBAAt/AUEACwciBARpbml0AAAGdXBkYXRlAAIFZmluYWwAAwZtZW1vcnkCAAqFEAQmAEGBxpS6BiQBQYnXtv5+JAJB/rnrxXkkA0H2qMmBASQEQQAkAAvMCgEYfyMBIQojAiEGIwMhByMEIQgDQCAAIAVLBEAgBSgCCCINIAcgBiAFKAIEIgsgCCAHIAUoAgAiDCAKIAggBiAHIAhzcXNqakEDdyIDIAYgB3Nxc2pqQQd3IgEgAyAGc3FzampBC3chAiAFKAIUIg8gASACIAUoAhAiCSADIAEgBSgCDCIOIAYgAyACIAEgA3Nxc2pqQRN3IgQgASACc3FzampBA3ciAyACIARzcXNqakEHdyEBIAUoAiAiEiADIAEgBSgCHCIRIAQgAyAFKAIYIhAgAiAEIAEgAyAEc3FzampBC3ciAiABIANzcXNqakETdyIEIAEgAnNxc2pqQQN3IQMgBSgCLCIVIAQgAyAFKAIoIhQgAiAEIAUoAiQiEyABIAIgAyACIARzcXNqakEHdyIBIAMgBHNxc2pqQQt3IgIgASADc3FzampBE3chBCAPIBAgCSAVIBQgEyAFKAI4IhYgAiAEIAUoAjQiFyABIAIgBSgCMCIYIAMgASAEIAEgAnNxc2pqQQN3IgEgAiAEc3FzampBB3ciAiABIARzcXNqakELdyIDIAkgAiAMIAEgBSgCPCIJIAQgASADIAEgAnNxc2pqQRN3IgEgAiADcnEgAiADcXJqakGZ84nUBWpBA3ciAiABIANycSABIANxcmpqQZnzidQFakEFdyIEIAEgAnJxIAEgAnFyaiASakGZ84nUBWpBCXciAyAPIAQgCyACIBggASADIAIgBHJxIAIgBHFyampBmfOJ1AVqQQ13IgEgAyAEcnEgAyAEcXJqakGZ84nUBWpBA3ciAiABIANycSABIANxcmpqQZnzidQFakEFdyIEIAEgAnJxIAEgAnFyampBmfOJ1AVqQQl3IgMgECAEIAIgFyABIAMgAiAEcnEgAiAEcXJqakGZ84nUBWpBDXciASADIARycSADIARxcmogDWpBmfOJ1AVqQQN3IgIgASADcnEgASADcXJqakGZ84nUBWpBBXciBCABIAJycSABIAJxcmpqQZnzidQFakEJdyIDIBEgBCAOIAIgFiABIAMgAiAEcnEgAiAEcXJqakGZ84nUBWpBDXciASADIARycSADIARxcmpqQZnzidQFakEDdyICIAEgA3JxIAEgA3FyampBmfOJ1AVqQQV3IgQgASACcnEgASACcXJqakGZ84nUBWpBCXciAyAMIAIgAyAJIAEgAyACIARycSACIARxcmpqQZnzidQFakENdyIBcyAEc2pqQaHX5/YGakEDdyICIAQgASACcyADc2ogEmpBodfn9gZqQQl3IgRzIAFzampBodfn9gZqQQt3IgMgAiADIBggASADIARzIAJzampBodfn9gZqQQ93IgFzIARzaiANakGh1+f2BmpBA3ciAiAUIAQgASACcyADc2pqQaHX5/YGakEJdyIEcyABc2pqQaHX5/YGakELdyIDIAsgAiADIBYgASADIARzIAJzampBodfn9gZqQQ93IgFzIARzampBodfn9gZqQQN3IgIgEyAEIAEgAnMgA3NqakGh1+f2BmpBCXciBHMgAXNqakGh1+f2BmpBC3chAyAKIA4gAiADIBcgASADIARzIAJzampBodfn9gZqQQ93IgFzIARzampBodfn9gZqQQN3IgJqIQogBiAJIAEgESADIAIgFSAEIAEgAnMgA3NqakGh1+f2BmpBCXciBHMgAXNqakGh1+f2BmpBC3ciAyAEcyACc2pqQaHX5/YGakEPd2ohBiADIAdqIQcgBCAIaiEIIAVBQGshBQwBCwsgCiQBIAYkAiAHJAMgCCQECw0AIAAQASMAIABqJAAL/wQCA38BfiMAIABqrUIDhiEEIABByABqQUBxIgJBCGshAyAAIgFBAWohACABQYABOgAAA0AgACACSUEAIABBB3EbBEAgAEEAOgAAIABBAWohAAwBCwsDQCAAIAJJBEAgAEIANwMAIABBCGohAAwBCwsgAyAENwMAIAIQAUEAIwGtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEIIwKtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEQIwOtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEYIwStIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAAs=",
      "base64"
    )
  );
  md4_1 = create.bind(null, md4, [], 64, 32);
  return md4_1;
}
function requireBulkUpdateDecorator() {
  if (hasRequiredBulkUpdateDecorator) return BulkUpdateDecorator_1;
  hasRequiredBulkUpdateDecorator = 1;
  const BULK_SIZE = 2e3;
  const digestCaches = {};
  class BulkUpdateDecorator2 {
    /**
     * @param {Hash | function(): Hash} hashOrFactory function to create a hash
     * @param {string=} hashKey key for caching
     */
    constructor(hashOrFactory, hashKey) {
      this.hashKey = hashKey;
      if (typeof hashOrFactory === "function") {
        this.hashFactory = hashOrFactory;
        this.hash = void 0;
      } else {
        this.hashFactory = void 0;
        this.hash = hashOrFactory;
      }
      this.buffer = "";
    }
    /**
     * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
     * @param {string|Buffer} data data
     * @param {string=} inputEncoding data encoding
     * @returns {this} updated hash
     */
    update(data, inputEncoding) {
      if (inputEncoding !== void 0 || typeof data !== "string" || data.length > BULK_SIZE) {
        if (this.hash === void 0) {
          this.hash = this.hashFactory();
        }
        if (this.buffer.length > 0) {
          this.hash.update(this.buffer);
          this.buffer = "";
        }
        this.hash.update(data, inputEncoding);
      } else {
        this.buffer += data;
        if (this.buffer.length > BULK_SIZE) {
          if (this.hash === void 0) {
            this.hash = this.hashFactory();
          }
          this.hash.update(this.buffer);
          this.buffer = "";
        }
      }
      return this;
    }
    /**
     * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
     * @param {string=} encoding encoding of the return value
     * @returns {string|Buffer} digest
     */
    digest(encoding) {
      let digestCache;
      const buffer = this.buffer;
      if (this.hash === void 0) {
        const cacheKey = `${this.hashKey}-${encoding}`;
        digestCache = digestCaches[cacheKey];
        if (digestCache === void 0) {
          digestCache = digestCaches[cacheKey] = /* @__PURE__ */ new Map();
        }
        const cacheEntry = digestCache.get(buffer);
        if (cacheEntry !== void 0) {
          return cacheEntry;
        }
        this.hash = this.hashFactory();
      }
      if (buffer.length > 0) {
        this.hash.update(buffer);
      }
      const digestResult = this.hash.digest(encoding);
      if (digestCache !== void 0) {
        digestCache.set(buffer, digestResult);
      }
      return digestResult;
    }
  }
  BulkUpdateDecorator_1 = BulkUpdateDecorator2;
  return BulkUpdateDecorator_1;
}
function divmod32(uint32Array, divisor) {
  let carry = 0;
  for (let i14 = uint32Array.length - 1; i14 >= 0; i14--) {
    const value2 = carry * 4294967296 + uint32Array[i14];
    carry = value2 % divisor;
    uint32Array[i14] = Math.floor(value2 / divisor);
  }
  return carry;
}
function encodeBufferToBase(buffer, base, length) {
  const encodeTable = baseEncodeTables[base];
  if (!encodeTable) {
    throw new Error("Unknown encoding base" + base);
  }
  const limit = Math.ceil(buffer.length * 8 / Math.log2(base));
  length = Math.min(length, limit);
  const uint32Array = new Uint32Array(Math.ceil(buffer.length / 4));
  buffer.copy(Buffer.from(uint32Array.buffer));
  let output = "";
  for (let i14 = 0; i14 < length; i14++) {
    output = encodeTable[divmod32(uint32Array, base)] + output;
  }
  return output;
}
function getHashDigest$1(buffer, algorithm, digestType, maxLength) {
  algorithm = algorithm || "xxhash64";
  maxLength = maxLength || 9999;
  let hash3;
  if (algorithm === "xxhash64") {
    if (createXXHash64 === void 0) {
      createXXHash64 = requireXxhash64();
      if (BatchedHash === void 0) {
        BatchedHash = requireBatchedHash();
      }
    }
    hash3 = new BatchedHash(createXXHash64());
  } else if (algorithm === "md4") {
    if (createMd4 === void 0) {
      createMd4 = requireMd4();
      if (BatchedHash === void 0) {
        BatchedHash = requireBatchedHash();
      }
    }
    hash3 = new BatchedHash(createMd4());
  } else if (algorithm === "native-md4") {
    if (typeof crypto === "undefined") {
      crypto = require$$3;
      if (BulkUpdateDecorator === void 0) {
        BulkUpdateDecorator = requireBulkUpdateDecorator();
      }
    }
    hash3 = new BulkUpdateDecorator(() => crypto.createHash("md4"), "md4");
  } else {
    if (typeof crypto === "undefined") {
      crypto = require$$3;
      if (BulkUpdateDecorator === void 0) {
        BulkUpdateDecorator = requireBulkUpdateDecorator();
      }
    }
    hash3 = new BulkUpdateDecorator(
      () => crypto.createHash(algorithm),
      algorithm
    );
  }
  hash3.update(buffer);
  if (digestType === "base26" || digestType === "base32" || digestType === "base36" || digestType === "base49" || digestType === "base52" || digestType === "base58" || digestType === "base62") {
    return encodeBufferToBase(hash3.digest(), digestType.substr(4), maxLength);
  } else {
    return hash3.digest(digestType || "hex").substr(0, maxLength);
  }
}
function interpolateName$1(loaderContext, name2, options2 = {}) {
  let filename;
  const hasQuery = loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;
  if (typeof name2 === "function") {
    filename = name2(
      loaderContext.resourcePath,
      hasQuery ? loaderContext.resourceQuery : void 0
    );
  } else {
    filename = name2 || "[hash].[ext]";
  }
  const context = options2.context;
  const content = options2.content;
  const regExp = options2.regExp;
  let ext2 = "bin";
  let basename3 = "file";
  let directory = "";
  let folder = "";
  let query = "";
  if (loaderContext.resourcePath) {
    const parsed = path$12.parse(loaderContext.resourcePath);
    let resourcePath = loaderContext.resourcePath;
    if (parsed.ext) {
      ext2 = parsed.ext.substr(1);
    }
    if (parsed.dir) {
      basename3 = parsed.name;
      resourcePath = parsed.dir + path$12.sep;
    }
    if (typeof context !== "undefined") {
      directory = path$12.relative(context, resourcePath + "_").replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
      directory = directory.substr(0, directory.length - 1);
    } else {
      directory = resourcePath.replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
    }
    if (directory.length === 1) {
      directory = "";
    } else if (directory.length > 1) {
      folder = path$12.basename(directory);
    }
  }
  if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {
    query = loaderContext.resourceQuery;
    const hashIdx = query.indexOf("#");
    if (hashIdx >= 0) {
      query = query.substr(0, hashIdx);
    }
  }
  let url2 = filename;
  if (content) {
    url2 = url2.replace(
      /\[(?:([^[:\]]+):)?(?:hash|contenthash)(?::([a-z]+\d*))?(?::(\d+))?\]/gi,
      (all, hashType, digestType, maxLength) => getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))
    );
  }
  url2 = url2.replace(/\[ext\]/gi, () => ext2).replace(/\[name\]/gi, () => basename3).replace(/\[path\]/gi, () => directory).replace(/\[folder\]/gi, () => folder).replace(/\[query\]/gi, () => query);
  if (regExp && loaderContext.resourcePath) {
    const match2 = loaderContext.resourcePath.match(new RegExp(regExp));
    match2 && match2.forEach((matched, i14) => {
      url2 = url2.replace(new RegExp("\\[" + i14 + "\\]", "ig"), matched);
    });
  }
  if (typeof loaderContext.options === "object" && typeof loaderContext.options.customInterpolateName === "function") {
    url2 = loaderContext.options.customInterpolateName.call(
      loaderContext,
      url2,
      name2,
      options2
    );
  }
  return url2;
}
function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
function isNode(node3) {
  return typeof node3 === "object" && IS_TYPE[node3.type];
}
function isNodeType(type, node3) {
  return isNode(node3) && node3.type === type;
}
function isPseudoElement(node3) {
  return isPseudo(node3) && node3.value && (node3.value.startsWith("::") || node3.value.toLowerCase() === ":before" || node3.value.toLowerCase() === ":after" || node3.value.toLowerCase() === ":first-letter" || node3.value.toLowerCase() === ":first-line");
}
function isPseudoClass(node3) {
  return isPseudo(node3) && !isPseudoElement(node3);
}
function isContainer(node3) {
  return !!(isNode(node3) && node3.walk);
}
function isNamespace(node3) {
  return isAttribute(node3) || isTag(node3);
}
function normalizeNodeArray(nodes) {
  const array2 = [];
  nodes.forEach((x22) => {
    if (Array.isArray(x22)) {
      normalizeNodeArray(x22).forEach((item) => {
        array2.push(item);
      });
    } else if (x22) {
      array2.push(x22);
    }
  });
  if (array2.length > 0 && isSpacing(array2[array2.length - 1])) {
    array2.pop();
  }
  return array2;
}
function localizeNode(rule, mode2, localAliasMap) {
  const transform2 = (node3, context) => {
    if (context.ignoreNextSpacing && !isSpacing(node3)) {
      throw new Error("Missing whitespace after " + context.ignoreNextSpacing);
    }
    if (context.enforceNoSpacing && isSpacing(node3)) {
      throw new Error("Missing whitespace before " + context.enforceNoSpacing);
    }
    let newNodes;
    switch (node3.type) {
      case "root": {
        let resultingGlobal;
        context.hasPureGlobals = false;
        newNodes = node3.nodes.map((n14) => {
          const nContext = {
            global: context.global,
            lastWasSpacing: true,
            hasLocals: false,
            explicit: false
          };
          n14 = transform2(n14, nContext);
          if (typeof resultingGlobal === "undefined") {
            resultingGlobal = nContext.global;
          } else if (resultingGlobal !== nContext.global) {
            throw new Error(
              'Inconsistent rule global/local result in rule "' + node3 + '" (multiple selectors must result in the same mode for the rule)'
            );
          }
          if (!nContext.hasLocals) {
            context.hasPureGlobals = true;
          }
          return n14;
        });
        context.global = resultingGlobal;
        node3.nodes = normalizeNodeArray(newNodes);
        break;
      }
      case "selector": {
        newNodes = node3.map((childNode) => transform2(childNode, context));
        node3 = node3.clone();
        node3.nodes = normalizeNodeArray(newNodes);
        break;
      }
      case "combinator": {
        if (isSpacing(node3)) {
          if (context.ignoreNextSpacing) {
            context.ignoreNextSpacing = false;
            context.lastWasSpacing = false;
            context.enforceNoSpacing = false;
            return null;
          }
          context.lastWasSpacing = true;
          return node3;
        }
        break;
      }
      case "pseudo": {
        let childContext;
        const isNested = !!node3.length;
        const isScoped = node3.value === ":local" || node3.value === ":global";
        const isImportExport = node3.value === ":import" || node3.value === ":export";
        if (isImportExport) {
          context.hasLocals = true;
        } else if (isNested) {
          if (isScoped) {
            if (node3.nodes.length === 0) {
              throw new Error(`${node3.value}() can't be empty`);
            }
            if (context.inside) {
              throw new Error(
                `A ${node3.value} is not allowed inside of a ${context.inside}(...)`
              );
            }
            childContext = {
              global: node3.value === ":global",
              inside: node3.value,
              hasLocals: false,
              explicit: true
            };
            newNodes = node3.map((childNode) => transform2(childNode, childContext)).reduce((acc, next) => acc.concat(next.nodes), []);
            if (newNodes.length) {
              const { before, after } = node3.spaces;
              const first2 = newNodes[0];
              const last = newNodes[newNodes.length - 1];
              first2.spaces = { before, after: first2.spaces.after };
              last.spaces = { before: last.spaces.before, after };
            }
            node3 = newNodes;
            break;
          } else {
            childContext = {
              global: context.global,
              inside: context.inside,
              lastWasSpacing: true,
              hasLocals: false,
              explicit: context.explicit
            };
            newNodes = node3.map(
              (childNode) => transform2(childNode, childContext)
            );
            node3 = node3.clone();
            node3.nodes = normalizeNodeArray(newNodes);
            if (childContext.hasLocals) {
              context.hasLocals = true;
            }
          }
          break;
        } else if (isScoped) {
          if (context.inside) {
            throw new Error(
              `A ${node3.value} is not allowed inside of a ${context.inside}(...)`
            );
          }
          const addBackSpacing = !!node3.spaces.before;
          context.ignoreNextSpacing = context.lastWasSpacing ? node3.value : false;
          context.enforceNoSpacing = context.lastWasSpacing ? false : node3.value;
          context.global = node3.value === ":global";
          context.explicit = true;
          return addBackSpacing ? selectorParser$1.combinator({ value: " " }) : null;
        }
        break;
      }
      case "id":
      case "class": {
        if (!node3.value) {
          throw new Error("Invalid class or id selector syntax");
        }
        if (context.global) {
          break;
        }
        const isImportedValue = localAliasMap.has(node3.value);
        const isImportedWithExplicitScope = isImportedValue && context.explicit;
        if (!isImportedValue || isImportedWithExplicitScope) {
          const innerNode = node3.clone();
          innerNode.spaces = { before: "", after: "" };
          node3 = selectorParser$1.pseudo({
            value: ":local",
            nodes: [innerNode],
            spaces: node3.spaces
          });
          context.hasLocals = true;
        }
        break;
      }
    }
    context.lastWasSpacing = false;
    context.ignoreNextSpacing = false;
    context.enforceNoSpacing = false;
    return node3;
  };
  const rootContext = {
    global: mode2 === "global",
    hasPureGlobals: false
  };
  rootContext.selector = selectorParser$1((root3) => {
    transform2(root3, rootContext);
  }).processSync(rule, { updateSelector: false, lossless: true });
  return rootContext;
}
function localizeDeclNode(node3, context) {
  switch (node3.type) {
    case "word":
      if (context.localizeNextItem) {
        if (!context.localAliasMap.has(node3.value)) {
          node3.value = ":local(" + node3.value + ")";
          context.localizeNextItem = false;
        }
      }
      break;
    case "function":
      if (context.options && context.options.rewriteUrl && node3.value.toLowerCase() === "url") {
        node3.nodes.map((nestedNode) => {
          if (nestedNode.type !== "string" && nestedNode.type !== "word") {
            return;
          }
          let newUrl = context.options.rewriteUrl(
            context.global,
            nestedNode.value
          );
          switch (nestedNode.type) {
            case "string":
              if (nestedNode.quote === "'") {
                newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/'/g, "\\'");
              }
              if (nestedNode.quote === '"') {
                newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/"/g, '\\"');
              }
              break;
            case "word":
              newUrl = newUrl.replace(/("|'|\)|\\)/g, "\\$1");
              break;
          }
          nestedNode.value = newUrl;
        });
      }
      break;
  }
  return node3;
}
function isWordAFunctionArgument(wordNode, functionNode) {
  return functionNode ? functionNode.nodes.some(
    (functionNodeChild) => functionNodeChild.sourceIndex === wordNode.sourceIndex
  ) : false;
}
function localizeDeclarationValues(localize, declaration, context) {
  const valueNodes = valueParser2(declaration.value);
  valueNodes.walk((node3, index3, nodes) => {
    const subContext = {
      options: context.options,
      global: context.global,
      localizeNextItem: localize && !context.global,
      localAliasMap: context.localAliasMap
    };
    nodes[index3] = localizeDeclNode(node3, subContext);
  });
  declaration.value = valueNodes.toString();
}
function localizeDeclaration(declaration, context) {
  const isAnimation = /animation$/i.test(declaration.prop);
  if (isAnimation) {
    const validIdent = /^-?[_a-z][_a-z0-9-]*$/i;
    const animationKeywords = {
      $alternate: 1,
      "$alternate-reverse": 1,
      $backwards: 1,
      $both: 1,
      $ease: 1,
      "$ease-in": 1,
      "$ease-in-out": 1,
      "$ease-out": 1,
      $forwards: 1,
      $infinite: 1,
      $linear: 1,
      $none: Infinity,
      // No matter how many times you write none, it will never be an animation name
      $normal: 1,
      $paused: 1,
      $reverse: 1,
      $running: 1,
      "$step-end": 1,
      "$step-start": 1,
      $initial: Infinity,
      $inherit: Infinity,
      $unset: Infinity
    };
    let parsedAnimationKeywords = {};
    let stepsFunctionNode = null;
    const valueNodes = valueParser2(declaration.value).walk((node3) => {
      if (node3.type === "div") {
        parsedAnimationKeywords = {};
      }
      if (node3.type === "function" && node3.value.toLowerCase() === "steps") {
        stepsFunctionNode = node3;
      }
      const value2 = node3.type === "word" && !isWordAFunctionArgument(node3, stepsFunctionNode) ? node3.value.toLowerCase() : null;
      let shouldParseAnimationName = false;
      if (value2 && validIdent.test(value2)) {
        if ("$" + value2 in animationKeywords) {
          parsedAnimationKeywords["$" + value2] = "$" + value2 in parsedAnimationKeywords ? parsedAnimationKeywords["$" + value2] + 1 : 0;
          shouldParseAnimationName = parsedAnimationKeywords["$" + value2] >= animationKeywords["$" + value2];
        } else {
          shouldParseAnimationName = true;
        }
      }
      const subContext = {
        options: context.options,
        global: context.global,
        localizeNextItem: shouldParseAnimationName && !context.global,
        localAliasMap: context.localAliasMap
      };
      return localizeDeclNode(node3, subContext);
    });
    declaration.value = valueNodes.toString();
    return;
  }
  const isAnimationName = /animation(-name)?$/i.test(declaration.prop);
  if (isAnimationName) {
    return localizeDeclarationValues(true, declaration, context);
  }
  const hasUrl = /url\(/i.test(declaration.value);
  if (hasUrl) {
    return localizeDeclarationValues(false, declaration, context);
  }
}
function getSingleLocalNamesForComposes(root3) {
  return root3.nodes.map((node3) => {
    if (node3.type !== "selector" || node3.nodes.length !== 1) {
      throw new Error(
        `composition is only allowed when selector is single :local class name not in "${root3}"`
      );
    }
    node3 = node3.nodes[0];
    if (node3.type !== "pseudo" || node3.value !== ":local" || node3.nodes.length !== 1) {
      throw new Error(
        'composition is only allowed when selector is single :local class name not in "' + root3 + '", "' + node3 + '" is weird'
      );
    }
    node3 = node3.first;
    if (node3.type !== "selector" || node3.length !== 1) {
      throw new Error(
        'composition is only allowed when selector is single :local class name not in "' + root3 + '", "' + node3 + '" is weird'
      );
    }
    node3 = node3.first;
    if (node3.type !== "class") {
      throw new Error(
        'composition is only allowed when selector is single :local class name not in "' + root3 + '", "' + node3 + '" is weird'
      );
    }
    return node3.value;
  });
}
function unescape2(str2) {
  return str2.replace(unescapeRegExp, (_22, escaped2, escapedWhitespace) => {
    const high = "0x" + escaped2 - 65536;
    return high !== high || escapedWhitespace ? escaped2 : high < 0 ? (
      // BMP codepoint
      String.fromCharCode(high + 65536)
    ) : (
      // Supplemental Plane codepoint (surrogate pair)
      String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
    );
  });
}
function hash(str2) {
  var hash3 = 5381, i14 = str2.length;
  while (i14) {
    hash3 = hash3 * 33 ^ str2.charCodeAt(--i14);
  }
  return hash3 >>> 0;
}
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function getDefaultPlugins({
  behaviour,
  generateScopedName,
  exportGlobals
}) {
  const scope = (0, _postcssModulesScope.default)({
    generateScopedName,
    exportGlobals
  });
  const plugins2 = {
    [behaviours.LOCAL]: [_postcssModulesValues.default, (0, _postcssModulesLocalByDefault.default)({
      mode: "local"
    }), _postcssModulesExtractImports.default, scope],
    [behaviours.GLOBAL]: [_postcssModulesValues.default, (0, _postcssModulesLocalByDefault.default)({
      mode: "global"
    }), _postcssModulesExtractImports.default, scope]
  };
  return plugins2[behaviour];
}
function isValidBehaviour(behaviour) {
  return Object.keys(behaviours).map((key) => behaviours[key]).indexOf(behaviour) > -1;
}
function getDefaultScopeBehaviour(scopeBehaviour) {
  return scopeBehaviour && isValidBehaviour(scopeBehaviour) ? scopeBehaviour : behaviours.LOCAL;
}
function generateScopedNameDefault(name2, filename, css) {
  const i14 = css.indexOf(`.${name2}`);
  const lineNumber = css.substr(0, i14).split(/[\r\n]/).length;
  const hash3 = (0, _stringHash.default)(css).toString(36).substr(0, 5);
  return `_${name2}_${hash3}_${lineNumber}`;
}
function getScopedNameGenerator(generateScopedName, hashPrefix) {
  const scopedNameGenerator = generateScopedName || generateScopedNameDefault;
  if (typeof scopedNameGenerator === "function") {
    return scopedNameGenerator;
  }
  return (0, _genericNames.default)(scopedNameGenerator, {
    context: process.cwd(),
    hashPrefix
  });
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function isGlobalModule(globalModules, inputFile) {
  return globalModules.some((regex2) => inputFile.match(regex2));
}
function getDefaultPluginsList(opts, inputFile) {
  const globalModulesList = opts.globalModulePaths || null;
  const exportGlobals = opts.exportGlobals || false;
  const defaultBehaviour = (0, _scoping.getDefaultScopeBehaviour)(opts.scopeBehaviour);
  const generateScopedName = (0, _scoping.getScopedNameGenerator)(opts.generateScopedName, opts.hashPrefix);
  if (globalModulesList && isGlobalModule(globalModulesList, inputFile)) {
    return (0, _scoping.getDefaultPlugins)({
      behaviour: _scoping.behaviours.GLOBAL,
      generateScopedName,
      exportGlobals
    });
  }
  return (0, _scoping.getDefaultPlugins)({
    behaviour: defaultBehaviour,
    generateScopedName,
    exportGlobals
  });
}
function getLoader(opts, plugins2) {
  const root3 = typeof opts.root === "undefined" ? "/" : opts.root;
  return typeof opts.Loader === "function" ? new opts.Loader(root3, plugins2, opts.resolve) : new _FileSystemLoader.default(root3, plugins2, opts.resolve);
}
function isOurPlugin(plugin2) {
  return plugin2.postcssPlugin === PLUGIN_NAME;
}
function makePlugin(opts) {
  return {
    postcssPlugin: PLUGIN_NAME,
    async OnceExit(css, {
      result
    }) {
      const getJSON = opts.getJSON || _saveJSON.default;
      const inputFile = css.source.input.file;
      const pluginList = getDefaultPluginsList(opts, inputFile);
      const resultPluginIndex = result.processor.plugins.findIndex((plugin2) => isOurPlugin(plugin2));
      if (resultPluginIndex === -1) {
        throw new Error("Plugin missing from options.");
      }
      const earlierPlugins = result.processor.plugins.slice(0, resultPluginIndex);
      const loaderPlugins = [...earlierPlugins, ...pluginList];
      const loader = getLoader(opts, loaderPlugins);
      const fetcher = async (file, relativeTo, depTrace) => {
        const unquoteFile = (0, _unquote.default)(file);
        return loader.fetch.call(loader, unquoteFile, relativeTo, depTrace);
      };
      const parser2 = new _Parser.default(fetcher);
      await (0, _postcss.default)([...pluginList, parser2.plugin()]).process(css, {
        from: inputFile
      });
      const out = loader.finalSource;
      if (out) css.prepend(out);
      if (opts.localsConvention) {
        const reducer = (0, _localsConvention.makeLocalsConventionReducer)(opts.localsConvention, inputFile);
        parser2.exportTokens = Object.entries(parser2.exportTokens).reduce(reducer, {});
      }
      result.messages.push({
        type: "export",
        plugin: "postcss-modules",
        exportTokens: parser2.exportTokens
      });
      return getJSON(css.source.input.file, parser2.exportTokens, result.opts.to);
    }
  };
}
var __filename3, __dirname3, require26, build, fs3, fileSystem, pluginFactory, unquote$1, reg, Parser$1, matchValueName, replaceValueSymbols$2, replaceValueSymbols_1, replaceValueSymbols$1, replaceSymbols$1, replaceSymbols_1, importPattern, balancedQuotes, getDeclsObject, extractICSS$2, extractICSS_1, createImports, createExports, createICSSRules$1, createICSSRules_1, replaceValueSymbols, replaceSymbols, extractICSS$1, createICSSRules, src$4, _icssUtils, importRegexp, Parser, saveJSON$1, _fs$2, localsConvention, INFINITY, symbolTag, reAsciiWord, reLatin, rsAstralRange, rsComboMarksRange, rsComboSymbolsRange, rsDingbatRange, rsLowerRange, rsMathOpRange, rsNonCharRange, rsPunctuationRange, rsSpaceRange, rsUpperRange, rsVarRange, rsBreakRange, rsApos, rsAstral, rsBreak, rsCombo, rsDigits, rsDingbat, rsLower, rsMisc, rsFitz, rsModifier, rsNonAstral, rsRegional, rsSurrPair, rsUpper, rsZWJ, rsLowerMisc, rsUpperMisc, rsOptLowerContr, rsOptUpperContr, reOptMod, rsOptVar, rsOptJoin, rsSeq, rsEmoji, rsSymbol, reApos, reComboMark, reUnicode, reUnicodeWord, reHasUnicode, reHasUnicodeWord, deburredLetters, freeGlobal, freeSelf, root$2, deburrLetter, objectProto, objectToString, Symbol$1, symbolProto, symbolToString, camelCase, upperFirst, lodash_camelcase, _lodash, FileSystemLoader$1, _postcss$1, _path, _Parser$1, _fs$1, Core, traceKeySorter, FileSystemLoader, scoping, src$3, PERMANENT_MARKER, TEMPORARY_MARKER, topologicalSort_1, topologicalSort, matchImports$1, icssImport, VISITED_MARKER, srcExports$2, wasmHash, hasRequiredWasmHash, xxhash64_1, hasRequiredXxhash64, BatchedHash_1, hasRequiredBatchedHash, md4_1, hasRequiredMd4, BulkUpdateDecorator_1, hasRequiredBulkUpdateDecorator, baseEncodeTables, crypto, createXXHash64, createMd4, BatchedHash, BulkUpdateDecorator, getHashDigest_1, path$12, getHashDigest, interpolateName_1, interpolateName, path4, genericNames, src$2, dist, processor, parser, root$1, container, node$1, util, unesc, unescExports, getProp, getPropExports, ensureObject, ensureObjectExports, stripComments, stripCommentsExports, _unesc, _getProp, _ensureObject, _stripComments, nodeExports, types, TAG, STRING, SELECTOR, ROOT, PSEUDO, NESTING, ID, COMMENT, COMBINATOR, CLASS, ATTRIBUTE, UNIVERSAL, containerExports, rootExports, selector$1, selectorExports, className$1, object, hasOwnProperty$1, merge, regexAnySingleEscape, regexSingleEscape, regexExcessiveSpaces, cssesc, cssesc_1, classNameExports, comment$2, commentExports, id$1, idExports, tag$1, namespace, namespaceExports, tagExports, string$1, stringExports, pseudo$1, pseudoExports, attribute$1, node, universal$1, universalExports, combinator$2, combinatorExports, nesting$1, nestingExports, sortAscending, sortAscendingExports, tokenize, tokenTypes, ampersand, asterisk, at, comma2, colon2, semicolon, openParenthesis, closeParenthesis, openSquare, closeSquare, dollar, tilde, caret, plus2, equals, pipe, greaterThan, space, singleQuote2, doubleQuote2, slash2, bang, backslash2, cr, feed, newline, tab, str, comment$1, word, combinator$1, parserExports, processorExports, selectors, constructors, _attribute, _className, _combinator, _comment, _id, _nesting, _pseudo, _root, _selector, _string, _tag, _universal, attribute, className, combinator, comment, id, nesting, pseudo, root, selector, string, tag, universal, guards, _types, _IS_TYPE, IS_TYPE, isAttribute, isClassName, isCombinator, isComment, isIdentifier, isNesting, isPseudo, isRoot, isSelector, isString, isTag, isUniversal, distExports, selectorParser$1, valueParser2, extractICSS, isSpacing, srcExports$1, selectorParser, hasOwnProperty, whitespace, unescapeRegExp, plugin, src$1, stringHash, src, ICSSUtils, matchImports, matchValueDefinition, matchImport, srcExports, _postcssModulesExtractImports, _genericNames, _postcssModulesLocalByDefault, _postcssModulesScope, _stringHash, _postcssModulesValues, behaviours, _postcss, _unquote, _Parser, _saveJSON, _localsConvention, _FileSystemLoader, _scoping, PLUGIN_NAME, _fs, _fs2, _pluginFactory, postcss, buildExports, index2, index$12;
var init_dep_BASfdaBA = __esm({
  "dist/node/chunks/dep-BASfdaBA.js"() {
    init_dep_BWSbWtLw();
    init_postcss_8_4();
    init_dep_IQS_Za7F();
    __filename3 = __cjs_fileURLToPath3(import.meta.url);
    __dirname3 = __cjs_dirname3(__filename3);
    require26 = __cjs_createRequire3(import.meta.url);
    build = { exports: {} };
    fs3 = {};
    Object.defineProperty(fs3, "__esModule", {
      value: true
    });
    fs3.getFileSystem = getFileSystem;
    fs3.setFileSystem = setFileSystem;
    fileSystem = {
      readFile: () => {
        throw Error("readFile not implemented");
      },
      writeFile: () => {
        throw Error("writeFile not implemented");
      }
    };
    pluginFactory = {};
    unquote$1 = {};
    Object.defineProperty(unquote$1, "__esModule", {
      value: true
    });
    unquote$1.default = unquote;
    reg = /['"]/;
    Parser$1 = {};
    matchValueName = /[$]?[\w-]+/g;
    replaceValueSymbols$2 = (value2, replacements) => {
      let matches;
      while (matches = matchValueName.exec(value2)) {
        const replacement = replacements[matches[0]];
        if (replacement) {
          value2 = value2.slice(0, matches.index) + replacement + value2.slice(matchValueName.lastIndex);
          matchValueName.lastIndex -= matches[0].length - replacement.length;
        }
      }
      return value2;
    };
    replaceValueSymbols_1 = replaceValueSymbols$2;
    replaceValueSymbols$1 = replaceValueSymbols_1;
    replaceSymbols$1 = (css, replacements) => {
      css.walk((node3) => {
        if (node3.type === "decl" && node3.value) {
          node3.value = replaceValueSymbols$1(node3.value.toString(), replacements);
        } else if (node3.type === "rule" && node3.selector) {
          node3.selector = replaceValueSymbols$1(
            node3.selector.toString(),
            replacements
          );
        } else if (node3.type === "atrule" && node3.params) {
          node3.params = replaceValueSymbols$1(node3.params.toString(), replacements);
        }
      });
    };
    replaceSymbols_1 = replaceSymbols$1;
    importPattern = /^:import\(("[^"]*"|'[^']*'|[^"']+)\)$/;
    balancedQuotes = /^("[^"]*"|'[^']*'|[^"']+)$/;
    getDeclsObject = (rule) => {
      const object2 = {};
      rule.walkDecls((decl) => {
        const before = decl.raws.before ? decl.raws.before.trim() : "";
        object2[before + decl.prop] = decl.value;
      });
      return object2;
    };
    extractICSS$2 = (css, removeRules = true, mode2 = "auto") => {
      const icssImports = {};
      const icssExports = {};
      function addImports(node3, path7) {
        const unquoted = path7.replace(/'|"/g, "");
        icssImports[unquoted] = Object.assign(
          icssImports[unquoted] || {},
          getDeclsObject(node3)
        );
        if (removeRules) {
          node3.remove();
        }
      }
      function addExports(node3) {
        Object.assign(icssExports, getDeclsObject(node3));
        if (removeRules) {
          node3.remove();
        }
      }
      css.each((node3) => {
        if (node3.type === "rule" && mode2 !== "at-rule") {
          if (node3.selector.slice(0, 7) === ":import") {
            const matches = importPattern.exec(node3.selector);
            if (matches) {
              addImports(node3, matches[1]);
            }
          }
          if (node3.selector === ":export") {
            addExports(node3);
          }
        }
        if (node3.type === "atrule" && mode2 !== "rule") {
          if (node3.name === "icss-import") {
            const matches = balancedQuotes.exec(node3.params);
            if (matches) {
              addImports(node3, matches[1]);
            }
          }
          if (node3.name === "icss-export") {
            addExports(node3);
          }
        }
      });
      return { icssImports, icssExports };
    };
    extractICSS_1 = extractICSS$2;
    createImports = (imports2, postcss2, mode2 = "rule") => {
      return Object.keys(imports2).map((path7) => {
        const aliases = imports2[path7];
        const declarations = Object.keys(aliases).map(
          (key) => postcss2.decl({
            prop: key,
            value: aliases[key],
            raws: { before: "\n  " }
          })
        );
        const hasDeclarations = declarations.length > 0;
        const rule = mode2 === "rule" ? postcss2.rule({
          selector: `:import('${path7}')`,
          raws: { after: hasDeclarations ? "\n" : "" }
        }) : postcss2.atRule({
          name: "icss-import",
          params: `'${path7}'`,
          raws: { after: hasDeclarations ? "\n" : "" }
        });
        if (hasDeclarations) {
          rule.append(declarations);
        }
        return rule;
      });
    };
    createExports = (exports4, postcss2, mode2 = "rule") => {
      const declarations = Object.keys(exports4).map(
        (key) => postcss2.decl({
          prop: key,
          value: exports4[key],
          raws: { before: "\n  " }
        })
      );
      if (declarations.length === 0) {
        return [];
      }
      const rule = mode2 === "rule" ? postcss2.rule({
        selector: `:export`,
        raws: { after: "\n" }
      }) : postcss2.atRule({
        name: "icss-export",
        raws: { after: "\n" }
      });
      rule.append(declarations);
      return [rule];
    };
    createICSSRules$1 = (imports2, exports4, postcss2, mode2) => [
      ...createImports(imports2, postcss2, mode2),
      ...createExports(exports4, postcss2, mode2)
    ];
    createICSSRules_1 = createICSSRules$1;
    replaceValueSymbols = replaceValueSymbols_1;
    replaceSymbols = replaceSymbols_1;
    extractICSS$1 = extractICSS_1;
    createICSSRules = createICSSRules_1;
    src$4 = {
      replaceValueSymbols,
      replaceSymbols,
      extractICSS: extractICSS$1,
      createICSSRules
    };
    Object.defineProperty(Parser$1, "__esModule", {
      value: true
    });
    Parser$1.default = void 0;
    _icssUtils = src$4;
    importRegexp = /^:import\((.+)\)$/;
    Parser = class {
      constructor(pathFetcher, trace) {
        this.pathFetcher = pathFetcher;
        this.plugin = this.plugin.bind(this);
        this.exportTokens = {};
        this.translations = {};
        this.trace = trace;
      }
      plugin() {
        const parser2 = this;
        return {
          postcssPlugin: "css-modules-parser",
          async OnceExit(css) {
            await Promise.all(parser2.fetchAllImports(css));
            parser2.linkImportedSymbols(css);
            return parser2.extractExports(css);
          }
        };
      }
      fetchAllImports(css) {
        let imports2 = [];
        css.each((node3) => {
          if (node3.type == "rule" && node3.selector.match(importRegexp)) {
            imports2.push(this.fetchImport(node3, css.source.input.from, imports2.length));
          }
        });
        return imports2;
      }
      linkImportedSymbols(css) {
        (0, _icssUtils.replaceSymbols)(css, this.translations);
      }
      extractExports(css) {
        css.each((node3) => {
          if (node3.type == "rule" && node3.selector == ":export") this.handleExport(node3);
        });
      }
      handleExport(exportNode) {
        exportNode.each((decl) => {
          if (decl.type == "decl") {
            Object.keys(this.translations).forEach((translation) => {
              decl.value = decl.value.replace(translation, this.translations[translation]);
            });
            this.exportTokens[decl.prop] = decl.value;
          }
        });
        exportNode.remove();
      }
      async fetchImport(importNode, relativeTo, depNr) {
        const file = importNode.selector.match(importRegexp)[1];
        const depTrace = this.trace + String.fromCharCode(depNr);
        const exports4 = await this.pathFetcher(file, relativeTo, depTrace);
        try {
          importNode.each((decl) => {
            if (decl.type == "decl") {
              this.translations[decl.prop] = exports4[decl.value];
            }
          });
          importNode.remove();
        } catch (err) {
          console.log(err);
        }
      }
    };
    Parser$1.default = Parser;
    saveJSON$1 = {};
    Object.defineProperty(saveJSON$1, "__esModule", {
      value: true
    });
    saveJSON$1.default = saveJSON;
    _fs$2 = fs3;
    localsConvention = {};
    INFINITY = 1 / 0;
    symbolTag = "[object Symbol]";
    reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    rsAstralRange = "\\ud800-\\udfff";
    rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    rsComboSymbolsRange = "\\u20d0-\\u20f0";
    rsDingbatRange = "\\u2700-\\u27bf";
    rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    rsPunctuationRange = "\\u2000-\\u206f";
    rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    rsVarRange = "\\ufe0e\\ufe0f";
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    rsApos = "['’]";
    rsAstral = "[" + rsAstralRange + "]";
    rsBreak = "[" + rsBreakRange + "]";
    rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    rsDigits = "\\d+";
    rsDingbat = "[" + rsDingbatRange + "]";
    rsLower = "[" + rsLowerRange + "]";
    rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    rsFitz = "\\ud83c[\\udffb-\\udfff]";
    rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    rsNonAstral = "[^" + rsAstralRange + "]";
    rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    rsUpper = "[" + rsUpperRange + "]";
    rsZWJ = "\\u200d";
    rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    reOptMod = rsModifier + "?";
    rsOptVar = "[" + rsVarRange + "]?";
    rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    rsSeq = rsOptVar + reOptMod + rsOptJoin;
    rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    reApos = RegExp(rsApos, "g");
    reComboMark = RegExp(rsCombo, "g");
    reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "ss"
    };
    freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    freeSelf = typeof self == "object" && self && self.Object === Object && self;
    root$2 = freeGlobal || freeSelf || Function("return this")();
    deburrLetter = basePropertyOf(deburredLetters);
    objectProto = Object.prototype;
    objectToString = objectProto.toString;
    Symbol$1 = root$2.Symbol;
    symbolProto = Symbol$1 ? Symbol$1.prototype : void 0;
    symbolToString = symbolProto ? symbolProto.toString : void 0;
    camelCase = createCompounder(function(result, word2, index3) {
      word2 = word2.toLowerCase();
      return result + (index3 ? capitalize(word2) : word2);
    });
    upperFirst = createCaseFirst("toUpperCase");
    lodash_camelcase = camelCase;
    Object.defineProperty(localsConvention, "__esModule", {
      value: true
    });
    localsConvention.makeLocalsConventionReducer = makeLocalsConventionReducer;
    _lodash = _interopRequireDefault$5(lodash_camelcase);
    FileSystemLoader$1 = {};
    Object.defineProperty(FileSystemLoader$1, "__esModule", {
      value: true
    });
    FileSystemLoader$1.default = void 0;
    _postcss$1 = _interopRequireDefault$4(e);
    _path = _interopRequireDefault$4(require$$0$1);
    _Parser$1 = _interopRequireDefault$4(Parser$1);
    _fs$1 = fs3;
    Core = class _Core {
      constructor(plugins2) {
        this.plugins = plugins2 || _Core.defaultPlugins;
      }
      async load(sourceString, sourcePath, trace, pathFetcher) {
        const parser2 = new _Parser$1.default(pathFetcher, trace);
        const plugins2 = this.plugins.concat([parser2.plugin()]);
        const result = await (0, _postcss$1.default)(plugins2).process(sourceString, {
          from: sourcePath
        });
        return {
          injectableSource: result.css,
          exportTokens: parser2.exportTokens
        };
      }
    };
    traceKeySorter = (a20, b18) => {
      if (a20.length < b18.length) {
        return a20 < b18.substring(0, a20.length) ? -1 : 1;
      }
      if (a20.length > b18.length) {
        return a20.substring(0, b18.length) <= b18 ? -1 : 1;
      }
      return a20 < b18 ? -1 : 1;
    };
    FileSystemLoader = class {
      constructor(root3, plugins2, fileResolve) {
        if (root3 === "/" && process.platform === "win32") {
          const cwdDrive = process.cwd().slice(0, 3);
          if (!/^[A-Za-z]:\\$/.test(cwdDrive)) {
            throw new Error(`Failed to obtain root from "${process.cwd()}".`);
          }
          root3 = cwdDrive;
        }
        this.root = root3;
        this.fileResolve = fileResolve;
        this.sources = {};
        this.traces = {};
        this.importNr = 0;
        this.core = new Core(plugins2);
        this.tokensByFile = {};
        this.fs = (0, _fs$1.getFileSystem)();
      }
      async fetch(_newPath, relativeTo, _trace) {
        const newPath = _newPath.replace(/^["']|["']$/g, "");
        const trace = _trace || String.fromCharCode(this.importNr++);
        const useFileResolve = typeof this.fileResolve === "function";
        const fileResolvedPath = useFileResolve ? await this.fileResolve(newPath, relativeTo) : await Promise.resolve();
        if (fileResolvedPath && !_path.default.isAbsolute(fileResolvedPath)) {
          throw new Error('The returned path from the "fileResolve" option must be absolute.');
        }
        const relativeDir = _path.default.dirname(relativeTo);
        const rootRelativePath = fileResolvedPath || _path.default.resolve(relativeDir, newPath);
        let fileRelativePath = fileResolvedPath || _path.default.resolve(_path.default.resolve(this.root, relativeDir), newPath);
        if (!useFileResolve && newPath[0] !== "." && !_path.default.isAbsolute(newPath)) {
          try {
            fileRelativePath = require26.resolve(newPath);
          } catch (e2) {
          }
        }
        const tokens = this.tokensByFile[fileRelativePath];
        if (tokens) return tokens;
        return new Promise((resolve5, reject) => {
          this.fs.readFile(fileRelativePath, "utf-8", async (err, source) => {
            if (err) reject(err);
            const {
              injectableSource,
              exportTokens
            } = await this.core.load(source, rootRelativePath, trace, this.fetch.bind(this));
            this.sources[fileRelativePath] = injectableSource;
            this.traces[trace] = fileRelativePath;
            this.tokensByFile[fileRelativePath] = exportTokens;
            resolve5(exportTokens);
          });
        });
      }
      get finalSource() {
        const traces = this.traces;
        const sources = this.sources;
        let written = /* @__PURE__ */ new Set();
        return Object.keys(traces).sort(traceKeySorter).map((key) => {
          const filename = traces[key];
          if (written.has(filename)) {
            return null;
          }
          written.add(filename);
          return sources[filename];
        }).join("");
      }
    };
    FileSystemLoader$1.default = FileSystemLoader;
    scoping = {};
    src$3 = { exports: {} };
    PERMANENT_MARKER = 2;
    TEMPORARY_MARKER = 1;
    topologicalSort_1 = topologicalSort$1;
    topologicalSort = topologicalSort_1;
    matchImports$1 = /^(.+?)\s+from\s+(?:"([^"]+)"|'([^']+)'|(global))$/;
    icssImport = /^:import\((?:"([^"]+)"|'([^']+)')\)/;
    VISITED_MARKER = 1;
    src$3.exports = (options2 = {}) => {
      let importIndex = 0;
      const createImportedName = typeof options2.createImportedName !== "function" ? (importName) => `i__imported_${importName.replace(/\W/g, "_")}_${importIndex++}` : options2.createImportedName;
      const failOnWrongOrder = options2.failOnWrongOrder;
      return {
        postcssPlugin: "postcss-modules-extract-imports",
        prepare() {
          const graph = {};
          const visited = {};
          const existingImports = {};
          const importDecls = {};
          const imports2 = {};
          return {
            Once(root3, postcss2) {
              root3.walkRules((rule) => {
                const matches = icssImport.exec(rule.selector);
                if (matches) {
                  const [
                    ,
                    /*match*/
                    doubleQuotePath,
                    singleQuotePath
                  ] = matches;
                  const importPath = doubleQuotePath || singleQuotePath;
                  addImportToGraph(importPath, "root", graph, visited);
                  existingImports[importPath] = rule;
                }
              });
              root3.walkDecls(/^composes$/, (declaration) => {
                const matches = declaration.value.match(matchImports$1);
                if (!matches) {
                  return;
                }
                let tmpSymbols;
                let [
                  ,
                  /*match*/
                  symbols,
                  doubleQuotePath,
                  singleQuotePath,
                  global2
                ] = matches;
                if (global2) {
                  tmpSymbols = symbols.split(/\s+/).map((s12) => `global(${s12})`);
                } else {
                  const importPath = doubleQuotePath || singleQuotePath;
                  let parent = declaration.parent;
                  let parentIndexes = "";
                  while (parent.type !== "root") {
                    parentIndexes = parent.parent.index(parent) + "_" + parentIndexes;
                    parent = parent.parent;
                  }
                  const { selector: selector3 } = declaration.parent;
                  const parentRule = `_${parentIndexes}${selector3}`;
                  addImportToGraph(importPath, parentRule, graph, visited);
                  importDecls[importPath] = declaration;
                  imports2[importPath] = imports2[importPath] || {};
                  tmpSymbols = symbols.split(/\s+/).map((s12) => {
                    if (!imports2[importPath][s12]) {
                      imports2[importPath][s12] = createImportedName(s12, importPath);
                    }
                    return imports2[importPath][s12];
                  });
                }
                declaration.value = tmpSymbols.join(" ");
              });
              const importsOrder = topologicalSort(graph, failOnWrongOrder);
              if (importsOrder instanceof Error) {
                const importPath = importsOrder.nodes.find(
                  (importPath2) => (
                    // eslint-disable-next-line no-prototype-builtins
                    importDecls.hasOwnProperty(importPath2)
                  )
                );
                const decl = importDecls[importPath];
                throw decl.error(
                  "Failed to resolve order of composed modules " + importsOrder.nodes.map((importPath2) => "`" + importPath2 + "`").join(", ") + ".",
                  {
                    plugin: "postcss-modules-extract-imports",
                    word: "composes"
                  }
                );
              }
              let lastImportRule;
              importsOrder.forEach((path7) => {
                const importedSymbols = imports2[path7];
                let rule = existingImports[path7];
                if (!rule && importedSymbols) {
                  rule = postcss2.rule({
                    selector: `:import("${path7}")`,
                    raws: { after: "\n" }
                  });
                  if (lastImportRule) {
                    root3.insertAfter(lastImportRule, rule);
                  } else {
                    root3.prepend(rule);
                  }
                }
                lastImportRule = rule;
                if (!importedSymbols) {
                  return;
                }
                Object.keys(importedSymbols).forEach((importedSymbol) => {
                  rule.append(
                    postcss2.decl({
                      value: importedSymbol,
                      prop: importedSymbols[importedSymbol],
                      raws: { before: "\n  " }
                    })
                  );
                });
              });
            }
          };
        }
      };
    };
    src$3.exports.postcss = true;
    srcExports$2 = src$3.exports;
    wasmHash = { exports: {} };
    baseEncodeTables = {
      26: "abcdefghijklmnopqrstuvwxyz",
      32: "123456789abcdefghjkmnpqrstuvwxyz",
      // no 0lio
      36: "0123456789abcdefghijklmnopqrstuvwxyz",
      49: "abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
      // no lIO
      52: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
      58: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
      // no 0lIO
      62: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
      64: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_"
    };
    crypto = void 0;
    createXXHash64 = void 0;
    createMd4 = void 0;
    BatchedHash = void 0;
    BulkUpdateDecorator = void 0;
    getHashDigest_1 = getHashDigest$1;
    path$12 = require$$0$1;
    getHashDigest = getHashDigest_1;
    interpolateName_1 = interpolateName$1;
    interpolateName = interpolateName_1;
    path4 = require$$0$1;
    genericNames = function createGenerator(pattern2, options2) {
      options2 = options2 || {};
      var context = options2 && typeof options2.context === "string" ? options2.context : process.cwd();
      var hashPrefix = options2 && typeof options2.hashPrefix === "string" ? options2.hashPrefix : "";
      return function generate2(localName, filepath) {
        var name2 = pattern2.replace(/\[local\]/gi, localName);
        var loaderContext = {
          resourcePath: filepath
        };
        var loaderOptions = {
          content: hashPrefix + path4.relative(context, filepath).replace(/\\/g, "/") + "\0" + localName,
          context
        };
        var genericName = interpolateName(loaderContext, name2, loaderOptions);
        return genericName.replace(new RegExp("[^a-zA-Z0-9\\-_ -￿]", "g"), "-").replace(/^((-?[0-9])|--)/, "_$1");
      };
    };
    src$2 = { exports: {} };
    dist = { exports: {} };
    processor = { exports: {} };
    parser = { exports: {} };
    root$1 = { exports: {} };
    container = { exports: {} };
    node$1 = { exports: {} };
    util = {};
    unesc = { exports: {} };
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = unesc2;
      function gobbleHex(str2) {
        var lower = str2.toLowerCase();
        var hex = "";
        var spaceTerminated = false;
        for (var i14 = 0; i14 < 6 && lower[i14] !== void 0; i14++) {
          var code = lower.charCodeAt(i14);
          var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
          spaceTerminated = code === 32;
          if (!valid) {
            break;
          }
          hex += lower[i14];
        }
        if (hex.length === 0) {
          return void 0;
        }
        var codePoint = parseInt(hex, 16);
        var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
        if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
          return ["�", hex.length + (spaceTerminated ? 1 : 0)];
        }
        return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
      }
      var CONTAINS_ESCAPE = /\\/;
      function unesc2(str2) {
        var needToProcess = CONTAINS_ESCAPE.test(str2);
        if (!needToProcess) {
          return str2;
        }
        var ret = "";
        for (var i14 = 0; i14 < str2.length; i14++) {
          if (str2[i14] === "\\") {
            var gobbled = gobbleHex(str2.slice(i14 + 1, i14 + 7));
            if (gobbled !== void 0) {
              ret += gobbled[0];
              i14 += gobbled[1];
              continue;
            }
            if (str2[i14 + 1] === "\\") {
              ret += "\\";
              i14++;
              continue;
            }
            if (str2.length === i14 + 1) {
              ret += str2[i14];
            }
            continue;
          }
          ret += str2[i14];
        }
        return ret;
      }
      module3.exports = exports4.default;
    })(unesc, unesc.exports);
    unescExports = unesc.exports;
    getProp = { exports: {} };
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = getProp2;
      function getProp2(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }
        while (props.length > 0) {
          var prop = props.shift();
          if (!obj[prop]) {
            return void 0;
          }
          obj = obj[prop];
        }
        return obj;
      }
      module3.exports = exports4.default;
    })(getProp, getProp.exports);
    getPropExports = getProp.exports;
    ensureObject = { exports: {} };
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = ensureObject2;
      function ensureObject2(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }
        while (props.length > 0) {
          var prop = props.shift();
          if (!obj[prop]) {
            obj[prop] = {};
          }
          obj = obj[prop];
        }
      }
      module3.exports = exports4.default;
    })(ensureObject, ensureObject.exports);
    ensureObjectExports = ensureObject.exports;
    stripComments = { exports: {} };
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = stripComments2;
      function stripComments2(str2) {
        var s12 = "";
        var commentStart = str2.indexOf("/*");
        var lastEnd = 0;
        while (commentStart >= 0) {
          s12 = s12 + str2.slice(lastEnd, commentStart);
          var commentEnd = str2.indexOf("*/", commentStart + 2);
          if (commentEnd < 0) {
            return s12;
          }
          lastEnd = commentEnd + 2;
          commentStart = str2.indexOf("/*", lastEnd);
        }
        s12 = s12 + str2.slice(lastEnd);
        return s12;
      }
      module3.exports = exports4.default;
    })(stripComments, stripComments.exports);
    stripCommentsExports = stripComments.exports;
    util.__esModule = true;
    util.unesc = util.stripComments = util.getProp = util.ensureObject = void 0;
    _unesc = _interopRequireDefault$3(unescExports);
    util.unesc = _unesc["default"];
    _getProp = _interopRequireDefault$3(getPropExports);
    util.getProp = _getProp["default"];
    _ensureObject = _interopRequireDefault$3(ensureObjectExports);
    util.ensureObject = _ensureObject["default"];
    _stripComments = _interopRequireDefault$3(stripCommentsExports);
    util.stripComments = _stripComments["default"];
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _util = util;
      function _defineProperties(target, props) {
        for (var i14 = 0; i14 < props.length; i14++) {
          var descriptor = props[i14];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var cloneNode = function cloneNode2(obj, parent) {
        if (typeof obj !== "object" || obj === null) {
          return obj;
        }
        var cloned = new obj.constructor();
        for (var i14 in obj) {
          if (!obj.hasOwnProperty(i14)) {
            continue;
          }
          var value2 = obj[i14];
          var type = typeof value2;
          if (i14 === "parent" && type === "object") {
            if (parent) {
              cloned[i14] = parent;
            }
          } else if (value2 instanceof Array) {
            cloned[i14] = value2.map(function(j16) {
              return cloneNode2(j16, cloned);
            });
          } else {
            cloned[i14] = cloneNode2(value2, cloned);
          }
        }
        return cloned;
      };
      var Node = /* @__PURE__ */ function() {
        function Node2(opts) {
          if (opts === void 0) {
            opts = {};
          }
          Object.assign(this, opts);
          this.spaces = this.spaces || {};
          this.spaces.before = this.spaces.before || "";
          this.spaces.after = this.spaces.after || "";
        }
        var _proto = Node2.prototype;
        _proto.remove = function remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = void 0;
          return this;
        };
        _proto.replaceWith = function replaceWith() {
          if (this.parent) {
            for (var index3 in arguments) {
              this.parent.insertBefore(this, arguments[index3]);
            }
            this.remove();
          }
          return this;
        };
        _proto.next = function next() {
          return this.parent.at(this.parent.index(this) + 1);
        };
        _proto.prev = function prev() {
          return this.parent.at(this.parent.index(this) - 1);
        };
        _proto.clone = function clone(overrides) {
          if (overrides === void 0) {
            overrides = {};
          }
          var cloned = cloneNode(this);
          for (var name2 in overrides) {
            cloned[name2] = overrides[name2];
          }
          return cloned;
        };
        _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name2, value2, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }
          var originalValue = this[name2];
          var originalEscaped = this.raws[name2];
          this[name2] = originalValue + value2;
          if (originalEscaped || valueEscaped !== value2) {
            this.raws[name2] = (originalEscaped || originalValue) + valueEscaped;
          } else {
            delete this.raws[name2];
          }
        };
        _proto.setPropertyAndEscape = function setPropertyAndEscape(name2, value2, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }
          this[name2] = value2;
          this.raws[name2] = valueEscaped;
        };
        _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name2, value2) {
          this[name2] = value2;
          if (this.raws) {
            delete this.raws[name2];
          }
        };
        _proto.isAtPosition = function isAtPosition(line, column) {
          if (this.source && this.source.start && this.source.end) {
            if (this.source.start.line > line) {
              return false;
            }
            if (this.source.end.line < line) {
              return false;
            }
            if (this.source.start.line === line && this.source.start.column > column) {
              return false;
            }
            if (this.source.end.line === line && this.source.end.column < column) {
              return false;
            }
            return true;
          }
          return void 0;
        };
        _proto.stringifyProperty = function stringifyProperty(name2) {
          return this.raws && this.raws[name2] || this[name2];
        };
        _proto.valueToString = function valueToString() {
          return String(this.stringifyProperty("value"));
        };
        _proto.toString = function toString2() {
          return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
        };
        _createClass(Node2, [{
          key: "rawSpaceBefore",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
            if (rawSpace === void 0) {
              rawSpace = this.spaces && this.spaces.before;
            }
            return rawSpace || "";
          },
          set: function set2(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.before = raw;
          }
        }, {
          key: "rawSpaceAfter",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
            if (rawSpace === void 0) {
              rawSpace = this.spaces.after;
            }
            return rawSpace || "";
          },
          set: function set2(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.after = raw;
          }
        }]);
        return Node2;
      }();
      exports4["default"] = Node;
      module3.exports = exports4.default;
    })(node$1, node$1.exports);
    nodeExports = node$1.exports;
    types = {};
    types.__esModule = true;
    types.UNIVERSAL = types.TAG = types.STRING = types.SELECTOR = types.ROOT = types.PSEUDO = types.NESTING = types.ID = types.COMMENT = types.COMBINATOR = types.CLASS = types.ATTRIBUTE = void 0;
    TAG = "tag";
    types.TAG = TAG;
    STRING = "string";
    types.STRING = STRING;
    SELECTOR = "selector";
    types.SELECTOR = SELECTOR;
    ROOT = "root";
    types.ROOT = ROOT;
    PSEUDO = "pseudo";
    types.PSEUDO = PSEUDO;
    NESTING = "nesting";
    types.NESTING = NESTING;
    ID = "id";
    types.ID = ID;
    COMMENT = "comment";
    types.COMMENT = COMMENT;
    COMBINATOR = "combinator";
    types.COMBINATOR = COMBINATOR;
    CLASS = "class";
    types.CLASS = CLASS;
    ATTRIBUTE = "attribute";
    types.ATTRIBUTE = ATTRIBUTE;
    UNIVERSAL = "universal";
    types.UNIVERSAL = UNIVERSAL;
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _node = _interopRequireDefault2(nodeExports);
      var types$12 = _interopRequireWildcard(types);
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _createForOfIteratorHelperLoose(o10, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o10[Symbol.iterator] || o10["@@iterator"];
        if (it) return (it = it.call(o10)).next.bind(it);
        if (Array.isArray(o10) || (it = _unsupportedIterableToArray(o10)) || allowArrayLike) {
          if (it) o10 = it;
          var i14 = 0;
          return function() {
            if (i14 >= o10.length) return { done: true };
            return { done: false, value: o10[i14++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o10, minLen) {
        if (!o10) return;
        if (typeof o10 === "string") return _arrayLikeToArray(o10, minLen);
        var n14 = Object.prototype.toString.call(o10).slice(8, -1);
        if (n14 === "Object" && o10.constructor) n14 = o10.constructor.name;
        if (n14 === "Map" || n14 === "Set") return Array.from(o10);
        if (n14 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n14)) return _arrayLikeToArray(o10, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i14 = 0, arr2 = new Array(len); i14 < len; i14++) {
          arr2[i14] = arr[i14];
        }
        return arr2;
      }
      function _defineProperties(target, props) {
        for (var i14 = 0; i14 < props.length; i14++) {
          var descriptor = props[i14];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o10, p20) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p21) {
          o11.__proto__ = p21;
          return o11;
        };
        return _setPrototypeOf(o10, p20);
      }
      var Container = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Container2, _Node);
        function Container2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          if (!_this.nodes) {
            _this.nodes = [];
          }
          return _this;
        }
        var _proto = Container2.prototype;
        _proto.append = function append2(selector3) {
          selector3.parent = this;
          this.nodes.push(selector3);
          return this;
        };
        _proto.prepend = function prepend(selector3) {
          selector3.parent = this;
          this.nodes.unshift(selector3);
          return this;
        };
        _proto.at = function at2(index3) {
          return this.nodes[index3];
        };
        _proto.index = function index3(child) {
          if (typeof child === "number") {
            return child;
          }
          return this.nodes.indexOf(child);
        };
        _proto.removeChild = function removeChild(child) {
          child = this.index(child);
          this.at(child).parent = void 0;
          this.nodes.splice(child, 1);
          var index3;
          for (var id3 in this.indexes) {
            index3 = this.indexes[id3];
            if (index3 >= child) {
              this.indexes[id3] = index3 - 1;
            }
          }
          return this;
        };
        _proto.removeAll = function removeAll() {
          for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
            var node3 = _step.value;
            node3.parent = void 0;
          }
          this.nodes = [];
          return this;
        };
        _proto.empty = function empty() {
          return this.removeAll();
        };
        _proto.insertAfter = function insertAfter(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex + 1, 0, newNode);
          newNode.parent = this;
          var index3;
          for (var id3 in this.indexes) {
            index3 = this.indexes[id3];
            if (oldIndex <= index3) {
              this.indexes[id3] = index3 + 1;
            }
          }
          return this;
        };
        _proto.insertBefore = function insertBefore(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex, 0, newNode);
          newNode.parent = this;
          var index3;
          for (var id3 in this.indexes) {
            index3 = this.indexes[id3];
            if (index3 <= oldIndex) {
              this.indexes[id3] = index3 + 1;
            }
          }
          return this;
        };
        _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
          var found = void 0;
          this.each(function(node3) {
            if (node3.atPosition) {
              var foundChild = node3.atPosition(line, col);
              if (foundChild) {
                found = foundChild;
                return false;
              }
            } else if (node3.isAtPosition(line, col)) {
              found = node3;
              return false;
            }
          });
          return found;
        };
        _proto.atPosition = function atPosition(line, col) {
          if (this.isAtPosition(line, col)) {
            return this._findChildAtPosition(line, col) || this;
          } else {
            return void 0;
          }
        };
        _proto._inferEndPosition = function _inferEndPosition() {
          if (this.last && this.last.source && this.last.source.end) {
            this.source = this.source || {};
            this.source.end = this.source.end || {};
            Object.assign(this.source.end, this.last.source.end);
          }
        };
        _proto.each = function each(callback) {
          if (!this.lastEach) {
            this.lastEach = 0;
          }
          if (!this.indexes) {
            this.indexes = {};
          }
          this.lastEach++;
          var id3 = this.lastEach;
          this.indexes[id3] = 0;
          if (!this.length) {
            return void 0;
          }
          var index3, result;
          while (this.indexes[id3] < this.length) {
            index3 = this.indexes[id3];
            result = callback(this.at(index3), index3);
            if (result === false) {
              break;
            }
            this.indexes[id3] += 1;
          }
          delete this.indexes[id3];
          if (result === false) {
            return false;
          }
        };
        _proto.walk = function walk3(callback) {
          return this.each(function(node3, i14) {
            var result = callback(node3, i14);
            if (result !== false && node3.length) {
              result = node3.walk(callback);
            }
            if (result === false) {
              return false;
            }
          });
        };
        _proto.walkAttributes = function walkAttributes(callback) {
          var _this2 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.ATTRIBUTE) {
              return callback.call(_this2, selector3);
            }
          });
        };
        _proto.walkClasses = function walkClasses(callback) {
          var _this3 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.CLASS) {
              return callback.call(_this3, selector3);
            }
          });
        };
        _proto.walkCombinators = function walkCombinators(callback) {
          var _this4 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.COMBINATOR) {
              return callback.call(_this4, selector3);
            }
          });
        };
        _proto.walkComments = function walkComments(callback) {
          var _this5 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.COMMENT) {
              return callback.call(_this5, selector3);
            }
          });
        };
        _proto.walkIds = function walkIds(callback) {
          var _this6 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.ID) {
              return callback.call(_this6, selector3);
            }
          });
        };
        _proto.walkNesting = function walkNesting(callback) {
          var _this7 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.NESTING) {
              return callback.call(_this7, selector3);
            }
          });
        };
        _proto.walkPseudos = function walkPseudos(callback) {
          var _this8 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.PSEUDO) {
              return callback.call(_this8, selector3);
            }
          });
        };
        _proto.walkTags = function walkTags(callback) {
          var _this9 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.TAG) {
              return callback.call(_this9, selector3);
            }
          });
        };
        _proto.walkUniversals = function walkUniversals(callback) {
          var _this10 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.UNIVERSAL) {
              return callback.call(_this10, selector3);
            }
          });
        };
        _proto.split = function split(callback) {
          var _this11 = this;
          var current = [];
          return this.reduce(function(memo, node3, index3) {
            var split2 = callback.call(_this11, node3);
            current.push(node3);
            if (split2) {
              memo.push(current);
              current = [];
            } else if (index3 === _this11.length - 1) {
              memo.push(current);
            }
            return memo;
          }, []);
        };
        _proto.map = function map(callback) {
          return this.nodes.map(callback);
        };
        _proto.reduce = function reduce(callback, memo) {
          return this.nodes.reduce(callback, memo);
        };
        _proto.every = function every(callback) {
          return this.nodes.every(callback);
        };
        _proto.some = function some(callback) {
          return this.nodes.some(callback);
        };
        _proto.filter = function filter2(callback) {
          return this.nodes.filter(callback);
        };
        _proto.sort = function sort(callback) {
          return this.nodes.sort(callback);
        };
        _proto.toString = function toString2() {
          return this.map(String).join("");
        };
        _createClass(Container2, [{
          key: "first",
          get: function get() {
            return this.at(0);
          }
        }, {
          key: "last",
          get: function get() {
            return this.at(this.length - 1);
          }
        }, {
          key: "length",
          get: function get() {
            return this.nodes.length;
          }
        }]);
        return Container2;
      }(_node["default"]);
      exports4["default"] = Container;
      module3.exports = exports4.default;
    })(container, container.exports);
    containerExports = container.exports;
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _container = _interopRequireDefault2(containerExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i14 = 0; i14 < props.length; i14++) {
          var descriptor = props[i14];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o10, p20) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p21) {
          o11.__proto__ = p21;
          return o11;
        };
        return _setPrototypeOf(o10, p20);
      }
      var Root = /* @__PURE__ */ function(_Container) {
        _inheritsLoose(Root2, _Container);
        function Root2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types2.ROOT;
          return _this;
        }
        var _proto = Root2.prototype;
        _proto.toString = function toString2() {
          var str2 = this.reduce(function(memo, selector3) {
            memo.push(String(selector3));
            return memo;
          }, []).join(",");
          return this.trailingComma ? str2 + "," : str2;
        };
        _proto.error = function error2(message, options2) {
          if (this._error) {
            return this._error(message, options2);
          } else {
            return new Error(message);
          }
        };
        _createClass(Root2, [{
          key: "errorGenerator",
          set: function set2(handler) {
            this._error = handler;
          }
        }]);
        return Root2;
      }(_container["default"]);
      exports4["default"] = Root;
      module3.exports = exports4.default;
    })(root$1, root$1.exports);
    rootExports = root$1.exports;
    selector$1 = { exports: {} };
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _container = _interopRequireDefault2(containerExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o10, p20) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p21) {
          o11.__proto__ = p21;
          return o11;
        };
        return _setPrototypeOf(o10, p20);
      }
      var Selector = /* @__PURE__ */ function(_Container) {
        _inheritsLoose(Selector2, _Container);
        function Selector2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types2.SELECTOR;
          return _this;
        }
        return Selector2;
      }(_container["default"]);
      exports4["default"] = Selector;
      module3.exports = exports4.default;
    })(selector$1, selector$1.exports);
    selectorExports = selector$1.exports;
    className$1 = { exports: {} };
    object = {};
    hasOwnProperty$1 = object.hasOwnProperty;
    merge = function merge2(options2, defaults2) {
      if (!options2) {
        return defaults2;
      }
      var result = {};
      for (var key in defaults2) {
        result[key] = hasOwnProperty$1.call(options2, key) ? options2[key] : defaults2[key];
      }
      return result;
    };
    regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
    regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
    regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
    cssesc = function cssesc2(string4, options2) {
      options2 = merge(options2, cssesc2.options);
      if (options2.quotes != "single" && options2.quotes != "double") {
        options2.quotes = "single";
      }
      var quote3 = options2.quotes == "double" ? '"' : "'";
      var isIdentifier2 = options2.isIdentifier;
      var firstChar = string4.charAt(0);
      var output = "";
      var counter = 0;
      var length = string4.length;
      while (counter < length) {
        var character = string4.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value2 = void 0;
        if (codePoint < 32 || codePoint > 126) {
          if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
            var extra = string4.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
            } else {
              counter--;
            }
          }
          value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else {
          if (options2.escapeEverything) {
            if (regexAnySingleEscape.test(character)) {
              value2 = "\\" + character;
            } else {
              value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
            }
          } else if (/[\t\n\f\r\x0B]/.test(character)) {
            value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else if (character == "\\" || !isIdentifier2 && (character == '"' && quote3 == character || character == "'" && quote3 == character) || isIdentifier2 && regexSingleEscape.test(character)) {
            value2 = "\\" + character;
          } else {
            value2 = character;
          }
        }
        output += value2;
      }
      if (isIdentifier2) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        } else if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      output = output.replace(regexExcessiveSpaces, function($0, $1, $22) {
        if ($1 && $1.length % 2) {
          return $0;
        }
        return ($1 || "") + $22;
      });
      if (!isIdentifier2 && options2.wrap) {
        return quote3 + output + quote3;
      }
      return output;
    };
    cssesc.options = {
      "escapeEverything": false,
      "isIdentifier": false,
      "quotes": "single",
      "wrap": false
    };
    cssesc.version = "3.0.0";
    cssesc_1 = cssesc;
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _cssesc = _interopRequireDefault2(cssesc_1);
      var _util = util;
      var _node = _interopRequireDefault2(nodeExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i14 = 0; i14 < props.length; i14++) {
          var descriptor = props[i14];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o10, p20) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p21) {
          o11.__proto__ = p21;
          return o11;
        };
        return _setPrototypeOf(o10, p20);
      }
      var ClassName = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(ClassName2, _Node);
        function ClassName2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.CLASS;
          _this._constructed = true;
          return _this;
        }
        var _proto = ClassName2.prototype;
        _proto.valueToString = function valueToString() {
          return "." + _Node.prototype.valueToString.call(this);
        };
        _createClass(ClassName2, [{
          key: "value",
          get: function get() {
            return this._value;
          },
          set: function set2(v15) {
            if (this._constructed) {
              var escaped2 = (0, _cssesc["default"])(v15, {
                isIdentifier: true
              });
              if (escaped2 !== v15) {
                (0, _util.ensureObject)(this, "raws");
                this.raws.value = escaped2;
              } else if (this.raws) {
                delete this.raws.value;
              }
            }
            this._value = v15;
          }
        }]);
        return ClassName2;
      }(_node["default"]);
      exports4["default"] = ClassName;
      module3.exports = exports4.default;
    })(className$1, className$1.exports);
    classNameExports = className$1.exports;
    comment$2 = { exports: {} };
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _node = _interopRequireDefault2(nodeExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o10, p20) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p21) {
          o11.__proto__ = p21;
          return o11;
        };
        return _setPrototypeOf(o10, p20);
      }
      var Comment = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Comment2, _Node);
        function Comment2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.COMMENT;
          return _this;
        }
        return Comment2;
      }(_node["default"]);
      exports4["default"] = Comment;
      module3.exports = exports4.default;
    })(comment$2, comment$2.exports);
    commentExports = comment$2.exports;
    id$1 = { exports: {} };
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _node = _interopRequireDefault2(nodeExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o10, p20) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p21) {
          o11.__proto__ = p21;
          return o11;
        };
        return _setPrototypeOf(o10, p20);
      }
      var ID2 = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(ID3, _Node);
        function ID3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.ID;
          return _this;
        }
        var _proto = ID3.prototype;
        _proto.valueToString = function valueToString() {
          return "#" + _Node.prototype.valueToString.call(this);
        };
        return ID3;
      }(_node["default"]);
      exports4["default"] = ID2;
      module3.exports = exports4.default;
    })(id$1, id$1.exports);
    idExports = id$1.exports;
    tag$1 = { exports: {} };
    namespace = { exports: {} };
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _cssesc = _interopRequireDefault2(cssesc_1);
      var _util = util;
      var _node = _interopRequireDefault2(nodeExports);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i14 = 0; i14 < props.length; i14++) {
          var descriptor = props[i14];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o10, p20) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p21) {
          o11.__proto__ = p21;
          return o11;
        };
        return _setPrototypeOf(o10, p20);
      }
      var Namespace = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Namespace2, _Node);
        function Namespace2() {
          return _Node.apply(this, arguments) || this;
        }
        var _proto = Namespace2.prototype;
        _proto.qualifiedName = function qualifiedName(value2) {
          if (this.namespace) {
            return this.namespaceString + "|" + value2;
          } else {
            return value2;
          }
        };
        _proto.valueToString = function valueToString() {
          return this.qualifiedName(_Node.prototype.valueToString.call(this));
        };
        _createClass(Namespace2, [{
          key: "namespace",
          get: function get() {
            return this._namespace;
          },
          set: function set2(namespace2) {
            if (namespace2 === true || namespace2 === "*" || namespace2 === "&") {
              this._namespace = namespace2;
              if (this.raws) {
                delete this.raws.namespace;
              }
              return;
            }
            var escaped2 = (0, _cssesc["default"])(namespace2, {
              isIdentifier: true
            });
            this._namespace = namespace2;
            if (escaped2 !== namespace2) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.namespace = escaped2;
            } else if (this.raws) {
              delete this.raws.namespace;
            }
          }
        }, {
          key: "ns",
          get: function get() {
            return this._namespace;
          },
          set: function set2(namespace2) {
            this.namespace = namespace2;
          }
        }, {
          key: "namespaceString",
          get: function get() {
            if (this.namespace) {
              var ns = this.stringifyProperty("namespace");
              if (ns === true) {
                return "";
              } else {
                return ns;
              }
            } else {
              return "";
            }
          }
        }]);
        return Namespace2;
      }(_node["default"]);
      exports4["default"] = Namespace;
      module3.exports = exports4.default;
    })(namespace, namespace.exports);
    namespaceExports = namespace.exports;
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _namespace = _interopRequireDefault2(namespaceExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o10, p20) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p21) {
          o11.__proto__ = p21;
          return o11;
        };
        return _setPrototypeOf(o10, p20);
      }
      var Tag = /* @__PURE__ */ function(_Namespace) {
        _inheritsLoose(Tag2, _Namespace);
        function Tag2(opts) {
          var _this;
          _this = _Namespace.call(this, opts) || this;
          _this.type = _types2.TAG;
          return _this;
        }
        return Tag2;
      }(_namespace["default"]);
      exports4["default"] = Tag;
      module3.exports = exports4.default;
    })(tag$1, tag$1.exports);
    tagExports = tag$1.exports;
    string$1 = { exports: {} };
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _node = _interopRequireDefault2(nodeExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o10, p20) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p21) {
          o11.__proto__ = p21;
          return o11;
        };
        return _setPrototypeOf(o10, p20);
      }
      var String2 = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(String3, _Node);
        function String3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.STRING;
          return _this;
        }
        return String3;
      }(_node["default"]);
      exports4["default"] = String2;
      module3.exports = exports4.default;
    })(string$1, string$1.exports);
    stringExports = string$1.exports;
    pseudo$1 = { exports: {} };
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _container = _interopRequireDefault2(containerExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o10, p20) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p21) {
          o11.__proto__ = p21;
          return o11;
        };
        return _setPrototypeOf(o10, p20);
      }
      var Pseudo = /* @__PURE__ */ function(_Container) {
        _inheritsLoose(Pseudo2, _Container);
        function Pseudo2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types2.PSEUDO;
          return _this;
        }
        var _proto = Pseudo2.prototype;
        _proto.toString = function toString2() {
          var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
          return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
        };
        return Pseudo2;
      }(_container["default"]);
      exports4["default"] = Pseudo;
      module3.exports = exports4.default;
    })(pseudo$1, pseudo$1.exports);
    pseudoExports = pseudo$1.exports;
    attribute$1 = {};
    node = require$$0$2.deprecate;
    (function(exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      exports4.unescapeValue = unescapeValue;
      var _cssesc = _interopRequireDefault2(cssesc_1);
      var _unesc2 = _interopRequireDefault2(unescExports);
      var _namespace = _interopRequireDefault2(namespaceExports);
      var _types2 = types;
      var _CSSESC_QUOTE_OPTIONS;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i14 = 0; i14 < props.length; i14++) {
          var descriptor = props[i14];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o10, p20) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p21) {
          o11.__proto__ = p21;
          return o11;
        };
        return _setPrototypeOf(o10, p20);
      }
      var deprecate = node;
      var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
      var warnOfDeprecatedValueAssignment = deprecate(function() {
      }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
      var warnOfDeprecatedQuotedAssignment = deprecate(function() {
      }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
      var warnOfDeprecatedConstructor = deprecate(function() {
      }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
      function unescapeValue(value2) {
        var deprecatedUsage = false;
        var quoteMark = null;
        var unescaped = value2;
        var m23 = unescaped.match(WRAPPED_IN_QUOTES);
        if (m23) {
          quoteMark = m23[1];
          unescaped = m23[2];
        }
        unescaped = (0, _unesc2["default"])(unescaped);
        if (unescaped !== value2) {
          deprecatedUsage = true;
        }
        return {
          deprecatedUsage,
          unescaped,
          quoteMark
        };
      }
      function handleDeprecatedContructorOpts(opts) {
        if (opts.quoteMark !== void 0) {
          return opts;
        }
        if (opts.value === void 0) {
          return opts;
        }
        warnOfDeprecatedConstructor();
        var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
        if (!opts.raws) {
          opts.raws = {};
        }
        if (opts.raws.value === void 0) {
          opts.raws.value = opts.value;
        }
        opts.value = unescaped;
        opts.quoteMark = quoteMark;
        return opts;
      }
      var Attribute = /* @__PURE__ */ function(_Namespace) {
        _inheritsLoose(Attribute2, _Namespace);
        function Attribute2(opts) {
          var _this;
          if (opts === void 0) {
            opts = {};
          }
          _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
          _this.type = _types2.ATTRIBUTE;
          _this.raws = _this.raws || {};
          Object.defineProperty(_this.raws, "unquoted", {
            get: deprecate(function() {
              return _this.value;
            }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
            set: deprecate(function() {
              return _this.value;
            }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
          });
          _this._constructed = true;
          return _this;
        }
        var _proto = Attribute2.prototype;
        _proto.getQuotedValue = function getQuotedValue(options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var quoteMark = this._determineQuoteMark(options2);
          var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
          var escaped2 = (0, _cssesc["default"])(this._value, cssescopts);
          return escaped2;
        };
        _proto._determineQuoteMark = function _determineQuoteMark(options2) {
          return options2.smart ? this.smartQuoteMark(options2) : this.preferredQuoteMark(options2);
        };
        _proto.setValue = function setValue(value2, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          this._value = value2;
          this._quoteMark = this._determineQuoteMark(options2);
          this._syncRawValue();
        };
        _proto.smartQuoteMark = function smartQuoteMark(options2) {
          var v15 = this.value;
          var numSingleQuotes = v15.replace(/[^']/g, "").length;
          var numDoubleQuotes = v15.replace(/[^"]/g, "").length;
          if (numSingleQuotes + numDoubleQuotes === 0) {
            var escaped2 = (0, _cssesc["default"])(v15, {
              isIdentifier: true
            });
            if (escaped2 === v15) {
              return Attribute2.NO_QUOTE;
            } else {
              var pref = this.preferredQuoteMark(options2);
              if (pref === Attribute2.NO_QUOTE) {
                var quote3 = this.quoteMark || options2.quoteMark || Attribute2.DOUBLE_QUOTE;
                var opts = CSSESC_QUOTE_OPTIONS[quote3];
                var quoteValue = (0, _cssesc["default"])(v15, opts);
                if (quoteValue.length < escaped2.length) {
                  return quote3;
                }
              }
              return pref;
            }
          } else if (numDoubleQuotes === numSingleQuotes) {
            return this.preferredQuoteMark(options2);
          } else if (numDoubleQuotes < numSingleQuotes) {
            return Attribute2.DOUBLE_QUOTE;
          } else {
            return Attribute2.SINGLE_QUOTE;
          }
        };
        _proto.preferredQuoteMark = function preferredQuoteMark(options2) {
          var quoteMark = options2.preferCurrentQuoteMark ? this.quoteMark : options2.quoteMark;
          if (quoteMark === void 0) {
            quoteMark = options2.preferCurrentQuoteMark ? options2.quoteMark : this.quoteMark;
          }
          if (quoteMark === void 0) {
            quoteMark = Attribute2.DOUBLE_QUOTE;
          }
          return quoteMark;
        };
        _proto._syncRawValue = function _syncRawValue() {
          var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
          if (rawValue === this._value) {
            if (this.raws) {
              delete this.raws.value;
            }
          } else {
            this.raws.value = rawValue;
          }
        };
        _proto._handleEscapes = function _handleEscapes(prop, value2) {
          if (this._constructed) {
            var escaped2 = (0, _cssesc["default"])(value2, {
              isIdentifier: true
            });
            if (escaped2 !== value2) {
              this.raws[prop] = escaped2;
            } else {
              delete this.raws[prop];
            }
          }
        };
        _proto._spacesFor = function _spacesFor(name2) {
          var attrSpaces = {
            before: "",
            after: ""
          };
          var spaces2 = this.spaces[name2] || {};
          var rawSpaces = this.raws.spaces && this.raws.spaces[name2] || {};
          return Object.assign(attrSpaces, spaces2, rawSpaces);
        };
        _proto._stringFor = function _stringFor(name2, spaceName, concat2) {
          if (spaceName === void 0) {
            spaceName = name2;
          }
          if (concat2 === void 0) {
            concat2 = defaultAttrConcat;
          }
          var attrSpaces = this._spacesFor(spaceName);
          return concat2(this.stringifyProperty(name2), attrSpaces);
        };
        _proto.offsetOf = function offsetOf(name2) {
          var count = 1;
          var attributeSpaces = this._spacesFor("attribute");
          count += attributeSpaces.before.length;
          if (name2 === "namespace" || name2 === "ns") {
            return this.namespace ? count : -1;
          }
          if (name2 === "attributeNS") {
            return count;
          }
          count += this.namespaceString.length;
          if (this.namespace) {
            count += 1;
          }
          if (name2 === "attribute") {
            return count;
          }
          count += this.stringifyProperty("attribute").length;
          count += attributeSpaces.after.length;
          var operatorSpaces = this._spacesFor("operator");
          count += operatorSpaces.before.length;
          var operator = this.stringifyProperty("operator");
          if (name2 === "operator") {
            return operator ? count : -1;
          }
          count += operator.length;
          count += operatorSpaces.after.length;
          var valueSpaces = this._spacesFor("value");
          count += valueSpaces.before.length;
          var value2 = this.stringifyProperty("value");
          if (name2 === "value") {
            return value2 ? count : -1;
          }
          count += value2.length;
          count += valueSpaces.after.length;
          var insensitiveSpaces = this._spacesFor("insensitive");
          count += insensitiveSpaces.before.length;
          if (name2 === "insensitive") {
            return this.insensitive ? count : -1;
          }
          return -1;
        };
        _proto.toString = function toString2() {
          var _this2 = this;
          var selector3 = [this.rawSpaceBefore, "["];
          selector3.push(this._stringFor("qualifiedAttribute", "attribute"));
          if (this.operator && (this.value || this.value === "")) {
            selector3.push(this._stringFor("operator"));
            selector3.push(this._stringFor("value"));
            selector3.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
              if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
                attrSpaces.before = " ";
              }
              return defaultAttrConcat(attrValue, attrSpaces);
            }));
          }
          selector3.push("]");
          selector3.push(this.rawSpaceAfter);
          return selector3.join("");
        };
        _createClass(Attribute2, [{
          key: "quoted",
          get: function get() {
            var qm = this.quoteMark;
            return qm === "'" || qm === '"';
          },
          set: function set2(value2) {
            warnOfDeprecatedQuotedAssignment();
          }
          /**
           * returns a single (`'`) or double (`"`) quote character if the value is quoted.
           * returns `null` if the value is not quoted.
           * returns `undefined` if the quotation state is unknown (this can happen when
           * the attribute is constructed without specifying a quote mark.)
           */
        }, {
          key: "quoteMark",
          get: function get() {
            return this._quoteMark;
          },
          set: function set2(quoteMark) {
            if (!this._constructed) {
              this._quoteMark = quoteMark;
              return;
            }
            if (this._quoteMark !== quoteMark) {
              this._quoteMark = quoteMark;
              this._syncRawValue();
            }
          }
        }, {
          key: "qualifiedAttribute",
          get: function get() {
            return this.qualifiedName(this.raws.attribute || this.attribute);
          }
        }, {
          key: "insensitiveFlag",
          get: function get() {
            return this.insensitive ? "i" : "";
          }
        }, {
          key: "value",
          get: function get() {
            return this._value;
          },
          set: (
            /**
             * Before 3.0, the value had to be set to an escaped value including any wrapped
             * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
             * is unescaped during parsing and any quote marks are removed.
             *
             * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
             * a deprecation warning is raised when the new value contains any characters that would
             * require escaping (including if it contains wrapped quotes).
             *
             * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
             * how the new value is quoted.
             */
            function set2(v15) {
              if (this._constructed) {
                var _unescapeValue2 = unescapeValue(v15), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
                if (deprecatedUsage) {
                  warnOfDeprecatedValueAssignment();
                }
                if (unescaped === this._value && quoteMark === this._quoteMark) {
                  return;
                }
                this._value = unescaped;
                this._quoteMark = quoteMark;
                this._syncRawValue();
              } else {
                this._value = v15;
              }
            }
          )
        }, {
          key: "insensitive",
          get: function get() {
            return this._insensitive;
          },
          set: function set2(insensitive) {
            if (!insensitive) {
              this._insensitive = false;
              if (this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i")) {
                this.raws.insensitiveFlag = void 0;
              }
            }
            this._insensitive = insensitive;
          }
        }, {
          key: "attribute",
          get: function get() {
            return this._attribute;
          },
          set: function set2(name2) {
            this._handleEscapes("attribute", name2);
            this._attribute = name2;
          }
        }]);
        return Attribute2;
      }(_namespace["default"]);
      exports4["default"] = Attribute;
      Attribute.NO_QUOTE = null;
      Attribute.SINGLE_QUOTE = "'";
      Attribute.DOUBLE_QUOTE = '"';
      var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
        "'": {
          quotes: "single",
          wrap: true
        },
        '"': {
          quotes: "double",
          wrap: true
        }
      }, _CSSESC_QUOTE_OPTIONS[null] = {
        isIdentifier: true
      }, _CSSESC_QUOTE_OPTIONS);
      function defaultAttrConcat(attrValue, attrSpaces) {
        return "" + attrSpaces.before + attrValue + attrSpaces.after;
      }
    })(attribute$1);
    universal$1 = { exports: {} };
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _namespace = _interopRequireDefault2(namespaceExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o10, p20) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p21) {
          o11.__proto__ = p21;
          return o11;
        };
        return _setPrototypeOf(o10, p20);
      }
      var Universal = /* @__PURE__ */ function(_Namespace) {
        _inheritsLoose(Universal2, _Namespace);
        function Universal2(opts) {
          var _this;
          _this = _Namespace.call(this, opts) || this;
          _this.type = _types2.UNIVERSAL;
          _this.value = "*";
          return _this;
        }
        return Universal2;
      }(_namespace["default"]);
      exports4["default"] = Universal;
      module3.exports = exports4.default;
    })(universal$1, universal$1.exports);
    universalExports = universal$1.exports;
    combinator$2 = { exports: {} };
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _node = _interopRequireDefault2(nodeExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o10, p20) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p21) {
          o11.__proto__ = p21;
          return o11;
        };
        return _setPrototypeOf(o10, p20);
      }
      var Combinator = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Combinator2, _Node);
        function Combinator2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.COMBINATOR;
          return _this;
        }
        return Combinator2;
      }(_node["default"]);
      exports4["default"] = Combinator;
      module3.exports = exports4.default;
    })(combinator$2, combinator$2.exports);
    combinatorExports = combinator$2.exports;
    nesting$1 = { exports: {} };
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _node = _interopRequireDefault2(nodeExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o10, p20) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o11, p21) {
          o11.__proto__ = p21;
          return o11;
        };
        return _setPrototypeOf(o10, p20);
      }
      var Nesting = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Nesting2, _Node);
        function Nesting2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.NESTING;
          _this.value = "&";
          return _this;
        }
        return Nesting2;
      }(_node["default"]);
      exports4["default"] = Nesting;
      module3.exports = exports4.default;
    })(nesting$1, nesting$1.exports);
    nestingExports = nesting$1.exports;
    sortAscending = { exports: {} };
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = sortAscending2;
      function sortAscending2(list) {
        return list.sort(function(a20, b18) {
          return a20 - b18;
        });
      }
      module3.exports = exports4.default;
    })(sortAscending, sortAscending.exports);
    sortAscendingExports = sortAscending.exports;
    tokenize = {};
    tokenTypes = {};
    tokenTypes.__esModule = true;
    tokenTypes.word = tokenTypes.tilde = tokenTypes.tab = tokenTypes.str = tokenTypes.space = tokenTypes.slash = tokenTypes.singleQuote = tokenTypes.semicolon = tokenTypes.plus = tokenTypes.pipe = tokenTypes.openSquare = tokenTypes.openParenthesis = tokenTypes.newline = tokenTypes.greaterThan = tokenTypes.feed = tokenTypes.equals = tokenTypes.doubleQuote = tokenTypes.dollar = tokenTypes.cr = tokenTypes.comment = tokenTypes.comma = tokenTypes.combinator = tokenTypes.colon = tokenTypes.closeSquare = tokenTypes.closeParenthesis = tokenTypes.caret = tokenTypes.bang = tokenTypes.backslash = tokenTypes.at = tokenTypes.asterisk = tokenTypes.ampersand = void 0;
    ampersand = 38;
    tokenTypes.ampersand = ampersand;
    asterisk = 42;
    tokenTypes.asterisk = asterisk;
    at = 64;
    tokenTypes.at = at;
    comma2 = 44;
    tokenTypes.comma = comma2;
    colon2 = 58;
    tokenTypes.colon = colon2;
    semicolon = 59;
    tokenTypes.semicolon = semicolon;
    openParenthesis = 40;
    tokenTypes.openParenthesis = openParenthesis;
    closeParenthesis = 41;
    tokenTypes.closeParenthesis = closeParenthesis;
    openSquare = 91;
    tokenTypes.openSquare = openSquare;
    closeSquare = 93;
    tokenTypes.closeSquare = closeSquare;
    dollar = 36;
    tokenTypes.dollar = dollar;
    tilde = 126;
    tokenTypes.tilde = tilde;
    caret = 94;
    tokenTypes.caret = caret;
    plus2 = 43;
    tokenTypes.plus = plus2;
    equals = 61;
    tokenTypes.equals = equals;
    pipe = 124;
    tokenTypes.pipe = pipe;
    greaterThan = 62;
    tokenTypes.greaterThan = greaterThan;
    space = 32;
    tokenTypes.space = space;
    singleQuote2 = 39;
    tokenTypes.singleQuote = singleQuote2;
    doubleQuote2 = 34;
    tokenTypes.doubleQuote = doubleQuote2;
    slash2 = 47;
    tokenTypes.slash = slash2;
    bang = 33;
    tokenTypes.bang = bang;
    backslash2 = 92;
    tokenTypes.backslash = backslash2;
    cr = 13;
    tokenTypes.cr = cr;
    feed = 12;
    tokenTypes.feed = feed;
    newline = 10;
    tokenTypes.newline = newline;
    tab = 9;
    tokenTypes.tab = tab;
    str = singleQuote2;
    tokenTypes.str = str;
    comment$1 = -1;
    tokenTypes.comment = comment$1;
    word = -2;
    tokenTypes.word = word;
    combinator$1 = -3;
    tokenTypes.combinator = combinator$1;
    (function(exports4) {
      exports4.__esModule = true;
      exports4.FIELDS = void 0;
      exports4["default"] = tokenize2;
      var t = _interopRequireWildcard(tokenTypes);
      var _unescapable, _wordDelimiters;
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
      var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
      var hex = {};
      var hexChars = "0123456789abcdefABCDEF";
      for (var i14 = 0; i14 < hexChars.length; i14++) {
        hex[hexChars.charCodeAt(i14)] = true;
      }
      function consumeWord(css, start2) {
        var next = start2;
        var code;
        do {
          code = css.charCodeAt(next);
          if (wordDelimiters[code]) {
            return next - 1;
          } else if (code === t.backslash) {
            next = consumeEscape(css, next) + 1;
          } else {
            next++;
          }
        } while (next < css.length);
        return next - 1;
      }
      function consumeEscape(css, start2) {
        var next = start2;
        var code = css.charCodeAt(next + 1);
        if (unescapable[code]) ;
        else if (hex[code]) {
          var hexDigits2 = 0;
          do {
            next++;
            hexDigits2++;
            code = css.charCodeAt(next + 1);
          } while (hex[code] && hexDigits2 < 6);
          if (hexDigits2 < 6 && code === t.space) {
            next++;
          }
        } else {
          next++;
        }
        return next;
      }
      var FIELDS = {
        TYPE: 0,
        START_LINE: 1,
        START_COL: 2,
        END_LINE: 3,
        END_COL: 4,
        START_POS: 5,
        END_POS: 6
      };
      exports4.FIELDS = FIELDS;
      function tokenize2(input) {
        var tokens = [];
        var css = input.css.valueOf();
        var _css = css, length = _css.length;
        var offset = -1;
        var line = 1;
        var start2 = 0;
        var end = 0;
        var code, content, endColumn, endLine, escaped2, escapePos, last, lines, next, nextLine, nextOffset, quote3, tokenType2;
        function unclosed(what, fix) {
          if (input.safe) {
            css += fix;
            next = css.length - 1;
          } else {
            throw input.error("Unclosed " + what, line, start2 - offset, start2);
          }
        }
        while (start2 < length) {
          code = css.charCodeAt(start2);
          if (code === t.newline) {
            offset = start2;
            line += 1;
          }
          switch (code) {
            case t.space:
            case t.tab:
            case t.newline:
            case t.cr:
            case t.feed:
              next = start2;
              do {
                next += 1;
                code = css.charCodeAt(next);
                if (code === t.newline) {
                  offset = next;
                  line += 1;
                }
              } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);
              tokenType2 = t.space;
              endLine = line;
              endColumn = next - offset - 1;
              end = next;
              break;
            case t.plus:
            case t.greaterThan:
            case t.tilde:
            case t.pipe:
              next = start2;
              do {
                next += 1;
                code = css.charCodeAt(next);
              } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);
              tokenType2 = t.combinator;
              endLine = line;
              endColumn = start2 - offset;
              end = next;
              break;
            // Consume these characters as single tokens.
            case t.asterisk:
            case t.ampersand:
            case t.bang:
            case t.comma:
            case t.equals:
            case t.dollar:
            case t.caret:
            case t.openSquare:
            case t.closeSquare:
            case t.colon:
            case t.semicolon:
            case t.openParenthesis:
            case t.closeParenthesis:
              next = start2;
              tokenType2 = code;
              endLine = line;
              endColumn = start2 - offset;
              end = next + 1;
              break;
            case t.singleQuote:
            case t.doubleQuote:
              quote3 = code === t.singleQuote ? "'" : '"';
              next = start2;
              do {
                escaped2 = false;
                next = css.indexOf(quote3, next + 1);
                if (next === -1) {
                  unclosed("quote", quote3);
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === t.backslash) {
                  escapePos -= 1;
                  escaped2 = !escaped2;
                }
              } while (escaped2);
              tokenType2 = t.str;
              endLine = line;
              endColumn = start2 - offset;
              end = next + 1;
              break;
            default:
              if (code === t.slash && css.charCodeAt(start2 + 1) === t.asterisk) {
                next = css.indexOf("*/", start2 + 2) + 1;
                if (next === 0) {
                  unclosed("comment", "*/");
                }
                content = css.slice(start2, next + 1);
                lines = content.split("\n");
                last = lines.length - 1;
                if (last > 0) {
                  nextLine = line + last;
                  nextOffset = next - lines[last].length;
                } else {
                  nextLine = line;
                  nextOffset = offset;
                }
                tokenType2 = t.comment;
                line = nextLine;
                endLine = nextLine;
                endColumn = next - nextOffset;
              } else if (code === t.slash) {
                next = start2;
                tokenType2 = code;
                endLine = line;
                endColumn = start2 - offset;
                end = next + 1;
              } else {
                next = consumeWord(css, start2);
                tokenType2 = t.word;
                endLine = line;
                endColumn = next - offset;
              }
              end = next + 1;
              break;
          }
          tokens.push([
            tokenType2,
            // [0] Token type
            line,
            // [1] Starting line
            start2 - offset,
            // [2] Starting column
            endLine,
            // [3] Ending line
            endColumn,
            // [4] Ending column
            start2,
            // [5] Start position / Source index
            end
            // [6] End position
          ]);
          if (nextOffset) {
            offset = nextOffset;
            nextOffset = null;
          }
          start2 = end;
        }
        return tokens;
      }
    })(tokenize);
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _root2 = _interopRequireDefault2(rootExports);
      var _selector2 = _interopRequireDefault2(selectorExports);
      var _className2 = _interopRequireDefault2(classNameExports);
      var _comment2 = _interopRequireDefault2(commentExports);
      var _id2 = _interopRequireDefault2(idExports);
      var _tag2 = _interopRequireDefault2(tagExports);
      var _string2 = _interopRequireDefault2(stringExports);
      var _pseudo2 = _interopRequireDefault2(pseudoExports);
      var _attribute2 = _interopRequireWildcard(attribute$1);
      var _universal2 = _interopRequireDefault2(universalExports);
      var _combinator2 = _interopRequireDefault2(combinatorExports);
      var _nesting2 = _interopRequireDefault2(nestingExports);
      var _sortAscending = _interopRequireDefault2(sortAscendingExports);
      var _tokenize = _interopRequireWildcard(tokenize);
      var tokens = _interopRequireWildcard(tokenTypes);
      var types$12 = _interopRequireWildcard(types);
      var _util = util;
      var _WHITESPACE_TOKENS, _Object$assign;
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i14 = 0; i14 < props.length; i14++) {
          var descriptor = props[i14];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
      var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
      function tokenStart(token) {
        return {
          line: token[_tokenize.FIELDS.START_LINE],
          column: token[_tokenize.FIELDS.START_COL]
        };
      }
      function tokenEnd(token) {
        return {
          line: token[_tokenize.FIELDS.END_LINE],
          column: token[_tokenize.FIELDS.END_COL]
        };
      }
      function getSource(startLine, startColumn, endLine, endColumn) {
        return {
          start: {
            line: startLine,
            column: startColumn
          },
          end: {
            line: endLine,
            column: endColumn
          }
        };
      }
      function getTokenSource(token) {
        return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
      }
      function getTokenSourceSpan(startToken, endToken) {
        if (!startToken) {
          return void 0;
        }
        return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
      }
      function unescapeProp(node3, prop) {
        var value2 = node3[prop];
        if (typeof value2 !== "string") {
          return;
        }
        if (value2.indexOf("\\") !== -1) {
          (0, _util.ensureObject)(node3, "raws");
          node3[prop] = (0, _util.unesc)(value2);
          if (node3.raws[prop] === void 0) {
            node3.raws[prop] = value2;
          }
        }
        return node3;
      }
      function indexesOf(array2, item) {
        var i14 = -1;
        var indexes = [];
        while ((i14 = array2.indexOf(item, i14 + 1)) !== -1) {
          indexes.push(i14);
        }
        return indexes;
      }
      function uniqs() {
        var list = Array.prototype.concat.apply([], arguments);
        return list.filter(function(item, i14) {
          return i14 === list.indexOf(item);
        });
      }
      var Parser3 = /* @__PURE__ */ function() {
        function Parser4(rule, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          this.rule = rule;
          this.options = Object.assign({
            lossy: false,
            safe: false
          }, options2);
          this.position = 0;
          this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
          this.tokens = (0, _tokenize["default"])({
            css: this.css,
            error: this._errorGenerator(),
            safe: this.options.safe
          });
          var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
          this.root = new _root2["default"]({
            source: rootSource
          });
          this.root.errorGenerator = this._errorGenerator();
          var selector3 = new _selector2["default"]({
            source: {
              start: {
                line: 1,
                column: 1
              }
            },
            sourceIndex: 0
          });
          this.root.append(selector3);
          this.current = selector3;
          this.loop();
        }
        var _proto = Parser4.prototype;
        _proto._errorGenerator = function _errorGenerator() {
          var _this = this;
          return function(message, errorOptions) {
            if (typeof _this.rule === "string") {
              return new Error(message);
            }
            return _this.rule.error(message, errorOptions);
          };
        };
        _proto.attribute = function attribute3() {
          var attr = [];
          var startingToken = this.currToken;
          this.position++;
          while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            attr.push(this.currToken);
            this.position++;
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
          }
          var len = attr.length;
          var node3 = {
            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
            sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
          };
          if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
            return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
          }
          var pos = 0;
          var spaceBefore = "";
          var commentBefore = "";
          var lastAdded = null;
          var spaceAfterMeaningfulToken = false;
          while (pos < len) {
            var token = attr[pos];
            var content = this.content(token);
            var next = attr[pos + 1];
            switch (token[_tokenize.FIELDS.TYPE]) {
              case tokens.space:
                spaceAfterMeaningfulToken = true;
                if (this.options.lossy) {
                  break;
                }
                if (lastAdded) {
                  (0, _util.ensureObject)(node3, "spaces", lastAdded);
                  var prevContent = node3.spaces[lastAdded].after || "";
                  node3.spaces[lastAdded].after = prevContent + content;
                  var existingComment = (0, _util.getProp)(node3, "raws", "spaces", lastAdded, "after") || null;
                  if (existingComment) {
                    node3.raws.spaces[lastAdded].after = existingComment + content;
                  }
                } else {
                  spaceBefore = spaceBefore + content;
                  commentBefore = commentBefore + content;
                }
                break;
              case tokens.asterisk:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content;
                  lastAdded = "operator";
                } else if ((!node3.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node3, "spaces", "attribute");
                    node3.spaces.attribute.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node3, "raws", "spaces", "attribute");
                    node3.raws.spaces.attribute.before = spaceBefore;
                    commentBefore = "";
                  }
                  node3.namespace = (node3.namespace || "") + content;
                  var rawValue = (0, _util.getProp)(node3, "raws", "namespace") || null;
                  if (rawValue) {
                    node3.raws.namespace += content;
                  }
                  lastAdded = "namespace";
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.dollar:
                if (lastAdded === "value") {
                  var oldRawValue = (0, _util.getProp)(node3, "raws", "value");
                  node3.value += "$";
                  if (oldRawValue) {
                    node3.raws.value = oldRawValue + "$";
                  }
                  break;
                }
              // Falls through
              case tokens.caret:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content;
                  lastAdded = "operator";
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.combinator:
                if (content === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content;
                  lastAdded = "operator";
                }
                if (content !== "|") {
                  spaceAfterMeaningfulToken = false;
                  break;
                }
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content;
                  lastAdded = "operator";
                } else if (!node3.namespace && !node3.attribute) {
                  node3.namespace = true;
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.word:
                if (next && this.content(next) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
                !node3.operator && !node3.namespace) {
                  node3.namespace = content;
                  lastAdded = "namespace";
                } else if (!node3.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node3, "spaces", "attribute");
                    node3.spaces.attribute.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node3, "raws", "spaces", "attribute");
                    node3.raws.spaces.attribute.before = commentBefore;
                    commentBefore = "";
                  }
                  node3.attribute = (node3.attribute || "") + content;
                  var _rawValue = (0, _util.getProp)(node3, "raws", "attribute") || null;
                  if (_rawValue) {
                    node3.raws.attribute += content;
                  }
                  lastAdded = "attribute";
                } else if (!node3.value && node3.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node3.quoteMark)) {
                  var _unescaped = (0, _util.unesc)(content);
                  var _oldRawValue = (0, _util.getProp)(node3, "raws", "value") || "";
                  var oldValue = node3.value || "";
                  node3.value = oldValue + _unescaped;
                  node3.quoteMark = null;
                  if (_unescaped !== content || _oldRawValue) {
                    (0, _util.ensureObject)(node3, "raws");
                    node3.raws.value = (_oldRawValue || oldValue) + content;
                  }
                  lastAdded = "value";
                } else {
                  var insensitive = content === "i" || content === "I";
                  if ((node3.value || node3.value === "") && (node3.quoteMark || spaceAfterMeaningfulToken)) {
                    node3.insensitive = insensitive;
                    if (!insensitive || content === "I") {
                      (0, _util.ensureObject)(node3, "raws");
                      node3.raws.insensitiveFlag = content;
                    }
                    lastAdded = "insensitive";
                    if (spaceBefore) {
                      (0, _util.ensureObject)(node3, "spaces", "insensitive");
                      node3.spaces.insensitive.before = spaceBefore;
                      spaceBefore = "";
                    }
                    if (commentBefore) {
                      (0, _util.ensureObject)(node3, "raws", "spaces", "insensitive");
                      node3.raws.spaces.insensitive.before = commentBefore;
                      commentBefore = "";
                    }
                  } else if (node3.value || node3.value === "") {
                    lastAdded = "value";
                    node3.value += content;
                    if (node3.raws.value) {
                      node3.raws.value += content;
                    }
                  }
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.str:
                if (!node3.attribute || !node3.operator) {
                  return this.error("Expected an attribute followed by an operator preceding the string.", {
                    index: token[_tokenize.FIELDS.START_POS]
                  });
                }
                var _unescapeValue = (0, _attribute2.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
                node3.value = unescaped;
                node3.quoteMark = quoteMark;
                lastAdded = "value";
                (0, _util.ensureObject)(node3, "raws");
                node3.raws.value = content;
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.equals:
                if (!node3.attribute) {
                  return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content);
                }
                if (node3.value) {
                  return this.error('Unexpected "=" found; an operator was already defined.', {
                    index: token[_tokenize.FIELDS.START_POS]
                  });
                }
                node3.operator = node3.operator ? node3.operator + content : content;
                lastAdded = "operator";
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.comment:
                if (lastAdded) {
                  if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                    var lastComment = (0, _util.getProp)(node3, "spaces", lastAdded, "after") || "";
                    var rawLastComment = (0, _util.getProp)(node3, "raws", "spaces", lastAdded, "after") || lastComment;
                    (0, _util.ensureObject)(node3, "raws", "spaces", lastAdded);
                    node3.raws.spaces[lastAdded].after = rawLastComment + content;
                  } else {
                    var lastValue = node3[lastAdded] || "";
                    var rawLastValue = (0, _util.getProp)(node3, "raws", lastAdded) || lastValue;
                    (0, _util.ensureObject)(node3, "raws");
                    node3.raws[lastAdded] = rawLastValue + content;
                  }
                } else {
                  commentBefore = commentBefore + content;
                }
                break;
              default:
                return this.error('Unexpected "' + content + '" found.', {
                  index: token[_tokenize.FIELDS.START_POS]
                });
            }
            pos++;
          }
          unescapeProp(node3, "attribute");
          unescapeProp(node3, "namespace");
          this.newNode(new _attribute2["default"](node3));
          this.position++;
        };
        _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
          if (stopPosition < 0) {
            stopPosition = this.tokens.length;
          }
          var startPosition = this.position;
          var nodes = [];
          var space2 = "";
          var lastComment = void 0;
          do {
            if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
              if (!this.options.lossy) {
                space2 += this.content();
              }
            } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
              var spaces2 = {};
              if (space2) {
                spaces2.before = space2;
                space2 = "";
              }
              lastComment = new _comment2["default"]({
                value: this.content(),
                source: getTokenSource(this.currToken),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                spaces: spaces2
              });
              nodes.push(lastComment);
            }
          } while (++this.position < stopPosition);
          if (space2) {
            if (lastComment) {
              lastComment.spaces.after = space2;
            } else if (!this.options.lossy) {
              var firstToken = this.tokens[startPosition];
              var lastToken = this.tokens[this.position - 1];
              nodes.push(new _string2["default"]({
                value: "",
                source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                spaces: {
                  before: space2,
                  after: ""
                }
              }));
            }
          }
          return nodes;
        };
        _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
          var _this2 = this;
          if (requiredSpace === void 0) {
            requiredSpace = false;
          }
          var space2 = "";
          var rawSpace = "";
          nodes.forEach(function(n14) {
            var spaceBefore = _this2.lossySpace(n14.spaces.before, requiredSpace);
            var rawSpaceBefore = _this2.lossySpace(n14.rawSpaceBefore, requiredSpace);
            space2 += spaceBefore + _this2.lossySpace(n14.spaces.after, requiredSpace && spaceBefore.length === 0);
            rawSpace += spaceBefore + n14.value + _this2.lossySpace(n14.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
          });
          if (rawSpace === space2) {
            rawSpace = void 0;
          }
          var result = {
            space: space2,
            rawSpace
          };
          return result;
        };
        _proto.isNamedCombinator = function isNamedCombinator(position) {
          if (position === void 0) {
            position = this.position;
          }
          return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
        };
        _proto.namedCombinator = function namedCombinator() {
          if (this.isNamedCombinator()) {
            var nameRaw = this.content(this.tokens[this.position + 1]);
            var name2 = (0, _util.unesc)(nameRaw).toLowerCase();
            var raws = {};
            if (name2 !== nameRaw) {
              raws.value = "/" + nameRaw + "/";
            }
            var node3 = new _combinator2["default"]({
              value: "/" + name2 + "/",
              source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              raws
            });
            this.position = this.position + 3;
            return node3;
          } else {
            this.unexpected();
          }
        };
        _proto.combinator = function combinator3() {
          var _this3 = this;
          if (this.content() === "|") {
            return this.namespace();
          }
          var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
          if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
            var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
            if (nodes.length > 0) {
              var last = this.current.last;
              if (last) {
                var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space2 = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
                if (rawSpace !== void 0) {
                  last.rawSpaceAfter += rawSpace;
                }
                last.spaces.after += space2;
              } else {
                nodes.forEach(function(n14) {
                  return _this3.newNode(n14);
                });
              }
            }
            return;
          }
          var firstToken = this.currToken;
          var spaceOrDescendantSelectorNodes = void 0;
          if (nextSigTokenPos > this.position) {
            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          }
          var node3;
          if (this.isNamedCombinator()) {
            node3 = this.namedCombinator();
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
            node3 = new _combinator2["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
            });
            this.position++;
          } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) ;
          else if (!spaceOrDescendantSelectorNodes) {
            this.unexpected();
          }
          if (node3) {
            if (spaceOrDescendantSelectorNodes) {
              var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
              node3.spaces.before = _space;
              node3.rawSpaceBefore = _rawSpace;
            }
          } else {
            var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
            if (!_rawSpace2) {
              _rawSpace2 = _space2;
            }
            var spaces2 = {};
            var raws = {
              spaces: {}
            };
            if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
              spaces2.before = _space2.slice(0, _space2.length - 1);
              raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
            } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
              spaces2.after = _space2.slice(1);
              raws.spaces.after = _rawSpace2.slice(1);
            } else {
              raws.value = _rawSpace2;
            }
            node3 = new _combinator2["default"]({
              value: " ",
              source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces: spaces2,
              raws
            });
          }
          if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
            node3.spaces.after = this.optionalSpace(this.content());
            this.position++;
          }
          return this.newNode(node3);
        };
        _proto.comma = function comma4() {
          if (this.position === this.tokens.length - 1) {
            this.root.trailingComma = true;
            this.position++;
            return;
          }
          this.current._inferEndPosition();
          var selector3 = new _selector2["default"]({
            source: {
              start: tokenStart(this.tokens[this.position + 1])
            },
            sourceIndex: this.tokens[this.position + 1][_tokenize.FIELDS.START_POS]
          });
          this.current.parent.append(selector3);
          this.current = selector3;
          this.position++;
        };
        _proto.comment = function comment3() {
          var current = this.currToken;
          this.newNode(new _comment2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.error = function error2(message, opts) {
          throw this.root.error(message, opts);
        };
        _proto.missingBackslash = function missingBackslash() {
          return this.error("Expected a backslash preceding the semicolon.", {
            index: this.currToken[_tokenize.FIELDS.START_POS]
          });
        };
        _proto.missingParenthesis = function missingParenthesis() {
          return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.missingSquareBracket = function missingSquareBracket() {
          return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.unexpected = function unexpected() {
          return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.unexpectedPipe = function unexpectedPipe() {
          return this.error("Unexpected '|'.", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.namespace = function namespace2() {
          var before = this.prevToken && this.content(this.prevToken) || true;
          if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.position++;
            return this.word(before);
          } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
            this.position++;
            return this.universal(before);
          }
          this.unexpectedPipe();
        };
        _proto.nesting = function nesting3() {
          if (this.nextToken) {
            var nextContent = this.content(this.nextToken);
            if (nextContent === "|") {
              this.position++;
              return;
            }
          }
          var current = this.currToken;
          this.newNode(new _nesting2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.parentheses = function parentheses() {
          var last = this.current.last;
          var unbalanced = 1;
          this.position++;
          if (last && last.type === types$12.PSEUDO) {
            var selector3 = new _selector2["default"]({
              source: {
                start: tokenStart(this.tokens[this.position])
              },
              sourceIndex: this.tokens[this.position][_tokenize.FIELDS.START_POS]
            });
            var cache2 = this.current;
            last.append(selector3);
            this.current = selector3;
            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }
              if (unbalanced) {
                this.parse();
              } else {
                this.current.source.end = tokenEnd(this.currToken);
                this.current.parent.source.end = tokenEnd(this.currToken);
                this.position++;
              }
            }
            this.current = cache2;
          } else {
            var parenStart = this.currToken;
            var parenValue = "(";
            var parenEnd;
            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }
              parenEnd = this.currToken;
              parenValue += this.parseParenthesisToken(this.currToken);
              this.position++;
            }
            if (last) {
              last.appendToPropertyAndEscape("value", parenValue, parenValue);
            } else {
              this.newNode(new _string2["default"]({
                value: parenValue,
                source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
                sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
              }));
            }
          }
          if (unbalanced) {
            return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };
        _proto.pseudo = function pseudo3() {
          var _this4 = this;
          var pseudoStr = "";
          var startingToken = this.currToken;
          while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
            pseudoStr += this.content();
            this.position++;
          }
          if (!this.currToken) {
            return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.splitWord(false, function(first2, length) {
              pseudoStr += first2;
              _this4.newNode(new _pseudo2["default"]({
                value: pseudoStr,
                source: getTokenSourceSpan(startingToken, _this4.currToken),
                sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
              }));
              if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                _this4.error("Misplaced parenthesis.", {
                  index: _this4.nextToken[_tokenize.FIELDS.START_POS]
                });
              }
            });
          } else {
            return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };
        _proto.space = function space2() {
          var content = this.content();
          if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node3) {
            return node3.type === "comment";
          })) {
            this.spaces = this.optionalSpace(content);
            this.position++;
          } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            this.current.last.spaces.after = this.optionalSpace(content);
            this.position++;
          } else {
            this.combinator();
          }
        };
        _proto.string = function string4() {
          var current = this.currToken;
          this.newNode(new _string2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.universal = function universal3(namespace2) {
          var nextToken = this.nextToken;
          if (nextToken && this.content(nextToken) === "|") {
            this.position++;
            return this.namespace();
          }
          var current = this.currToken;
          this.newNode(new _universal2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }), namespace2);
          this.position++;
        };
        _proto.splitWord = function splitWord(namespace2, firstCallback) {
          var _this5 = this;
          var nextToken = this.nextToken;
          var word2 = this.content();
          while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
            this.position++;
            var current = this.content();
            word2 += current;
            if (current.lastIndexOf("\\") === current.length - 1) {
              var next = this.nextToken;
              if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
                word2 += this.requiredSpace(this.content(next));
                this.position++;
              }
            }
            nextToken = this.nextToken;
          }
          var hasClass = indexesOf(word2, ".").filter(function(i14) {
            var escapedDot = word2[i14 - 1] === "\\";
            var isKeyframesPercent = /^\d+\.\d+%$/.test(word2);
            return !escapedDot && !isKeyframesPercent;
          });
          var hasId = indexesOf(word2, "#").filter(function(i14) {
            return word2[i14 - 1] !== "\\";
          });
          var interpolations = indexesOf(word2, "#{");
          if (interpolations.length) {
            hasId = hasId.filter(function(hashIndex) {
              return !~interpolations.indexOf(hashIndex);
            });
          }
          var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
          indices.forEach(function(ind, i14) {
            var index3 = indices[i14 + 1] || word2.length;
            var value2 = word2.slice(ind, index3);
            if (i14 === 0 && firstCallback) {
              return firstCallback.call(_this5, value2, indices.length);
            }
            var node3;
            var current2 = _this5.currToken;
            var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i14];
            var source = getSource(current2[1], current2[2] + ind, current2[3], current2[2] + (index3 - 1));
            if (~hasClass.indexOf(ind)) {
              var classNameOpts = {
                value: value2.slice(1),
                source,
                sourceIndex
              };
              node3 = new _className2["default"](unescapeProp(classNameOpts, "value"));
            } else if (~hasId.indexOf(ind)) {
              var idOpts = {
                value: value2.slice(1),
                source,
                sourceIndex
              };
              node3 = new _id2["default"](unescapeProp(idOpts, "value"));
            } else {
              var tagOpts = {
                value: value2,
                source,
                sourceIndex
              };
              unescapeProp(tagOpts, "value");
              node3 = new _tag2["default"](tagOpts);
            }
            _this5.newNode(node3, namespace2);
            namespace2 = null;
          });
          this.position++;
        };
        _proto.word = function word2(namespace2) {
          var nextToken = this.nextToken;
          if (nextToken && this.content(nextToken) === "|") {
            this.position++;
            return this.namespace();
          }
          return this.splitWord(namespace2);
        };
        _proto.loop = function loop() {
          while (this.position < this.tokens.length) {
            this.parse(true);
          }
          this.current._inferEndPosition();
          return this.root;
        };
        _proto.parse = function parse6(throwOnParenthesis) {
          switch (this.currToken[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              this.space();
              break;
            case tokens.comment:
              this.comment();
              break;
            case tokens.openParenthesis:
              this.parentheses();
              break;
            case tokens.closeParenthesis:
              if (throwOnParenthesis) {
                this.missingParenthesis();
              }
              break;
            case tokens.openSquare:
              this.attribute();
              break;
            case tokens.dollar:
            case tokens.caret:
            case tokens.equals:
            case tokens.word:
              this.word();
              break;
            case tokens.colon:
              this.pseudo();
              break;
            case tokens.comma:
              this.comma();
              break;
            case tokens.asterisk:
              this.universal();
              break;
            case tokens.ampersand:
              this.nesting();
              break;
            case tokens.slash:
            case tokens.combinator:
              this.combinator();
              break;
            case tokens.str:
              this.string();
              break;
            // These cases throw; no break needed.
            case tokens.closeSquare:
              this.missingSquareBracket();
            case tokens.semicolon:
              this.missingBackslash();
            default:
              this.unexpected();
          }
        };
        _proto.expected = function expected(description2, index3, found) {
          if (Array.isArray(description2)) {
            var last = description2.pop();
            description2 = description2.join(", ") + " or " + last;
          }
          var an = /^[aeiou]/.test(description2[0]) ? "an" : "a";
          if (!found) {
            return this.error("Expected " + an + " " + description2 + ".", {
              index: index3
            });
          }
          return this.error("Expected " + an + " " + description2 + ', found "' + found + '" instead.', {
            index: index3
          });
        };
        _proto.requiredSpace = function requiredSpace(space2) {
          return this.options.lossy ? " " : space2;
        };
        _proto.optionalSpace = function optionalSpace(space2) {
          return this.options.lossy ? "" : space2;
        };
        _proto.lossySpace = function lossySpace(space2, required2) {
          if (this.options.lossy) {
            return required2 ? " " : "";
          } else {
            return space2;
          }
        };
        _proto.parseParenthesisToken = function parseParenthesisToken(token) {
          var content = this.content(token);
          if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
            return this.requiredSpace(content);
          } else {
            return content;
          }
        };
        _proto.newNode = function newNode(node3, namespace2) {
          if (namespace2) {
            if (/^ +$/.test(namespace2)) {
              if (!this.options.lossy) {
                this.spaces = (this.spaces || "") + namespace2;
              }
              namespace2 = true;
            }
            node3.namespace = namespace2;
            unescapeProp(node3, "namespace");
          }
          if (this.spaces) {
            node3.spaces.before = this.spaces;
            this.spaces = "";
          }
          return this.current.append(node3);
        };
        _proto.content = function content(token) {
          if (token === void 0) {
            token = this.currToken;
          }
          return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
        };
        _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
          if (startPosition === void 0) {
            startPosition = this.position + 1;
          }
          var searchPosition = startPosition;
          while (searchPosition < this.tokens.length) {
            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
              searchPosition++;
              continue;
            } else {
              return searchPosition;
            }
          }
          return -1;
        };
        _createClass(Parser4, [{
          key: "currToken",
          get: function get() {
            return this.tokens[this.position];
          }
        }, {
          key: "nextToken",
          get: function get() {
            return this.tokens[this.position + 1];
          }
        }, {
          key: "prevToken",
          get: function get() {
            return this.tokens[this.position - 1];
          }
        }]);
        return Parser4;
      }();
      exports4["default"] = Parser3;
      module3.exports = exports4.default;
    })(parser, parser.exports);
    parserExports = parser.exports;
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _parser = _interopRequireDefault2(parserExports);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var Processor2 = /* @__PURE__ */ function() {
        function Processor3(func, options2) {
          this.func = func || function noop2() {
          };
          this.funcRes = null;
          this.options = options2;
        }
        var _proto = Processor3.prototype;
        _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var merged = Object.assign({}, this.options, options2);
          if (merged.updateSelector === false) {
            return false;
          } else {
            return typeof rule !== "string";
          }
        };
        _proto._isLossy = function _isLossy(options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var merged = Object.assign({}, this.options, options2);
          if (merged.lossless === false) {
            return true;
          } else {
            return false;
          }
        };
        _proto._root = function _root2(rule, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var parser2 = new _parser["default"](rule, this._parseOptions(options2));
          return parser2.root;
        };
        _proto._parseOptions = function _parseOptions(options2) {
          return {
            lossy: this._isLossy(options2)
          };
        };
        _proto._run = function _run(rule, options2) {
          var _this = this;
          if (options2 === void 0) {
            options2 = {};
          }
          return new Promise(function(resolve5, reject) {
            try {
              var root3 = _this._root(rule, options2);
              Promise.resolve(_this.func(root3)).then(function(transform2) {
                var string4 = void 0;
                if (_this._shouldUpdateSelector(rule, options2)) {
                  string4 = root3.toString();
                  rule.selector = string4;
                }
                return {
                  transform: transform2,
                  root: root3,
                  string: string4
                };
              }).then(resolve5, reject);
            } catch (e2) {
              reject(e2);
              return;
            }
          });
        };
        _proto._runSync = function _runSync(rule, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var root3 = this._root(rule, options2);
          var transform2 = this.func(root3);
          if (transform2 && typeof transform2.then === "function") {
            throw new Error("Selector processor returned a promise to a synchronous call.");
          }
          var string4 = void 0;
          if (options2.updateSelector && typeof rule !== "string") {
            string4 = root3.toString();
            rule.selector = string4;
          }
          return {
            transform: transform2,
            root: root3,
            string: string4
          };
        };
        _proto.ast = function ast(rule, options2) {
          return this._run(rule, options2).then(function(result) {
            return result.root;
          });
        };
        _proto.astSync = function astSync(rule, options2) {
          return this._runSync(rule, options2).root;
        };
        _proto.transform = function transform2(rule, options2) {
          return this._run(rule, options2).then(function(result) {
            return result.transform;
          });
        };
        _proto.transformSync = function transformSync(rule, options2) {
          return this._runSync(rule, options2).transform;
        };
        _proto.process = function process2(rule, options2) {
          return this._run(rule, options2).then(function(result) {
            return result.string || result.root.toString();
          });
        };
        _proto.processSync = function processSync(rule, options2) {
          var result = this._runSync(rule, options2);
          return result.string || result.root.toString();
        };
        return Processor3;
      }();
      exports4["default"] = Processor2;
      module3.exports = exports4.default;
    })(processor, processor.exports);
    processorExports = processor.exports;
    selectors = {};
    constructors = {};
    constructors.__esModule = true;
    constructors.universal = constructors.tag = constructors.string = constructors.selector = constructors.root = constructors.pseudo = constructors.nesting = constructors.id = constructors.comment = constructors.combinator = constructors.className = constructors.attribute = void 0;
    _attribute = _interopRequireDefault$2(attribute$1);
    _className = _interopRequireDefault$2(classNameExports);
    _combinator = _interopRequireDefault$2(combinatorExports);
    _comment = _interopRequireDefault$2(commentExports);
    _id = _interopRequireDefault$2(idExports);
    _nesting = _interopRequireDefault$2(nestingExports);
    _pseudo = _interopRequireDefault$2(pseudoExports);
    _root = _interopRequireDefault$2(rootExports);
    _selector = _interopRequireDefault$2(selectorExports);
    _string = _interopRequireDefault$2(stringExports);
    _tag = _interopRequireDefault$2(tagExports);
    _universal = _interopRequireDefault$2(universalExports);
    attribute = function attribute2(opts) {
      return new _attribute["default"](opts);
    };
    constructors.attribute = attribute;
    className = function className2(opts) {
      return new _className["default"](opts);
    };
    constructors.className = className;
    combinator = function combinator2(opts) {
      return new _combinator["default"](opts);
    };
    constructors.combinator = combinator;
    comment = function comment2(opts) {
      return new _comment["default"](opts);
    };
    constructors.comment = comment;
    id = function id2(opts) {
      return new _id["default"](opts);
    };
    constructors.id = id;
    nesting = function nesting2(opts) {
      return new _nesting["default"](opts);
    };
    constructors.nesting = nesting;
    pseudo = function pseudo2(opts) {
      return new _pseudo["default"](opts);
    };
    constructors.pseudo = pseudo;
    root = function root2(opts) {
      return new _root["default"](opts);
    };
    constructors.root = root;
    selector = function selector2(opts) {
      return new _selector["default"](opts);
    };
    constructors.selector = selector;
    string = function string2(opts) {
      return new _string["default"](opts);
    };
    constructors.string = string;
    tag = function tag2(opts) {
      return new _tag["default"](opts);
    };
    constructors.tag = tag;
    universal = function universal2(opts) {
      return new _universal["default"](opts);
    };
    constructors.universal = universal;
    guards = {};
    guards.__esModule = true;
    guards.isComment = guards.isCombinator = guards.isClassName = guards.isAttribute = void 0;
    guards.isContainer = isContainer;
    guards.isIdentifier = void 0;
    guards.isNamespace = isNamespace;
    guards.isNesting = void 0;
    guards.isNode = isNode;
    guards.isPseudo = void 0;
    guards.isPseudoClass = isPseudoClass;
    guards.isPseudoElement = isPseudoElement;
    guards.isUniversal = guards.isTag = guards.isString = guards.isSelector = guards.isRoot = void 0;
    _types = types;
    IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
    isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
    guards.isAttribute = isAttribute;
    isClassName = isNodeType.bind(null, _types.CLASS);
    guards.isClassName = isClassName;
    isCombinator = isNodeType.bind(null, _types.COMBINATOR);
    guards.isCombinator = isCombinator;
    isComment = isNodeType.bind(null, _types.COMMENT);
    guards.isComment = isComment;
    isIdentifier = isNodeType.bind(null, _types.ID);
    guards.isIdentifier = isIdentifier;
    isNesting = isNodeType.bind(null, _types.NESTING);
    guards.isNesting = isNesting;
    isPseudo = isNodeType.bind(null, _types.PSEUDO);
    guards.isPseudo = isPseudo;
    isRoot = isNodeType.bind(null, _types.ROOT);
    guards.isRoot = isRoot;
    isSelector = isNodeType.bind(null, _types.SELECTOR);
    guards.isSelector = isSelector;
    isString = isNodeType.bind(null, _types.STRING);
    guards.isString = isString;
    isTag = isNodeType.bind(null, _types.TAG);
    guards.isTag = isTag;
    isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
    guards.isUniversal = isUniversal;
    (function(exports4) {
      exports4.__esModule = true;
      var _types2 = types;
      Object.keys(_types2).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports4 && exports4[key] === _types2[key]) return;
        exports4[key] = _types2[key];
      });
      var _constructors = constructors;
      Object.keys(_constructors).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports4 && exports4[key] === _constructors[key]) return;
        exports4[key] = _constructors[key];
      });
      var _guards = guards;
      Object.keys(_guards).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports4 && exports4[key] === _guards[key]) return;
        exports4[key] = _guards[key];
      });
    })(selectors);
    (function(module3, exports4) {
      exports4.__esModule = true;
      exports4["default"] = void 0;
      var _processor = _interopRequireDefault2(processorExports);
      var selectors$1 = _interopRequireWildcard(selectors);
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var parser2 = function parser3(processor2) {
        return new _processor["default"](processor2);
      };
      Object.assign(parser2, selectors$1);
      delete parser2.__esModule;
      var _default = parser2;
      exports4["default"] = _default;
      module3.exports = exports4.default;
    })(dist, dist.exports);
    distExports = dist.exports;
    selectorParser$1 = distExports;
    valueParser2 = lib;
    ({ extractICSS } = src$4);
    isSpacing = (node3) => node3.type === "combinator" && node3.value === " ";
    src$2.exports = (options2 = {}) => {
      if (options2 && options2.mode && options2.mode !== "global" && options2.mode !== "local" && options2.mode !== "pure") {
        throw new Error(
          'options.mode must be either "global", "local" or "pure" (default "local")'
        );
      }
      const pureMode = options2 && options2.mode === "pure";
      const globalMode = options2 && options2.mode === "global";
      return {
        postcssPlugin: "postcss-modules-local-by-default",
        prepare() {
          const localAliasMap = /* @__PURE__ */ new Map();
          return {
            Once(root3) {
              const { icssImports } = extractICSS(root3, false);
              Object.keys(icssImports).forEach((key) => {
                Object.keys(icssImports[key]).forEach((prop) => {
                  localAliasMap.set(prop, icssImports[key][prop]);
                });
              });
              root3.walkAtRules((atRule) => {
                if (/keyframes$/i.test(atRule.name)) {
                  const globalMatch = /^\s*:global\s*\((.+)\)\s*$/.exec(
                    atRule.params
                  );
                  const localMatch = /^\s*:local\s*\((.+)\)\s*$/.exec(
                    atRule.params
                  );
                  let globalKeyframes = globalMode;
                  if (globalMatch) {
                    if (pureMode) {
                      throw atRule.error(
                        "@keyframes :global(...) is not allowed in pure mode"
                      );
                    }
                    atRule.params = globalMatch[1];
                    globalKeyframes = true;
                  } else if (localMatch) {
                    atRule.params = localMatch[0];
                    globalKeyframes = false;
                  } else if (!globalMode) {
                    if (atRule.params && !localAliasMap.has(atRule.params)) {
                      atRule.params = ":local(" + atRule.params + ")";
                    }
                  }
                  atRule.walkDecls((declaration) => {
                    localizeDeclaration(declaration, {
                      localAliasMap,
                      options: options2,
                      global: globalKeyframes
                    });
                  });
                } else if (atRule.nodes) {
                  atRule.nodes.forEach((declaration) => {
                    if (declaration.type === "decl") {
                      localizeDeclaration(declaration, {
                        localAliasMap,
                        options: options2,
                        global: globalMode
                      });
                    }
                  });
                }
              });
              root3.walkRules((rule) => {
                if (rule.parent && rule.parent.type === "atrule" && /keyframes$/i.test(rule.parent.name)) {
                  return;
                }
                const context = localizeNode(rule, options2.mode, localAliasMap);
                context.options = options2;
                context.localAliasMap = localAliasMap;
                if (pureMode && context.hasPureGlobals) {
                  throw rule.error(
                    'Selector "' + rule.selector + '" is not pure (pure selectors must contain at least one local class or id)'
                  );
                }
                rule.selector = context.selector;
                if (rule.nodes) {
                  rule.nodes.forEach(
                    (declaration) => localizeDeclaration(declaration, context)
                  );
                }
              });
            }
          };
        }
      };
    };
    src$2.exports.postcss = true;
    srcExports$1 = src$2.exports;
    selectorParser = distExports;
    hasOwnProperty = Object.prototype.hasOwnProperty;
    whitespace = "[\\x20\\t\\r\\n\\f]";
    unescapeRegExp = new RegExp(
      "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)",
      "ig"
    );
    plugin = (options2 = {}) => {
      const generateScopedName = options2 && options2.generateScopedName || plugin.generateScopedName;
      const generateExportEntry = options2 && options2.generateExportEntry || plugin.generateExportEntry;
      const exportGlobals = options2 && options2.exportGlobals;
      return {
        postcssPlugin: "postcss-modules-scope",
        Once(root3, { rule }) {
          const exports4 = /* @__PURE__ */ Object.create(null);
          function exportScopedName(name2, rawName) {
            const scopedName = generateScopedName(
              rawName ? rawName : name2,
              root3.source.input.from,
              root3.source.input.css
            );
            const exportEntry = generateExportEntry(
              rawName ? rawName : name2,
              scopedName,
              root3.source.input.from,
              root3.source.input.css
            );
            const { key, value: value2 } = exportEntry;
            exports4[key] = exports4[key] || [];
            if (exports4[key].indexOf(value2) < 0) {
              exports4[key].push(value2);
            }
            return scopedName;
          }
          function localizeNode2(node3) {
            switch (node3.type) {
              case "selector":
                node3.nodes = node3.map(localizeNode2);
                return node3;
              case "class":
                return selectorParser.className({
                  value: exportScopedName(
                    node3.value,
                    node3.raws && node3.raws.value ? node3.raws.value : null
                  )
                });
              case "id": {
                return selectorParser.id({
                  value: exportScopedName(
                    node3.value,
                    node3.raws && node3.raws.value ? node3.raws.value : null
                  )
                });
              }
            }
            throw new Error(
              `${node3.type} ("${node3}") is not allowed in a :local block`
            );
          }
          function traverseNode(node3) {
            switch (node3.type) {
              case "pseudo":
                if (node3.value === ":local") {
                  if (node3.nodes.length !== 1) {
                    throw new Error('Unexpected comma (",") in :local block');
                  }
                  const selector3 = localizeNode2(node3.first);
                  selector3.first.spaces = node3.spaces;
                  const nextNode = node3.next();
                  if (nextNode && nextNode.type === "combinator" && nextNode.value === " " && /\\[A-F0-9]{1,6}$/.test(selector3.last.value)) {
                    selector3.last.spaces.after = " ";
                  }
                  node3.replaceWith(selector3);
                  return;
                }
              /* falls through */
              case "root":
              case "selector": {
                node3.each(traverseNode);
                break;
              }
              case "id":
              case "class":
                if (exportGlobals) {
                  exports4[node3.value] = [node3.value];
                }
                break;
            }
            return node3;
          }
          const importedNames = {};
          root3.walkRules(/^:import\(.+\)$/, (rule2) => {
            rule2.walkDecls((decl) => {
              importedNames[decl.prop] = true;
            });
          });
          root3.walkRules((rule2) => {
            let parsedSelector = selectorParser().astSync(rule2);
            rule2.selector = traverseNode(parsedSelector.clone()).toString();
            rule2.walkDecls(/composes|compose-with/i, (decl) => {
              const localNames = getSingleLocalNamesForComposes(parsedSelector);
              const classes = decl.value.split(/\s+/);
              classes.forEach((className3) => {
                const global2 = /^global\(([^)]+)\)$/.exec(className3);
                if (global2) {
                  localNames.forEach((exportedName) => {
                    exports4[exportedName].push(global2[1]);
                  });
                } else if (hasOwnProperty.call(importedNames, className3)) {
                  localNames.forEach((exportedName) => {
                    exports4[exportedName].push(className3);
                  });
                } else if (hasOwnProperty.call(exports4, className3)) {
                  localNames.forEach((exportedName) => {
                    exports4[className3].forEach((item) => {
                      exports4[exportedName].push(item);
                    });
                  });
                } else {
                  throw decl.error(
                    `referenced class name "${className3}" in ${decl.prop} not found`
                  );
                }
              });
              decl.remove();
            });
            rule2.walkDecls((decl) => {
              if (!/:local\s*\((.+?)\)/.test(decl.value)) {
                return;
              }
              let tokens = decl.value.split(/(,|'[^']*'|"[^"]*")/);
              tokens = tokens.map((token, idx) => {
                if (idx === 0 || tokens[idx - 1] === ",") {
                  let result = token;
                  const localMatch = /:local\s*\((.+?)\)/.exec(token);
                  if (localMatch) {
                    const input = localMatch.input;
                    const matchPattern = localMatch[0];
                    const matchVal = localMatch[1];
                    const newVal = exportScopedName(matchVal);
                    result = input.replace(matchPattern, newVal);
                  } else {
                    return token;
                  }
                  return result;
                } else {
                  return token;
                }
              });
              decl.value = tokens.join("");
            });
          });
          root3.walkAtRules(/keyframes$/i, (atRule) => {
            const localMatch = /^\s*:local\s*\((.+?)\)\s*$/.exec(atRule.params);
            if (!localMatch) {
              return;
            }
            atRule.params = exportScopedName(localMatch[1]);
          });
          const exportedNames = Object.keys(exports4);
          if (exportedNames.length > 0) {
            const exportRule = rule({ selector: ":export" });
            exportedNames.forEach(
              (exportedName) => exportRule.append({
                prop: exportedName,
                value: exports4[exportedName].join(" "),
                raws: { before: "\n  " }
              })
            );
            root3.append(exportRule);
          }
        }
      };
    };
    plugin.postcss = true;
    plugin.generateScopedName = function(name2, path7) {
      const sanitisedPath = path7.replace(/\.[^./\\]+$/, "").replace(/[\W_]+/g, "_").replace(/^_|_$/g, "");
      return `_${sanitisedPath}__${name2}`.trim();
    };
    plugin.generateExportEntry = function(name2, scopedName) {
      return {
        key: unescape2(name2),
        value: unescape2(scopedName)
      };
    };
    src$1 = plugin;
    stringHash = hash;
    src = { exports: {} };
    ICSSUtils = src$4;
    matchImports = /^(.+?|\([\s\S]+?\))\s+from\s+("[^"]*"|'[^']*'|[\w-]+)$/;
    matchValueDefinition = /(?:\s+|^)([\w-]+):?(.*?)$/;
    matchImport = /^([\w-]+)(?:\s+as\s+([\w-]+))?/;
    src.exports = (options2) => {
      let importIndex = 0;
      const createImportedName = options2 && options2.createImportedName || ((importName) => `i__const_${importName.replace(/\W/g, "_")}_${importIndex++}`);
      return {
        postcssPlugin: "postcss-modules-values",
        prepare(result) {
          const importAliases = [];
          const definitions = {};
          return {
            Once(root3, postcss2) {
              root3.walkAtRules(/value/i, (atRule) => {
                const matches = atRule.params.match(matchImports);
                if (matches) {
                  let [
                    ,
                    /*match*/
                    aliases,
                    path7
                  ] = matches;
                  if (definitions[path7]) {
                    path7 = definitions[path7];
                  }
                  const imports2 = aliases.replace(/^\(\s*([\s\S]+)\s*\)$/, "$1").split(/\s*,\s*/).map((alias) => {
                    const tokens = matchImport.exec(alias);
                    if (tokens) {
                      const [
                        ,
                        /*match*/
                        theirName,
                        myName = theirName
                      ] = tokens;
                      const importedName = createImportedName(myName);
                      definitions[myName] = importedName;
                      return { theirName, importedName };
                    } else {
                      throw new Error(`@import statement "${alias}" is invalid!`);
                    }
                  });
                  importAliases.push({ path: path7, imports: imports2 });
                  atRule.remove();
                  return;
                }
                if (atRule.params.indexOf("@value") !== -1) {
                  result.warn("Invalid value definition: " + atRule.params);
                }
                let [, key, value2] = `${atRule.params}${atRule.raws.between}`.match(
                  matchValueDefinition
                );
                const normalizedValue = value2.replace(/\/\*((?!\*\/).*?)\*\//g, "");
                if (normalizedValue.length === 0) {
                  result.warn("Invalid value definition: " + atRule.params);
                  atRule.remove();
                  return;
                }
                let isOnlySpace = /^\s+$/.test(normalizedValue);
                if (!isOnlySpace) {
                  value2 = value2.trim();
                }
                definitions[key] = ICSSUtils.replaceValueSymbols(
                  value2,
                  definitions
                );
                atRule.remove();
              });
              if (!Object.keys(definitions).length) {
                return;
              }
              ICSSUtils.replaceSymbols(root3, definitions);
              const exportDeclarations = Object.keys(definitions).map(
                (key) => postcss2.decl({
                  value: definitions[key],
                  prop: key,
                  raws: { before: "\n  " }
                })
              );
              if (exportDeclarations.length > 0) {
                const exportRule = postcss2.rule({
                  selector: ":export",
                  raws: { after: "\n" }
                });
                exportRule.append(exportDeclarations);
                root3.prepend(exportRule);
              }
              importAliases.reverse().forEach(({ path: path7, imports: imports2 }) => {
                const importRule = postcss2.rule({
                  selector: `:import(${path7})`,
                  raws: { after: "\n" }
                });
                imports2.forEach(({ theirName, importedName }) => {
                  importRule.append({
                    value: theirName,
                    prop: importedName,
                    raws: { before: "\n  " }
                  });
                });
                root3.prepend(importRule);
              });
            }
          };
        }
      };
    };
    src.exports.postcss = true;
    srcExports = src.exports;
    Object.defineProperty(scoping, "__esModule", {
      value: true
    });
    scoping.behaviours = void 0;
    scoping.getDefaultPlugins = getDefaultPlugins;
    scoping.getDefaultScopeBehaviour = getDefaultScopeBehaviour;
    scoping.getScopedNameGenerator = getScopedNameGenerator;
    _postcssModulesExtractImports = _interopRequireDefault$1(srcExports$2);
    _genericNames = _interopRequireDefault$1(genericNames);
    _postcssModulesLocalByDefault = _interopRequireDefault$1(srcExports$1);
    _postcssModulesScope = _interopRequireDefault$1(src$1);
    _stringHash = _interopRequireDefault$1(stringHash);
    _postcssModulesValues = _interopRequireDefault$1(srcExports);
    behaviours = {
      LOCAL: "local",
      GLOBAL: "global"
    };
    scoping.behaviours = behaviours;
    Object.defineProperty(pluginFactory, "__esModule", {
      value: true
    });
    pluginFactory.makePlugin = makePlugin;
    _postcss = _interopRequireDefault(e);
    _unquote = _interopRequireDefault(unquote$1);
    _Parser = _interopRequireDefault(Parser$1);
    _saveJSON = _interopRequireDefault(saveJSON$1);
    _localsConvention = localsConvention;
    _FileSystemLoader = _interopRequireDefault(FileSystemLoader$1);
    _scoping = scoping;
    PLUGIN_NAME = "postcss-modules";
    _fs = require$$0__default2;
    _fs2 = fs3;
    _pluginFactory = pluginFactory;
    (0, _fs2.setFileSystem)({
      readFile: _fs.readFile,
      writeFile: _fs.writeFile
    });
    build.exports = (opts = {}) => (0, _pluginFactory.makePlugin)(opts);
    postcss = build.exports.postcss = true;
    buildExports = build.exports;
    index2 = /* @__PURE__ */ getDefaultExportFromCjs(buildExports);
    index$12 = /* @__PURE__ */ _mergeNamespaces2({
      __proto__: null,
      default: index2,
      postcss
    }, [buildExports]);
  }
});

// dist/node/chunks/dep-BWSbWtLw.js
import * as fs$j from "node:fs";
import fs__default, { promises as promises$1 } from "node:fs";
import fsp, { lstat as lstat$3, readdir as readdir$5, readlink, realpath as realpath$2 } from "node:fs/promises";
import path$n, { win32 as win32$1, posix as posix$1, isAbsolute as isAbsolute$1, join as join$2, extname as extname$1, dirname as dirname$2, relative as relative$2, basename as basename$2 } from "node:path";
import { fileURLToPath as fileURLToPath2, URL as URL$3, parse as parse$h, pathToFileURL } from "node:url";
import { promisify as promisify$4, format as format$2, inspect } from "node:util";
import { performance as performance$1 } from "node:perf_hooks";
import { createRequire as createRequire$1, builtinModules } from "node:module";
import require$$0$3 from "node:tty";
import require$$0$4, { win32, posix, isAbsolute as isAbsolute2, resolve as resolve$3, relative as relative$1, basename as basename$1, extname as extname2, dirname as dirname$1, join as join$1, sep as sep$1, normalize as normalize$1 } from "node:path";
import * as require$$0$22 from "node:fs";
import require$$0__default3, { lstatSync, readdir as readdir$4, readdirSync, readlinkSync, realpathSync as realpathSync$1, existsSync as existsSync2, readFileSync as readFileSync2, statSync as statSync$1 } from "node:fs";
import { EventEmitter as EventEmitter$4 } from "node:events";
import Stream$1 from "node:stream";
import { StringDecoder } from "node:string_decoder";
import { exec, execSync } from "node:child_process";
import { createServer as createServer$3, STATUS_CODES, get as get$2 } from "node:http";
import { createServer as createServer$2, get as get$1 } from "node:https";
import require$$0$5 from "node:util";
import require$$4$1 from "node:net";
import require$$0$7 from "node:events";
import require$$0$9 from "node:url";
import require$$1 from "node:http";
import require$$0$6 from "node:stream";
import require$$2 from "node:os";
import require$$2$1 from "node:child_process";
import os$5 from "node:os";
import { createHash as createHash$2 } from "node:crypto";
import { promises } from "node:dns";
import require$$3$1 from "node:crypto";
import require$$0$8, { createRequire as createRequire$2 } from "node:module";
import assert$1 from "node:assert";
import v82 from "node:v8";
import { Worker as Worker$1 } from "node:worker_threads";
import { Buffer as Buffer$1 } from "node:buffer";
import * as qs from "node:querystring";
import readline from "node:readline";
import zlib$1 from "node:zlib";
import require$$0$a from "node:buffer";
import require$$1$1 from "node:https";
import require$$4$2 from "node:tls";
import require$$4$3 from "node:assert";
import { gzip } from "node:zlib";
import { fileURLToPath as __cjs_fileURLToPath4 } from "node:url";
import { dirname as __cjs_dirname4 } from "node:path";
import { createRequire as __cjs_createRequire4 } from "node:module";
function getDefaultExportFromCjs(x22) {
  return x22 && x22.__esModule && Object.prototype.hasOwnProperty.call(x22, "default") ? x22["default"] : x22;
}
function getAugmentedNamespace(n14) {
  if (n14.__esModule) return n14;
  var f15 = n14.default;
  if (typeof f15 == "function") {
    var a20 = function a21() {
      if (this instanceof a21) {
        return Reflect.construct(f15, arguments, this.constructor);
      }
      return f15.apply(this, arguments);
    };
    a20.prototype = f15.prototype;
  } else a20 = {};
  Object.defineProperty(a20, "__esModule", { value: true });
  Object.keys(n14).forEach(function(k13) {
    var d20 = Object.getOwnPropertyDescriptor(n14, k13);
    Object.defineProperty(a20, k13, d20.get ? d20 : {
      enumerable: true,
      get: function() {
        return n14[k13];
      }
    });
  });
  return a20;
}
function commonjsRequire(path7) {
  throw new Error('Could not dynamically require "' + path7 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
function slash$1(p20) {
  return p20.replace(windowsSlashRE, "/");
}
function cleanUrl(url2) {
  return url2.replace(postfixRE, "");
}
function balanced$1(a20, b18, str2) {
  if (a20 instanceof RegExp) a20 = maybeMatch(a20, str2);
  if (b18 instanceof RegExp) b18 = maybeMatch(b18, str2);
  var r9 = range$1(a20, b18, str2);
  return r9 && {
    start: r9[0],
    end: r9[1],
    pre: str2.slice(0, r9[0]),
    body: str2.slice(r9[0] + a20.length, r9[1]),
    post: str2.slice(r9[1] + b18.length)
  };
}
function maybeMatch(reg2, str2) {
  var m23 = str2.match(reg2);
  return m23 ? m23[0] : null;
}
function range$1(a20, b18, str2) {
  var begs, beg, left, right, result;
  var ai = str2.indexOf(a20);
  var bi = str2.indexOf(b18, ai + 1);
  var i14 = ai;
  if (ai >= 0 && bi > 0) {
    if (a20 === b18) {
      return [ai, bi];
    }
    begs = [];
    left = str2.length;
    while (i14 >= 0 && !result) {
      if (i14 == ai) {
        begs.push(i14);
        ai = str2.indexOf(a20, i14 + 1);
      } else if (begs.length == 1) {
        result = [begs.pop(), bi];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }
        bi = str2.indexOf(b18, i14 + 1);
      }
      i14 = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length) {
      result = [left, right];
    }
  }
  return result;
}
function numeric(str2) {
  return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
}
function escapeBraces(str2) {
  return str2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
}
function unescapeBraces(str2) {
  return str2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
}
function parseCommaParts(str2) {
  if (!str2)
    return [""];
  var parts = [];
  var m23 = balanced("{", "}", str2);
  if (!m23)
    return str2.split(",");
  var pre = m23.pre;
  var body = m23.body;
  var post = m23.post;
  var p20 = pre.split(",");
  p20[p20.length - 1] += "{" + body + "}";
  var postParts = parseCommaParts(post);
  if (post.length) {
    p20[p20.length - 1] += postParts.shift();
    p20.push.apply(p20, postParts);
  }
  parts.push.apply(parts, p20);
  return parts;
}
function expandTop(str2) {
  if (!str2)
    return [];
  if (str2.substr(0, 2) === "{}") {
    str2 = "\\{\\}" + str2.substr(2);
  }
  return expand$3(escapeBraces(str2), true).map(unescapeBraces);
}
function embrace(str2) {
  return "{" + str2 + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i14, y20) {
  return i14 <= y20;
}
function gte(i14, y20) {
  return i14 >= y20;
}
function expand$3(str2, isTop) {
  var expansions = [];
  var m23 = balanced("{", "}", str2);
  if (!m23) return [str2];
  var pre = m23.pre;
  var post = m23.post.length ? expand$3(m23.post, false) : [""];
  if (/\$$/.test(m23.pre)) {
    for (var k13 = 0; k13 < post.length; k13++) {
      var expansion = pre + "{" + m23.body + "}" + post[k13];
      expansions.push(expansion);
    }
  } else {
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m23.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m23.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m23.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m23.post.match(/,.*\}/)) {
        str2 = m23.pre + "{" + m23.body + escClose + m23.post;
        return expand$3(str2);
      }
      return [str2];
    }
    var n14;
    if (isSequence) {
      n14 = m23.body.split(/\.\./);
    } else {
      n14 = parseCommaParts(m23.body);
      if (n14.length === 1) {
        n14 = expand$3(n14[0], false).map(embrace);
        if (n14.length === 1) {
          return post.map(function(p20) {
            return m23.pre + n14[0] + p20;
          });
        }
      }
    }
    var N12;
    if (isSequence) {
      var x22 = numeric(n14[0]);
      var y20 = numeric(n14[1]);
      var width = Math.max(n14[0].length, n14[1].length);
      var incr = n14.length == 3 ? Math.abs(numeric(n14[2])) : 1;
      var test = lte;
      var reverse = y20 < x22;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad2 = n14.some(isPadded);
      N12 = [];
      for (var i14 = x22; test(i14, y20); i14 += incr) {
        var c16;
        if (isAlphaSequence) {
          c16 = String.fromCharCode(i14);
          if (c16 === "\\")
            c16 = "";
        } else {
          c16 = String(i14);
          if (pad2) {
            var need = width - c16.length;
            if (need > 0) {
              var z11 = new Array(need + 1).join("0");
              if (i14 < 0)
                c16 = "-" + z11 + c16.slice(1);
              else
                c16 = z11 + c16;
            }
          }
        }
        N12.push(c16);
      }
    } else {
      N12 = [];
      for (var j16 = 0; j16 < n14.length; j16++) {
        N12.push.apply(N12, expand$3(n14[j16], false));
      }
    }
    for (var j16 = 0; j16 < N12.length; j16++) {
      for (var k13 = 0; k13 < post.length; k13++) {
        var expansion = pre + N12[j16] + post[k13];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
  }
  return expansions;
}
function globStreamSync(pattern2, options2 = {}) {
  return new Glob(pattern2, options2).streamSync();
}
function globStream(pattern2, options2 = {}) {
  return new Glob(pattern2, options2).stream();
}
function globSync(pattern2, options2 = {}) {
  return new Glob(pattern2, options2).walkSync();
}
async function glob_(pattern2, options2 = {}) {
  return new Glob(pattern2, options2).walk();
}
function globIterateSync(pattern2, options2 = {}) {
  return new Glob(pattern2, options2).iterateSync();
}
function globIterate(pattern2, options2 = {}) {
  return new Glob(pattern2, options2).iterate();
}
function requireMs$1() {
  if (hasRequiredMs$1) return ms$1;
  hasRequiredMs$1 = 1;
  var s12 = 1e3;
  var m23 = s12 * 60;
  var h20 = m23 * 60;
  var d20 = h20 * 24;
  var w13 = d20 * 7;
  var y20 = d20 * 365.25;
  ms$1 = function(val, options2) {
    options2 = options2 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse6(val);
    } else if (type === "number" && isFinite(val)) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse6(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match2) {
      return;
    }
    var n14 = parseFloat(match2[1]);
    var type = (match2[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n14 * y20;
      case "weeks":
      case "week":
      case "w":
        return n14 * w13;
      case "days":
      case "day":
      case "d":
        return n14 * d20;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n14 * h20;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n14 * m23;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n14 * s12;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n14;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d20) {
      return Math.round(ms2 / d20) + "d";
    }
    if (msAbs >= h20) {
      return Math.round(ms2 / h20) + "h";
    }
    if (msAbs >= m23) {
      return Math.round(ms2 / m23) + "m";
    }
    if (msAbs >= s12) {
      return Math.round(ms2 / s12) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d20) {
      return plural(ms2, msAbs, d20, "day");
    }
    if (msAbs >= h20) {
      return plural(ms2, msAbs, h20, "hour");
    }
    if (msAbs >= m23) {
      return plural(ms2, msAbs, m23, "minute");
    }
    if (msAbs >= s12) {
      return plural(ms2, msAbs, s12, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n14, name2) {
    var isPlural = msAbs >= n14 * 1.5;
    return Math.round(ms2 / n14) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms$1;
}
function requireCommon() {
  if (hasRequiredCommon) return common$b;
  hasRequiredCommon = 1;
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs$1();
    createDebug.destroy = destroy2;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace2) {
      let hash3 = 0;
      for (let i14 = 0; i14 < namespace2.length; i14++) {
        hash3 = (hash3 << 5) - hash3 + namespace2.charCodeAt(i14);
        hash3 |= 0;
      }
      return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace2) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index3 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
          if (match2 === "%%") {
            return "%";
          }
          index3++;
          const formatter2 = createDebug.formatters[format2];
          if (typeof formatter2 === "function") {
            const val = args[index3];
            match2 = formatter2.call(self2, val);
            args.splice(index3, 1);
            index3--;
          }
          return match2;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace2;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace2);
      debug2.extend = extend;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace2);
          }
          return enabledCache;
        },
        set: (v15) => {
          enableOverride = v15;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend(namespace2, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i14;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i14 = 0; i14 < len; i14++) {
        if (!split[i14]) {
          continue;
        }
        namespaces = split[i14].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name2) {
      if (name2[name2.length - 1] === "*") {
        return true;
      }
      let i14;
      let len;
      for (i14 = 0, len = createDebug.skips.length; i14 < len; i14++) {
        if (createDebug.skips[i14].test(name2)) {
          return false;
        }
      }
      for (i14 = 0, len = createDebug.names.length; i14 < len; i14++) {
        if (createDebug.names[i14].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy2() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$b = setup;
  return common$b;
}
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$3.exports;
  hasRequiredBrowser$1 = 1;
  (function(module3, exports4) {
    exports4.formatArgs = formatArgs;
    exports4.save = save;
    exports4.load = load2;
    exports4.useColors = useColors;
    exports4.storage = localstorage();
    exports4.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports4.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m23;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m23 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m23[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module3.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c16 = "color: " + this.color;
      args.splice(1, 0, c16, "color: inherit");
      let index3 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index3++;
        if (match2 === "%c") {
          lastC = index3;
        }
      });
      args.splice(lastC, 0, c16);
    }
    exports4.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports4.storage.setItem("debug", namespaces);
        } else {
          exports4.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load2() {
      let r9;
      try {
        r9 = exports4.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r9 && typeof process !== "undefined" && "env" in process) {
        r9 = process.env.DEBUG;
      }
      return r9;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module3.exports = requireCommon()(exports4);
    const { formatters } = module3.exports;
    formatters.j = function(v15) {
      try {
        return JSON.stringify(v15);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser$3, browser$3.exports);
  return browser$3.exports;
}
function requireNode$1() {
  if (hasRequiredNode$1) return node$12.exports;
  hasRequiredNode$1 = 1;
  (function(module3, exports4) {
    const tty = require$$0$3;
    const util3 = require$$0$5;
    exports4.init = init2;
    exports4.log = log;
    exports4.formatArgs = formatArgs;
    exports4.save = save;
    exports4.load = load2;
    exports4.useColors = useColors;
    exports4.destroy = util3.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports4.colors = [6, 2, 3, 4, 5, 1];
    try {
    } catch (error2) {
    }
    exports4.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_22, k13) => {
        return k13.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports4.inspectOpts ? Boolean(exports4.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c16 = this.color;
        const colorCode = "\x1B[3" + (c16 < 8 ? c16 : "8;5;" + c16);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module3.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports4.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util3.formatWithOptions(exports4.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports4.inspectOpts);
      for (let i14 = 0; i14 < keys.length; i14++) {
        debug2.inspectOpts[keys[i14]] = exports4.inspectOpts[keys[i14]];
      }
    }
    module3.exports = requireCommon()(exports4);
    const { formatters } = module3.exports;
    formatters.o = function(v15) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v15, this.inspectOpts).split("\n").map((str2) => str2.trim()).join(" ");
    };
    formatters.O = function(v15) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v15, this.inspectOpts);
    };
  })(node$12, node$12.exports);
  return node$12.exports;
}
function resolveDependencyVersion(dep, pkgRelativePath = "../../package.json") {
  const pkgPath = path$n.resolve(_require$1.resolve(dep), pkgRelativePath);
  return JSON.parse(fs__default.readFileSync(pkgPath, "utf-8")).version;
}
function createDebugger(namespace2, options2 = {}) {
  const log = debug$i(namespace2);
  const { onlyWhenFocused } = options2;
  let enabled = log.enabled;
  if (enabled && onlyWhenFocused) {
    const ns = typeof onlyWhenFocused === "string" ? onlyWhenFocused : namespace2;
    enabled = !!DEBUG?.includes(ns);
  }
  if (enabled) {
    return (...args) => {
      if (!filter || args.some((a20) => a20?.includes?.(filter))) {
        log(...args);
      }
    };
  }
}
function testCaseInsensitiveFS() {
  if (!CLIENT_ENTRY.endsWith("client.mjs")) {
    throw new Error(
      `cannot test case insensitive FS, CLIENT_ENTRY const doesn't contain client.mjs`
    );
  }
  if (!fs__default.existsSync(CLIENT_ENTRY)) {
    throw new Error(
      "cannot test case insensitive FS, CLIENT_ENTRY does not point to an existing file: " + CLIENT_ENTRY
    );
  }
  return fs__default.existsSync(CLIENT_ENTRY.replace("client.mjs", "cLiEnT.mjs"));
}
function normalizePath$3(id3) {
  return path$n.posix.normalize(isWindows$3 ? slash$1(id3) : id3);
}
async function asyncReplace(input, re3, replacer) {
  let match2;
  let remaining = input;
  let rewritten = "";
  while (match2 = re3.exec(remaining)) {
    rewritten += remaining.slice(0, match2.index);
    rewritten += await replacer(match2);
    remaining = remaining.slice(match2.index + match2[0].length);
  }
  rewritten += remaining;
  return rewritten;
}
function tryStatSync(file) {
  try {
    return fs__default.statSync(file, { throwIfNoEntry: false });
  } catch {
  }
}
function windowsMappedRealpathSync(path22) {
  const realPath = fs__default.realpathSync.native(path22);
  if (realPath.startsWith("\\\\")) {
    for (const [network, volume] of windowsNetworkMap) {
      if (realPath.startsWith(network)) return realPath.replace(network, volume);
    }
  }
  return realPath;
}
function windowsSafeRealPathSync(path22) {
  if (!firstSafeRealPathSyncRun) {
    optimizeSafeRealPathSync();
    firstSafeRealPathSyncRun = true;
  }
  return fs__default.realpathSync(path22);
}
function optimizeSafeRealPathSync() {
  const nodeVersion = process.versions.node.split(".").map(Number);
  if (nodeVersion[0] < 18 || nodeVersion[0] === 18 && nodeVersion[1] < 10) {
    safeRealpathSync = fs__default.realpathSync;
    return;
  }
  try {
    fs__default.realpathSync.native(path$n.resolve("./"));
  } catch (error2) {
    if (error2.message.includes("EISDIR: illegal operation on a directory")) {
      safeRealpathSync = fs__default.realpathSync;
      return;
    }
  }
  exec("net use", (error2, stdout) => {
    if (error2) return;
    const lines = stdout.split("\n");
    for (const line of lines) {
      const m23 = parseNetUseRE.exec(line);
      if (m23) windowsNetworkMap.set(m23[2], m23[1]);
    }
    if (windowsNetworkMap.size === 0) {
      safeRealpathSync = fs__default.realpathSync.native;
    } else {
      safeRealpathSync = windowsMappedRealpathSync;
    }
  });
}
function joinSrcset(ret) {
  return ret.map(({ url: url2, descriptor }) => url2 + (descriptor ? ` ${descriptor}` : "")).join(", ");
}
function splitSrcSetDescriptor(srcs) {
  return splitSrcSet(srcs).map((s12) => {
    const src3 = s12.replace(escapedSpaceCharacters, " ").trim();
    const url2 = imageSetUrlRE.exec(src3)?.[0] ?? "";
    return {
      url: url2,
      descriptor: src3.slice(url2.length).trim()
    };
  }).filter(({ url: url2 }) => !!url2);
}
function processSrcSet(srcs, replacer) {
  return Promise.all(
    splitSrcSetDescriptor(srcs).map(async ({ url: url2, descriptor }) => ({
      url: await replacer({ url: url2, descriptor }),
      descriptor
    }))
  ).then(joinSrcset);
}
function splitSrcSet(srcs) {
  const parts = [];
  const cleanedSrcs = srcs.replace(cleanSrcSetRE, blankReplacer);
  let startIndex = 0;
  let splitIndex;
  do {
    splitIndex = cleanedSrcs.indexOf(",", startIndex);
    parts.push(
      srcs.slice(startIndex, splitIndex !== -1 ? splitIndex : void 0)
    );
    startIndex = splitIndex + 1;
  } while (splitIndex !== -1);
  return parts;
}
function partialEncodeURIPath(uri) {
  if (uri.startsWith("data:")) return uri;
  const filePath = cleanUrl(uri);
  const postfix = filePath !== uri ? uri.slice(filePath.length) : "";
  return filePath.replaceAll("%", "%25") + postfix;
}
function flatten$1(items) {
  return items.reduce((collection, item) => [].concat(collection, item), []);
}
function splitWhen(items, predicate) {
  const result = [[]];
  let groupIndex = 0;
  for (const item of items) {
    if (predicate(item)) {
      groupIndex++;
      result[groupIndex] = [];
    } else {
      result[groupIndex].push(item);
    }
  }
  return result;
}
function isEnoentCodeError(error2) {
  return error2.code === "ENOENT";
}
function createDirentFromStats$1(name2, stats) {
  return new DirentFromStats$1(name2, stats);
}
function unixify(filepath) {
  return filepath.replace(/\\/g, "/");
}
function makeAbsolute(cwd, filepath) {
  return path$h.resolve(cwd, filepath);
}
function removeLeadingDotSegment(entry2) {
  if (entry2.charAt(0) === ".") {
    const secondCharactery = entry2.charAt(1);
    if (secondCharactery === "/" || secondCharactery === "\\") {
      return entry2.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
    }
  }
  return entry2;
}
function escapeWindowsPath(pattern2) {
  return pattern2.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
}
function escapePosixPath(pattern2) {
  return pattern2.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
}
function convertWindowsPathToPattern(filepath) {
  return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
}
function convertPosixPathToPattern(filepath) {
  return escapePosixPath(filepath);
}
function collatePatterns(neg, pos, options2) {
  let onlyNegative = filterPatterns(neg, pos, "-", false) || [];
  let onlyPositive = filterPatterns(pos, neg, "", false) || [];
  let intersected = filterPatterns(neg, pos, "-?", true) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join("|");
}
function splitToRanges(min2, max) {
  let nines = 1;
  let zeros2 = 1;
  let stop = countNines(min2, nines);
  let stops = /* @__PURE__ */ new Set([max]);
  while (min2 <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min2, nines);
  }
  stop = countZeros(max + 1, zeros2) - 1;
  while (min2 < stop && stop <= max) {
    stops.add(stop);
    zeros2 += 1;
    stop = countZeros(max + 1, zeros2) - 1;
  }
  stops = [...stops];
  stops.sort(compare);
  return stops;
}
function rangeToPattern(start2, stop, options2) {
  if (start2 === stop) {
    return { pattern: start2, count: [], digits: 0 };
  }
  let zipped = zip(start2, stop);
  let digits = zipped.length;
  let pattern2 = "";
  let count = 0;
  for (let i14 = 0; i14 < digits; i14++) {
    let [startDigit, stopDigit] = zipped[i14];
    if (startDigit === stopDigit) {
      pattern2 += startDigit;
    } else if (startDigit !== "0" || stopDigit !== "9") {
      pattern2 += toCharacterClass(startDigit, stopDigit);
    } else {
      count++;
    }
  }
  if (count) {
    pattern2 += options2.shorthand === true ? "\\d" : "[0-9]";
  }
  return { pattern: pattern2, count: [count], digits };
}
function splitToPatterns(min2, max, tok, options2) {
  let ranges = splitToRanges(min2, max);
  let tokens = [];
  let start2 = min2;
  let prev;
  for (let i14 = 0; i14 < ranges.length; i14++) {
    let max2 = ranges[i14];
    let obj = rangeToPattern(String(start2), String(max2), options2);
    let zeros2 = "";
    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }
      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start2 = max2 + 1;
      continue;
    }
    if (tok.isPadded) {
      zeros2 = padZeros(max2, tok, options2);
    }
    obj.string = zeros2 + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start2 = max2 + 1;
    prev = obj;
  }
  return tokens;
}
function filterPatterns(arr, comparison, prefix, intersection, options2) {
  let result = [];
  for (let ele of arr) {
    let { string: string4 } = ele;
    if (!intersection && !contains(comparison, "string", string4)) {
      result.push(prefix + string4);
    }
    if (intersection && contains(comparison, "string", string4)) {
      result.push(prefix + string4);
    }
  }
  return result;
}
function zip(a20, b18) {
  let arr = [];
  for (let i14 = 0; i14 < a20.length; i14++) arr.push([a20[i14], b18[i14]]);
  return arr;
}
function compare(a20, b18) {
  return a20 > b18 ? 1 : b18 > a20 ? -1 : 0;
}
function contains(arr, key, val) {
  return arr.some((ele) => ele[key] === val);
}
function countNines(min2, len) {
  return Number(String(min2).slice(0, -len) + "9".repeat(len));
}
function countZeros(integer, zeros2) {
  return integer - integer % Math.pow(10, zeros2);
}
function toQuantifier(digits) {
  let [start2 = 0, stop = ""] = digits;
  if (stop || start2 > 1) {
    return `{${start2 + (stop ? "," + stop : "")}}`;
  }
  return "";
}
function toCharacterClass(a20, b18, options2) {
  return `[${a20}${b18 - a20 === 1 ? "" : "-"}${b18}]`;
}
function hasPadding(str2) {
  return /^-?(0+)\d/.test(str2);
}
function padZeros(value2, tok, options2) {
  if (!tok.isPadded) {
    return value2;
  }
  let diff = Math.abs(tok.maxLen - String(value2).length);
  let relax = options2.relaxZeros !== false;
  switch (diff) {
    case 0:
      return "";
    case 1:
      return relax ? "0?" : "0";
    case 2:
      return relax ? "0{0,2}" : "00";
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}
function isStaticPattern(pattern2, options2 = {}) {
  return !isDynamicPattern(pattern2, options2);
}
function isDynamicPattern(pattern2, options2 = {}) {
  if (pattern2 === "") {
    return false;
  }
  if (options2.caseSensitiveMatch === false || pattern2.includes(ESCAPE_SYMBOL)) {
    return true;
  }
  if (COMMON_GLOB_SYMBOLS_RE.test(pattern2) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern2) || REGEX_GROUP_SYMBOLS_RE.test(pattern2)) {
    return true;
  }
  if (options2.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern2)) {
    return true;
  }
  if (options2.braceExpansion !== false && hasBraceExpansion(pattern2)) {
    return true;
  }
  return false;
}
function hasBraceExpansion(pattern2) {
  const openingBraceIndex = pattern2.indexOf("{");
  if (openingBraceIndex === -1) {
    return false;
  }
  const closingBraceIndex = pattern2.indexOf("}", openingBraceIndex + 1);
  if (closingBraceIndex === -1) {
    return false;
  }
  const braceContent = pattern2.slice(openingBraceIndex, closingBraceIndex);
  return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
}
function convertToPositivePattern(pattern2) {
  return isNegativePattern(pattern2) ? pattern2.slice(1) : pattern2;
}
function convertToNegativePattern(pattern2) {
  return "!" + pattern2;
}
function isNegativePattern(pattern2) {
  return pattern2.startsWith("!") && pattern2[1] !== "(";
}
function isPositivePattern(pattern2) {
  return !isNegativePattern(pattern2);
}
function getNegativePatterns(patterns) {
  return patterns.filter(isNegativePattern);
}
function getPositivePatterns$1(patterns) {
  return patterns.filter(isPositivePattern);
}
function getPatternsInsideCurrentDirectory(patterns) {
  return patterns.filter((pattern2) => !isPatternRelatedToParentDirectory(pattern2));
}
function getPatternsOutsideCurrentDirectory(patterns) {
  return patterns.filter(isPatternRelatedToParentDirectory);
}
function isPatternRelatedToParentDirectory(pattern2) {
  return pattern2.startsWith("..") || pattern2.startsWith("./..");
}
function getBaseDirectory(pattern2) {
  return globParent$1(pattern2, { flipBackslashes: false });
}
function hasGlobStar(pattern2) {
  return pattern2.includes(GLOBSTAR$1);
}
function endsWithSlashGlobStar(pattern2) {
  return pattern2.endsWith("/" + GLOBSTAR$1);
}
function isAffectDepthOfReadingPattern(pattern2) {
  const basename3 = path$g.basename(pattern2);
  return endsWithSlashGlobStar(pattern2) || isStaticPattern(basename3);
}
function expandPatternsWithBraceExpansion(patterns) {
  return patterns.reduce((collection, pattern2) => {
    return collection.concat(expandBraceExpansion(pattern2));
  }, []);
}
function expandBraceExpansion(pattern2) {
  const patterns = micromatch.braces(pattern2, { expand: true, nodupes: true, keepEscaping: true });
  patterns.sort((a20, b18) => a20.length - b18.length);
  return patterns.filter((pattern3) => pattern3 !== "");
}
function getPatternParts(pattern2, options2) {
  let { parts } = micromatch.scan(pattern2, Object.assign(Object.assign({}, options2), { parts: true }));
  if (parts.length === 0) {
    parts = [pattern2];
  }
  if (parts[0].startsWith("/")) {
    parts[0] = parts[0].slice(1);
    parts.unshift("");
  }
  return parts;
}
function makeRe(pattern2, options2) {
  return micromatch.makeRe(pattern2, options2);
}
function convertPatternsToRe(patterns, options2) {
  return patterns.map((pattern2) => makeRe(pattern2, options2));
}
function matchAny(entry2, patternsRe) {
  return patternsRe.some((patternRe) => patternRe.test(entry2));
}
function removeDuplicateSlashes(pattern2) {
  return pattern2.replace(DOUBLE_SLASH_RE$1, "/");
}
function merge2$1() {
  const streamsQueue = [];
  const args = slice.call(arguments);
  let merging = false;
  let options2 = args[args.length - 1];
  if (options2 && !Array.isArray(options2) && options2.pipe == null) {
    args.pop();
  } else {
    options2 = {};
  }
  const doEnd = options2.end !== false;
  const doPipeError = options2.pipeError === true;
  if (options2.objectMode == null) {
    options2.objectMode = true;
  }
  if (options2.highWaterMark == null) {
    options2.highWaterMark = 64 * 1024;
  }
  const mergedStream = PassThrough(options2);
  function addStream() {
    for (let i14 = 0, len = arguments.length; i14 < len; i14++) {
      streamsQueue.push(pauseStreams(arguments[i14], options2));
    }
    mergeStream();
    return this;
  }
  function mergeStream() {
    if (merging) {
      return;
    }
    merging = true;
    let streams = streamsQueue.shift();
    if (!streams) {
      process.nextTick(endStream);
      return;
    }
    if (!Array.isArray(streams)) {
      streams = [streams];
    }
    let pipesCount = streams.length + 1;
    function next() {
      if (--pipesCount > 0) {
        return;
      }
      merging = false;
      mergeStream();
    }
    function pipe2(stream4) {
      function onend() {
        stream4.removeListener("merge2UnpipeEnd", onend);
        stream4.removeListener("end", onend);
        if (doPipeError) {
          stream4.removeListener("error", onerror);
        }
        next();
      }
      function onerror(err) {
        mergedStream.emit("error", err);
      }
      if (stream4._readableState.endEmitted) {
        return next();
      }
      stream4.on("merge2UnpipeEnd", onend);
      stream4.on("end", onend);
      if (doPipeError) {
        stream4.on("error", onerror);
      }
      stream4.pipe(mergedStream, { end: false });
      stream4.resume();
    }
    for (let i14 = 0; i14 < streams.length; i14++) {
      pipe2(streams[i14]);
    }
    next();
  }
  function endStream() {
    merging = false;
    mergedStream.emit("queueDrain");
    if (doEnd) {
      mergedStream.end();
    }
  }
  mergedStream.setMaxListeners(0);
  mergedStream.add = addStream;
  mergedStream.on("unpipe", function(stream4) {
    stream4.emit("merge2UnpipeEnd");
  });
  if (args.length) {
    addStream.apply(null, args);
  }
  return mergedStream;
}
function pauseStreams(streams, options2) {
  if (!Array.isArray(streams)) {
    if (!streams._readableState && streams.pipe) {
      streams = streams.pipe(PassThrough(options2));
    }
    if (!streams._readableState || !streams.pause || !streams.pipe) {
      throw new Error("Only readable stream can be merged.");
    }
    streams.pause();
  } else {
    for (let i14 = 0, len = streams.length; i14 < len; i14++) {
      streams[i14] = pauseStreams(streams[i14], options2);
    }
  }
  return streams;
}
function merge$1(streams) {
  const mergedStream = merge22(streams);
  streams.forEach((stream4) => {
    stream4.once("error", (error2) => mergedStream.emit("error", error2));
  });
  mergedStream.once("close", () => propagateCloseEventToSources(streams));
  mergedStream.once("end", () => propagateCloseEventToSources(streams));
  return mergedStream;
}
function propagateCloseEventToSources(streams) {
  streams.forEach((stream4) => stream4.emit("close"));
}
function isString$1(input) {
  return typeof input === "string";
}
function isEmpty$1(input) {
  return input === "";
}
function generate(input, settings2) {
  const patterns = processPatterns(input, settings2);
  const ignore = processPatterns(settings2.ignore, settings2);
  const positivePatterns = getPositivePatterns(patterns);
  const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);
  const staticPatterns = positivePatterns.filter((pattern2) => utils$a.pattern.isStaticPattern(pattern2, settings2));
  const dynamicPatterns = positivePatterns.filter((pattern2) => utils$a.pattern.isDynamicPattern(pattern2, settings2));
  const staticTasks = convertPatternsToTasks(
    staticPatterns,
    negativePatterns,
    /* dynamic */
    false
  );
  const dynamicTasks = convertPatternsToTasks(
    dynamicPatterns,
    negativePatterns,
    /* dynamic */
    true
  );
  return staticTasks.concat(dynamicTasks);
}
function processPatterns(input, settings2) {
  let patterns = input;
  if (settings2.braceExpansion) {
    patterns = utils$a.pattern.expandPatternsWithBraceExpansion(patterns);
  }
  if (settings2.baseNameMatch) {
    patterns = patterns.map((pattern2) => pattern2.includes("/") ? pattern2 : `**/${pattern2}`);
  }
  return patterns.map((pattern2) => utils$a.pattern.removeDuplicateSlashes(pattern2));
}
function convertPatternsToTasks(positive, negative, dynamic) {
  const tasks2 = [];
  const patternsOutsideCurrentDirectory = utils$a.pattern.getPatternsOutsideCurrentDirectory(positive);
  const patternsInsideCurrentDirectory = utils$a.pattern.getPatternsInsideCurrentDirectory(positive);
  const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
  const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
  tasks2.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
  if ("." in insideCurrentDirectoryGroup) {
    tasks2.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
  } else {
    tasks2.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
  }
  return tasks2;
}
function getPositivePatterns(patterns) {
  return utils$a.pattern.getPositivePatterns(patterns);
}
function getNegativePatternsAsPositive(patterns, ignore) {
  const negative = utils$a.pattern.getNegativePatterns(patterns).concat(ignore);
  const positive = negative.map(utils$a.pattern.convertToPositivePattern);
  return positive;
}
function groupPatternsByBaseDirectory(patterns) {
  const group = {};
  return patterns.reduce((collection, pattern2) => {
    const base = utils$a.pattern.getBaseDirectory(pattern2);
    if (base in collection) {
      collection[base].push(pattern2);
    } else {
      collection[base] = [pattern2];
    }
    return collection;
  }, group);
}
function convertPatternGroupsToTasks(positive, negative, dynamic) {
  return Object.keys(positive).map((base) => {
    return convertPatternGroupToTask(base, positive[base], negative, dynamic);
  });
}
function convertPatternGroupToTask(base, positive, negative, dynamic) {
  return {
    dynamic,
    positive,
    negative,
    base,
    patterns: [].concat(positive, negative.map(utils$a.pattern.convertToNegativePattern))
  };
}
function read$3(path7, settings2, callback) {
  settings2.fs.lstat(path7, (lstatError, lstat2) => {
    if (lstatError !== null) {
      callFailureCallback$2(callback, lstatError);
      return;
    }
    if (!lstat2.isSymbolicLink() || !settings2.followSymbolicLink) {
      callSuccessCallback$2(callback, lstat2);
      return;
    }
    settings2.fs.stat(path7, (statError, stat3) => {
      if (statError !== null) {
        if (settings2.throwErrorOnBrokenSymbolicLink) {
          callFailureCallback$2(callback, statError);
          return;
        }
        callSuccessCallback$2(callback, lstat2);
        return;
      }
      if (settings2.markSymbolicLink) {
        stat3.isSymbolicLink = () => true;
      }
      callSuccessCallback$2(callback, stat3);
    });
  });
}
function callFailureCallback$2(callback, error2) {
  callback(error2);
}
function callSuccessCallback$2(callback, result) {
  callback(null, result);
}
function read$2(path7, settings2) {
  const lstat2 = settings2.fs.lstatSync(path7);
  if (!lstat2.isSymbolicLink() || !settings2.followSymbolicLink) {
    return lstat2;
  }
  try {
    const stat3 = settings2.fs.statSync(path7);
    if (settings2.markSymbolicLink) {
      stat3.isSymbolicLink = () => true;
    }
    return stat3;
  } catch (error2) {
    if (!settings2.throwErrorOnBrokenSymbolicLink) {
      return lstat2;
    }
    throw error2;
  }
}
function stat$4(path7, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === "function") {
    async$1.read(path7, getSettings$2(), optionsOrSettingsOrCallback);
    return;
  }
  async$1.read(path7, getSettings$2(optionsOrSettingsOrCallback), callback);
}
function statSync2(path7, optionsOrSettings) {
  const settings2 = getSettings$2(optionsOrSettings);
  return sync$7.read(path7, settings2);
}
function getSettings$2(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof settings_1$3.default) {
    return settingsOrOptions;
  }
  return new settings_1$3.default(settingsOrOptions);
}
function runParallel(tasks2, cb) {
  let results, pending, keys;
  let isSync = true;
  if (Array.isArray(tasks2)) {
    results = [];
    pending = tasks2.length;
  } else {
    keys = Object.keys(tasks2);
    results = {};
    pending = keys.length;
  }
  function done(err) {
    function end() {
      if (cb) cb(err, results);
      cb = null;
    }
    if (isSync) queueMicrotask$1(end);
    else end();
  }
  function each(i14, err, result) {
    results[i14] = result;
    if (--pending === 0 || err) {
      done(err);
    }
  }
  if (!pending) {
    done(null);
  } else if (keys) {
    keys.forEach(function(key) {
      tasks2[key](function(err, result) {
        each(key, err, result);
      });
    });
  } else {
    tasks2.forEach(function(task, i14) {
      task(function(err, result) {
        each(i14, err, result);
      });
    });
  }
  isSync = false;
}
function createDirentFromStats(name2, stats) {
  return new DirentFromStats2(name2, stats);
}
function joinPathSegments$1(a20, b18, separator) {
  if (a20.endsWith(separator)) {
    return a20 + b18;
  }
  return a20 + separator + b18;
}
function read$1(directory, settings2, callback) {
  if (!settings2.stats && constants_1$1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
    readdirWithFileTypes$1(directory, settings2, callback);
    return;
  }
  readdir$3(directory, settings2, callback);
}
function readdirWithFileTypes$1(directory, settings2, callback) {
  settings2.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
    if (readdirError !== null) {
      callFailureCallback$1(callback, readdirError);
      return;
    }
    const entries = dirents.map((dirent) => ({
      dirent,
      name: dirent.name,
      path: common$9.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
    }));
    if (!settings2.followSymbolicLinks) {
      callSuccessCallback$1(callback, entries);
      return;
    }
    const tasks2 = entries.map((entry2) => makeRplTaskEntry(entry2, settings2));
    rpl(tasks2, (rplError, rplEntries) => {
      if (rplError !== null) {
        callFailureCallback$1(callback, rplError);
        return;
      }
      callSuccessCallback$1(callback, rplEntries);
    });
  });
}
function makeRplTaskEntry(entry2, settings2) {
  return (done) => {
    if (!entry2.dirent.isSymbolicLink()) {
      done(null, entry2);
      return;
    }
    settings2.fs.stat(entry2.path, (statError, stats) => {
      if (statError !== null) {
        if (settings2.throwErrorOnBrokenSymbolicLink) {
          done(statError);
          return;
        }
        done(null, entry2);
        return;
      }
      entry2.dirent = utils$8.fs.createDirentFromStats(entry2.name, stats);
      done(null, entry2);
    });
  };
}
function readdir$3(directory, settings2, callback) {
  settings2.fs.readdir(directory, (readdirError, names) => {
    if (readdirError !== null) {
      callFailureCallback$1(callback, readdirError);
      return;
    }
    const tasks2 = names.map((name2) => {
      const path7 = common$9.joinPathSegments(directory, name2, settings2.pathSegmentSeparator);
      return (done) => {
        fsStat$5.stat(path7, settings2.fsStatSettings, (error2, stats) => {
          if (error2 !== null) {
            done(error2);
            return;
          }
          const entry2 = {
            name: name2,
            path: path7,
            dirent: utils$8.fs.createDirentFromStats(name2, stats)
          };
          if (settings2.stats) {
            entry2.stats = stats;
          }
          done(null, entry2);
        });
      };
    });
    rpl(tasks2, (rplError, entries) => {
      if (rplError !== null) {
        callFailureCallback$1(callback, rplError);
        return;
      }
      callSuccessCallback$1(callback, entries);
    });
  });
}
function callFailureCallback$1(callback, error2) {
  callback(error2);
}
function callSuccessCallback$1(callback, result) {
  callback(null, result);
}
function read(directory, settings2) {
  if (!settings2.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
    return readdirWithFileTypes(directory, settings2);
  }
  return readdir$2(directory, settings2);
}
function readdirWithFileTypes(directory, settings2) {
  const dirents = settings2.fs.readdirSync(directory, { withFileTypes: true });
  return dirents.map((dirent) => {
    const entry2 = {
      dirent,
      name: dirent.name,
      path: common$8.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
    };
    if (entry2.dirent.isSymbolicLink() && settings2.followSymbolicLinks) {
      try {
        const stats = settings2.fs.statSync(entry2.path);
        entry2.dirent = utils$7.fs.createDirentFromStats(entry2.name, stats);
      } catch (error2) {
        if (settings2.throwErrorOnBrokenSymbolicLink) {
          throw error2;
        }
      }
    }
    return entry2;
  });
}
function readdir$2(directory, settings2) {
  const names = settings2.fs.readdirSync(directory);
  return names.map((name2) => {
    const entryPath = common$8.joinPathSegments(directory, name2, settings2.pathSegmentSeparator);
    const stats = fsStat$4.statSync(entryPath, settings2.fsStatSettings);
    const entry2 = {
      name: name2,
      path: entryPath,
      dirent: utils$7.fs.createDirentFromStats(name2, stats)
    };
    if (settings2.stats) {
      entry2.stats = stats;
    }
    return entry2;
  });
}
function scandir(path7, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === "function") {
    async.read(path7, getSettings$1(), optionsOrSettingsOrCallback);
    return;
  }
  async.read(path7, getSettings$1(optionsOrSettingsOrCallback), callback);
}
function scandirSync(path7, optionsOrSettings) {
  const settings2 = getSettings$1(optionsOrSettings);
  return sync$5.read(path7, settings2);
}
function getSettings$1(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof settings_1$2.default) {
    return settingsOrOptions;
  }
  return new settings_1$2.default(settingsOrOptions);
}
function reusify$1(Constructor) {
  var head = new Constructor();
  var tail = head;
  function get() {
    var current = head;
    if (current.next) {
      head = current.next;
    } else {
      head = new Constructor();
      tail = head;
    }
    current.next = null;
    return current;
  }
  function release(obj) {
    tail.next = obj;
    tail = obj;
  }
  return {
    get,
    release
  };
}
function fastqueue(context, worker, _concurrency) {
  if (typeof context === "function") {
    _concurrency = worker;
    worker = context;
    context = null;
  }
  if (!(_concurrency >= 1)) {
    throw new Error("fastqueue concurrency must be equal to or greater than 1");
  }
  var cache2 = reusify(Task);
  var queueHead = null;
  var queueTail = null;
  var _running = 0;
  var errorHandler = null;
  var self2 = {
    push: push2,
    drain: noop$4,
    saturated: noop$4,
    pause,
    paused: false,
    get concurrency() {
      return _concurrency;
    },
    set concurrency(value2) {
      if (!(value2 >= 1)) {
        throw new Error("fastqueue concurrency must be equal to or greater than 1");
      }
      _concurrency = value2;
      if (self2.paused) return;
      for (; queueHead && _running < _concurrency; ) {
        _running++;
        release();
      }
    },
    running,
    resume: resume2,
    idle,
    length,
    getQueue,
    unshift,
    empty: noop$4,
    kill,
    killAndDrain,
    error: error2
  };
  return self2;
  function running() {
    return _running;
  }
  function pause() {
    self2.paused = true;
  }
  function length() {
    var current = queueHead;
    var counter = 0;
    while (current) {
      current = current.next;
      counter++;
    }
    return counter;
  }
  function getQueue() {
    var current = queueHead;
    var tasks2 = [];
    while (current) {
      tasks2.push(current.value);
      current = current.next;
    }
    return tasks2;
  }
  function resume2() {
    if (!self2.paused) return;
    self2.paused = false;
    if (queueHead === null) {
      _running++;
      release();
      return;
    }
    for (; queueHead && _running < _concurrency; ) {
      _running++;
      release();
    }
  }
  function idle() {
    return _running === 0 && self2.length() === 0;
  }
  function push2(value2, done) {
    var current = cache2.get();
    current.context = context;
    current.release = release;
    current.value = value2;
    current.callback = done || noop$4;
    current.errorHandler = errorHandler;
    if (_running >= _concurrency || self2.paused) {
      if (queueTail) {
        queueTail.next = current;
        queueTail = current;
      } else {
        queueHead = current;
        queueTail = current;
        self2.saturated();
      }
    } else {
      _running++;
      worker.call(context, current.value, current.worked);
    }
  }
  function unshift(value2, done) {
    var current = cache2.get();
    current.context = context;
    current.release = release;
    current.value = value2;
    current.callback = done || noop$4;
    current.errorHandler = errorHandler;
    if (_running >= _concurrency || self2.paused) {
      if (queueHead) {
        current.next = queueHead;
        queueHead = current;
      } else {
        queueHead = current;
        queueTail = current;
        self2.saturated();
      }
    } else {
      _running++;
      worker.call(context, current.value, current.worked);
    }
  }
  function release(holder) {
    if (holder) {
      cache2.release(holder);
    }
    var next = queueHead;
    if (next && _running <= _concurrency) {
      if (!self2.paused) {
        if (queueTail === queueHead) {
          queueTail = null;
        }
        queueHead = next.next;
        next.next = null;
        worker.call(context, next.value, next.worked);
        if (queueTail === null) {
          self2.empty();
        }
      } else {
        _running--;
      }
    } else if (--_running === 0) {
      self2.drain();
    }
  }
  function kill() {
    queueHead = null;
    queueTail = null;
    self2.drain = noop$4;
  }
  function killAndDrain() {
    queueHead = null;
    queueTail = null;
    self2.drain();
    self2.drain = noop$4;
  }
  function error2(handler) {
    errorHandler = handler;
  }
}
function noop$4() {
}
function Task() {
  this.value = null;
  this.callback = noop$4;
  this.next = null;
  this.release = noop$4;
  this.context = null;
  this.errorHandler = null;
  var self2 = this;
  this.worked = function worked(err, result) {
    var callback = self2.callback;
    var errorHandler = self2.errorHandler;
    var val = self2.value;
    self2.value = null;
    self2.callback = noop$4;
    if (self2.errorHandler) {
      errorHandler(err, val);
    }
    callback.call(self2.context, err, result);
    self2.release(self2);
  };
}
function queueAsPromised(context, worker, _concurrency) {
  if (typeof context === "function") {
    _concurrency = worker;
    worker = context;
    context = null;
  }
  function asyncWrapper(arg, cb) {
    worker.call(this, arg).then(function(res) {
      cb(null, res);
    }, cb);
  }
  var queue2 = fastqueue(context, asyncWrapper, _concurrency);
  var pushCb = queue2.push;
  var unshiftCb = queue2.unshift;
  queue2.push = push2;
  queue2.unshift = unshift;
  queue2.drained = drained;
  return queue2;
  function push2(value2) {
    var p20 = new Promise(function(resolve5, reject) {
      pushCb(value2, function(err, result) {
        if (err) {
          reject(err);
          return;
        }
        resolve5(result);
      });
    });
    p20.catch(noop$4);
    return p20;
  }
  function unshift(value2) {
    var p20 = new Promise(function(resolve5, reject) {
      unshiftCb(value2, function(err, result) {
        if (err) {
          reject(err);
          return;
        }
        resolve5(result);
      });
    });
    p20.catch(noop$4);
    return p20;
  }
  function drained() {
    if (queue2.idle()) {
      return new Promise(function(resolve5) {
        resolve5();
      });
    }
    var previousDrain = queue2.drain;
    var p20 = new Promise(function(resolve5) {
      queue2.drain = function() {
        previousDrain();
        resolve5();
      };
    });
    return p20;
  }
}
function isFatalError(settings2, error2) {
  if (settings2.errorFilter === null) {
    return true;
  }
  return !settings2.errorFilter(error2);
}
function isAppliedFilter(filter2, value2) {
  return filter2 === null || filter2(value2);
}
function replacePathSegmentSeparator(filepath, separator) {
  return filepath.split(/[/\\]/).join(separator);
}
function joinPathSegments(a20, b18, separator) {
  if (a20 === "") {
    return b18;
  }
  if (a20.endsWith(separator)) {
    return a20 + b18;
  }
  return a20 + separator + b18;
}
function callFailureCallback(callback, error2) {
  callback(error2);
}
function callSuccessCallback(callback, entries) {
  callback(null, entries);
}
function walk$2(directory, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === "function") {
    new async_1$2.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
    return;
  }
  new async_1$2.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
}
function walkSync(directory, optionsOrSettings) {
  const settings2 = getSettings(optionsOrSettings);
  const provider2 = new sync_1$2.default(directory, settings2);
  return provider2.read();
}
function walkStream(directory, optionsOrSettings) {
  const settings2 = getSettings(optionsOrSettings);
  const provider2 = new stream_1$4.default(directory, settings2);
  return provider2.read();
}
function getSettings(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof settings_1$1.default) {
    return settingsOrOptions;
  }
  return new settings_1$1.default(settingsOrOptions);
}
async function FastGlob(source, options2) {
  assertPatternsInput(source);
  const works = getWorks(source, async_1.default, options2);
  const result = await Promise.all(works);
  return utils.array.flatten(result);
}
function getWorks(source, _Provider, options2) {
  const patterns = [].concat(source);
  const settings2 = new settings_1.default(options2);
  const tasks2 = taskManager.generate(patterns, settings2);
  const provider2 = new _Provider(settings2);
  return tasks2.map(provider2.read, provider2);
}
function assertPatternsInput(input) {
  const source = [].concat(input);
  const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
  if (!isValidSource) {
    throw new TypeError("Patterns must be a string (non empty) or an array of strings");
  }
}
function getDefaultSearchPlaces(name2, sync2) {
  return [
    "package.json",
    `.${name2}rc.json`,
    `.${name2}rc.js`,
    `.${name2}rc.cjs`,
    ...sync2 ? [] : [`.${name2}rc.mjs`],
    `.config/${name2}rc`,
    `.config/${name2}rc.json`,
    `.config/${name2}rc.js`,
    `.config/${name2}rc.cjs`,
    ...sync2 ? [] : [`.config/${name2}rc.mjs`],
    `${name2}.config.js`,
    `${name2}.config.cjs`,
    ...sync2 ? [] : [`${name2}.config.mjs`]
  ];
}
function parentDir(p20) {
  return path$a.dirname(p20) || path$a.sep;
}
function getOptions(name2, options2, sync2) {
  const conf = {
    stopDir: os$3.homedir(),
    searchPlaces: getDefaultSearchPlaces(name2, sync2),
    ignoreEmptySearchPlaces: true,
    cache: true,
    transform: (x22) => x22,
    packageProp: [name2],
    ...options2,
    loaders: {
      ...sync2 ? defaultLoadersSync : defaultLoaders,
      ...options2.loaders
    }
  };
  conf.searchPlaces.forEach((place) => {
    const key = path$a.extname(place) || "noExt";
    const loader = conf.loaders[key];
    if (!loader) {
      throw new Error(`Missing loader for extension "${place}"`);
    }
    if (typeof loader !== "function") {
      throw new Error(
        `Loader for extension "${place}" is not a function: Received ${typeof loader}.`
      );
    }
  });
  return conf;
}
function getPackageProp(props, obj) {
  if (typeof props === "string" && props in obj) return obj[props];
  return (Array.isArray(props) ? props : props.split(".")).reduce(
    (acc, prop) => acc === void 0 ? acc : acc[prop],
    obj
  ) || null;
}
function validateFilePath(filepath) {
  if (!filepath) throw new Error("load must pass a non-empty string");
}
function validateLoader(loader, ext2) {
  if (!loader) throw new Error(`No loader specified for extension "${ext2}"`);
  if (typeof loader !== "function") throw new Error("loader is not a function");
}
function isCollection$1(node3) {
  if (node3 && typeof node3 === "object")
    switch (node3[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode$1(node3) {
  if (node3 && typeof node3 === "object")
    switch (node3[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR$1:
      case SEQ:
        return true;
    }
  return false;
}
function visit$1(node3, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node3)) {
    const cd = visit_(null, node3.contents, visitor_, Object.freeze([node3]));
    if (cd === REMOVE$1)
      node3.contents = null;
  } else
    visit_(null, node3, visitor_, Object.freeze([]));
}
function visit_(key, node3, visitor, path7) {
  const ctrl = callVisitor(key, node3, visitor, path7);
  if (isNode$1(ctrl) || isPair(ctrl)) {
    replaceNode(key, path7, ctrl);
    return visit_(key, ctrl, visitor, path7);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node3)) {
      path7 = Object.freeze(path7.concat(node3));
      for (let i14 = 0; i14 < node3.items.length; ++i14) {
        const ci = visit_(i14, node3.items[i14], visitor, path7);
        if (typeof ci === "number")
          i14 = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node3.items.splice(i14, 1);
          i14 -= 1;
        }
      }
    } else if (isPair(node3)) {
      path7 = Object.freeze(path7.concat(node3));
      const ck = visit_("key", node3.key, visitor, path7);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node3.key = null;
      const cv = visit_("value", node3.value, visitor, path7);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node3.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node3, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node3)) {
    const cd = await visitAsync_(null, node3.contents, visitor_, Object.freeze([node3]));
    if (cd === REMOVE$1)
      node3.contents = null;
  } else
    await visitAsync_(null, node3, visitor_, Object.freeze([]));
}
async function visitAsync_(key, node3, visitor, path7) {
  const ctrl = await callVisitor(key, node3, visitor, path7);
  if (isNode$1(ctrl) || isPair(ctrl)) {
    replaceNode(key, path7, ctrl);
    return visitAsync_(key, ctrl, visitor, path7);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node3)) {
      path7 = Object.freeze(path7.concat(node3));
      for (let i14 = 0; i14 < node3.items.length; ++i14) {
        const ci = await visitAsync_(i14, node3.items[i14], visitor, path7);
        if (typeof ci === "number")
          i14 = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node3.items.splice(i14, 1);
          i14 -= 1;
        }
      }
    } else if (isPair(node3)) {
      path7 = Object.freeze(path7.concat(node3));
      const ck = await visitAsync_("key", node3.key, visitor, path7);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node3.key = null;
      const cv = await visitAsync_("value", node3.value, visitor, path7);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node3.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node3, visitor, path7) {
  if (typeof visitor === "function")
    return visitor(key, node3, path7);
  if (isMap(node3))
    return visitor.Map?.(key, node3, path7);
  if (isSeq(node3))
    return visitor.Seq?.(key, node3, path7);
  if (isPair(node3))
    return visitor.Pair?.(key, node3, path7);
  if (isScalar$1(node3))
    return visitor.Scalar?.(key, node3, path7);
  if (isAlias(node3))
    return visitor.Alias?.(key, node3, path7);
  return void 0;
}
function replaceNode(key, path7, node3) {
  const parent = path7[path7.length - 1];
  if (isCollection$1(parent)) {
    parent.items[key] = node3;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node3;
    else
      parent.value = node3;
  } else if (isDocument(parent)) {
    parent.contents = node3;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root3) {
  const anchors = /* @__PURE__ */ new Set();
  visit$1(root3, {
    Value(_key, node3) {
      if (node3.anchor)
        anchors.add(node3.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i14 = 1; true; ++i14) {
    const name2 = `${prefix}${i14}`;
    if (!exclude.has(name2))
      return name2;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar$1(ref.node) || isCollection$1(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error2 = new Error("Failed to resolve repeated object (this should not happen)");
          error2.source = source;
          throw error2;
        }
      }
    },
    sourceObjects
  };
}
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i14 = 0, len = val.length; i14 < len; ++i14) {
        const v0 = val[i14];
        const v1 = applyReviver(reviver, val, String(i14), v0);
        if (v1 === void 0)
          delete val[i14];
        else if (v1 !== v0)
          val[i14] = v1;
      }
    } else if (val instanceof Map) {
      for (const k13 of Array.from(val.keys())) {
        const v0 = val.get(k13);
        const v1 = applyReviver(reviver, val, k13, v0);
        if (v1 === void 0)
          val.delete(k13);
        else if (v1 !== v0)
          val.set(k13, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k13, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k13, v0);
        if (v1 === void 0)
          delete val[k13];
        else if (v1 !== v0)
          val[k13] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}
function toJS(value2, arg, ctx) {
  if (Array.isArray(value2))
    return value2.map((v15, i14) => toJS(v15, String(i14), ctx));
  if (value2 && typeof value2.toJSON === "function") {
    if (!ctx || !hasAnchor(value2))
      return value2.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value2, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value2.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value2 === "bigint" && !ctx?.keep)
    return Number(value2);
  return value2;
}
function getAliasCount(doc, node3, anchors) {
  if (isAlias(node3)) {
    const source = node3.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection$1(node3)) {
    let count = 0;
    for (const item of node3.items) {
      const c16 = getAliasCount(doc, item, anchors);
      if (c16 > count)
        count = c16;
    }
    return count;
  } else if (isPair(node3)) {
    const kc = getAliasCount(doc, node3.key, anchors);
    const vc = getAliasCount(doc, node3.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
function findTagObject(value2, tagName, tags) {
  if (tagName) {
    const match2 = tags.filter((t) => t.tag === tagName);
    const tagObj = match2.find((t) => !t.format) ?? match2[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => t.identify?.(value2) && !t.format);
}
function createNode(value2, tagName, ctx) {
  if (isDocument(value2))
    value2 = value2.contents;
  if (isNode$1(value2))
    return value2;
  if (isPair(value2)) {
    const map = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
    map.items.push(value2);
    return map;
  }
  if (value2 instanceof String || value2 instanceof Number || value2 instanceof Boolean || typeof BigInt !== "undefined" && value2 instanceof BigInt) {
    value2 = value2.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema2, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value2 && typeof value2 === "object") {
    ref = sourceObjects.get(value2);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value2);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value2, ref);
    }
  }
  if (tagName?.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value2, tagName, schema2.tags);
  if (!tagObj) {
    if (value2 && typeof value2.toJSON === "function") {
      value2 = value2.toJSON();
    }
    if (!value2 || typeof value2 !== "object") {
      const node4 = new Scalar(value2);
      if (ref)
        ref.node = node4;
      return node4;
    }
    tagObj = value2 instanceof Map ? schema2[MAP] : Symbol.iterator in Object(value2) ? schema2[SEQ] : schema2[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node3 = tagObj?.createNode ? tagObj.createNode(ctx.schema, value2, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value2, ctx) : new Scalar(value2);
  if (tagName)
    node3.tag = tagName;
  else if (!tagObj.default)
    node3.tag = tagObj.tag;
  if (ref)
    ref.node = node3;
  return node3;
}
function collectionFromPath(schema2, path7, value2) {
  let v15 = value2;
  for (let i14 = path7.length - 1; i14 >= 0; --i14) {
    const k13 = path7[i14];
    if (typeof k13 === "number" && Number.isInteger(k13) && k13 >= 0) {
      const a20 = [];
      a20[k13] = v15;
      v15 = a20;
    } else {
      v15 = /* @__PURE__ */ new Map([[k13, v15]]);
    }
  }
  return createNode(v15, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema2,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
function indentComment(comment3, indent) {
  if (/^\n+$/.test(comment3))
    return comment3.substring(1);
  return indent ? comment3.replace(/^(?! *$)/gm, indent) : comment3;
}
function foldFlowLines(text, indent, mode2 = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  if (lineWidth < minContentWidth)
    minContentWidth = 0;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i14 = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode2 === FOLD_BLOCK) {
    i14 = consumeMoreIndentedLines(text, i14, indent.length);
    if (i14 !== -1)
      end = i14 + endStep;
  }
  for (let ch; ch = text[i14 += 1]; ) {
    if (mode2 === FOLD_QUOTED && ch === "\\") {
      escStart = i14;
      switch (text[i14 + 1]) {
        case "x":
          i14 += 3;
          break;
        case "u":
          i14 += 5;
          break;
        case "U":
          i14 += 9;
          break;
        default:
          i14 += 1;
      }
      escEnd = i14;
    }
    if (ch === "\n") {
      if (mode2 === FOLD_BLOCK)
        i14 = consumeMoreIndentedLines(text, i14, indent.length);
      end = i14 + indent.length + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i14 + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i14;
      }
      if (i14 >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode2 === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i14 += 1];
            overflow = true;
          }
          const j16 = i14 > escEnd + 1 ? i14 - 2 : escStart - 1;
          if (escapedFolds[j16])
            return text;
          folds.push(j16);
          escapedFolds[j16] = true;
          end = j16 + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i15 = 0; i15 < folds.length; ++i15) {
    const fold = folds[i15];
    const end2 = folds[i15 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode2 === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i14, indent) {
  let end = i14;
  let start2 = i14 + 1;
  let ch = text[start2];
  while (ch === " " || ch === "	") {
    if (i14 < start2 + indent) {
      ch = text[++i14];
    } else {
      do {
        ch = text[++i14];
      } while (ch && ch !== "\n");
      end = i14;
      start2 = i14 + 1;
      ch = text[start2];
    }
  }
  return end;
}
function lineLengthOverLimit(str2, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str2.length;
  if (strLen <= limit)
    return false;
  for (let i14 = 0, start2 = 0; i14 < strLen; ++i14) {
    if (str2[i14] === "\n") {
      if (i14 - start2 > limit)
        return true;
      start2 = i14 + 1;
      if (strLen - start2 <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value2, ctx) {
  const json = JSON.stringify(value2);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value2) ? "  " : "");
  let str2 = "";
  let start2 = 0;
  for (let i14 = 0, ch = json[i14]; ch; ch = json[++i14]) {
    if (ch === " " && json[i14 + 1] === "\\" && json[i14 + 2] === "n") {
      str2 += json.slice(start2, i14) + "\\ ";
      i14 += 1;
      start2 = i14;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i14 + 1]) {
        case "u":
          {
            str2 += json.slice(start2, i14);
            const code = json.substr(i14 + 2, 4);
            switch (code) {
              case "0000":
                str2 += "\\0";
                break;
              case "0007":
                str2 += "\\a";
                break;
              case "000b":
                str2 += "\\v";
                break;
              case "001b":
                str2 += "\\e";
                break;
              case "0085":
                str2 += "\\N";
                break;
              case "00a0":
                str2 += "\\_";
                break;
              case "2028":
                str2 += "\\L";
                break;
              case "2029":
                str2 += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str2 += "\\x" + code.substr(2);
                else
                  str2 += json.substr(i14, 6);
            }
            i14 += 5;
            start2 = i14 + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i14 + 2] === '"' || json.length < minMultiLineLength) {
            i14 += 1;
          } else {
            str2 += json.slice(start2, i14) + "\n\n";
            while (json[i14 + 2] === "\\" && json[i14 + 3] === "n" && json[i14 + 4] !== '"') {
              str2 += "\n";
              i14 += 2;
            }
            str2 += indent;
            if (json[i14 + 2] === " ")
              str2 += "\\";
            i14 += 1;
            start2 = i14 + 1;
          }
          break;
        default:
          i14 += 1;
      }
  }
  str2 = start2 ? str2 + json.slice(start2) : json;
  return implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value2, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value2.includes("\n") || /[ \t]\n|\n[ \t]/.test(value2))
    return doubleQuotedString(value2, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value2) ? "  " : "");
  const res = "'" + value2.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value2, ctx) {
  const { singleQuote: singleQuote3 } = ctx.options;
  let qs2;
  if (singleQuote3 === false)
    qs2 = doubleQuotedString;
  else {
    const hasDouble = value2.includes('"');
    const hasSingle = value2.includes("'");
    if (hasDouble && !hasSingle)
      qs2 = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs2 = doubleQuotedString;
    else
      qs2 = singleQuote3 ? singleQuotedString : doubleQuotedString;
  }
  return qs2(value2, ctx);
}
function blockString({ comment: comment3, type, value: value2 }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value2) || /^\s*$/.test(value2)) {
    return quotedString(value2, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value2) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value2, lineWidth, indent.length);
  if (!value2)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value2.length; endStart > 0; --endStart) {
    const ch = value2[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value2.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value2 === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value2 = value2.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value2.length; ++startEnd) {
    const ch = value2[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start2 = value2.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start2) {
    value2 = value2.substring(start2.length);
    start2 = start2.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment3) {
    header += " " + commentString(comment3.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value2 = value2.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start2}${value2}${end}`;
  }
  value2 = value2.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start2}${value2}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx, true));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value: value2 } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value2.includes("\n") || inFlow && /[[\]{},]/.test(value2)) {
    return quotedString(value2, ctx);
  }
  if (!value2 || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value2)) {
    return implicitKey || inFlow || !value2.includes("\n") ? quotedString(value2, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value2.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value2)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value2, ctx);
    }
  }
  const str2 = value2.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag3) => tag3.default && tag3.tag !== "tag:yaml.org,2002:str" && tag3.test?.test(str2);
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || compat?.some(test))
      return quotedString(value2, ctx);
  }
  return implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}
function createStringifyContext(doc, options2) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options2);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  if (item.tag) {
    const match2 = tags.filter((t) => t.tag === item.tag);
    if (match2.length > 0)
      return match2.find((t) => t.format === item.format) ?? match2[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar$1(item)) {
    obj = item.value;
    const match2 = tags.filter((t) => t.identify?.(obj));
    tagObj = match2.find((t) => t.format === item.format) ?? match2.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name2 = obj?.constructor?.name ?? typeof obj;
    throw new Error(`Tag not resolved for ${name2} value`);
  }
  return tagObj;
}
function stringifyProps(node3, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar$1(node3) || isCollection$1(node3)) && node3.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag3 = node3.tag ? node3.tag : tagObj.default ? null : tagObj.tag;
  if (tag3)
    props.push(doc.directives.tagString(tag3));
  return props.join(" ");
}
function stringify$2(item, ctx, onComment, onChompKeep) {
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if (ctx.resolvedAliases?.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node3 = isNode$1(item) ? item : ctx.doc.createNode(item, { onTagObj: (o10) => tagObj = o10 });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node3);
  const props = stringifyProps(node3, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str2 = typeof tagObj.stringify === "function" ? tagObj.stringify(node3, ctx, onComment, onChompKeep) : isScalar$1(node3) ? stringifyString(node3, ctx, onComment, onChompKeep) : node3.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str2;
  return isScalar$1(node3) || str2[0] === "{" || str2[0] === "[" ? `${props} ${str2}` : `${props}
${ctx.indent}${str2}`;
}
function stringifyPair({ key, value: value2 }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode$1(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection$1(key) || !isNode$1(key) && typeof key === "object") {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value2 == null && !ctx.inFlow || isCollection$1(key) || (isScalar$1(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str2 = stringify$2(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str2.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value2 == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str2 === "" ? "?" : explicitKey ? `? ${str2}` : str2;
    }
  } else if (allNullValues && !simpleKeys || value2 == null && explicitKey) {
    str2 = `? ${str2}`;
    if (keyComment && !keyCommentDone) {
      str2 += lineComment(str2, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str2;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str2 += lineComment(str2, ctx.indent, commentString(keyComment));
    str2 = `? ${str2}
${indent}:`;
  } else {
    str2 = `${str2}:`;
    if (keyComment)
      str2 += lineComment(str2, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode$1(value2)) {
    vsb = !!value2.spaceBefore;
    vcb = value2.commentBefore;
    valueComment = value2.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value2 && typeof value2 === "object")
      value2 = doc.createNode(value2);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar$1(value2))
    ctx.indentAtStart = str2.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value2) && !value2.flow && !value2.tag && !value2.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify$2(value2, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n")
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection$1(value2)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = ctx.inFlow ?? value2.flow ?? value2.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str2 += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str2 += lineComment(str2, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str2;
}
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}
function addPairToJSMap(ctx, map, { key, value: value2 }) {
  if (ctx?.doc.schema.merge && isMergeKey(key)) {
    value2 = isAlias(value2) ? value2.resolve(ctx.doc) : value2;
    if (isSeq(value2))
      for (const it of value2.items)
        mergeToJSMap(ctx, map, it);
    else if (Array.isArray(value2))
      for (const it of value2)
        mergeToJSMap(ctx, map, it);
    else
      mergeToJSMap(ctx, map, value2);
  } else {
    const jsKey = toJS(key, "", ctx);
    if (map instanceof Map) {
      map.set(jsKey, toJS(value2, jsKey, ctx));
    } else if (map instanceof Set) {
      map.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value2, stringKey, ctx);
      if (stringKey in map)
        Object.defineProperty(map, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map[stringKey] = jsValue;
    }
  }
  return map;
}
function mergeToJSMap(ctx, map, value2) {
  const source = ctx && isAlias(value2) ? value2.resolve(ctx.doc) : value2;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value3] of srcMap) {
    if (map instanceof Map) {
      if (!map.has(key))
        map.set(key, value3);
    } else if (map instanceof Set) {
      map.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
      Object.defineProperty(map, key, {
        value: value3,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode$1(key) && ctx?.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node3 of ctx.anchors.keys())
      strCtx.anchors.add(node3.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
function createPair(key, value2, ctx) {
  const k13 = createNode(key, void 0, ctx);
  const v15 = createNode(value2, void 0, ctx);
  return new Pair(k13, v15);
}
function stringifyCollection(collection, ctx, options2) {
  const flow = ctx.inFlow ?? collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options2);
}
function stringifyBlockCollection({ comment: comment3, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i14 = 0; i14 < items.length; ++i14) {
    const item = items[i14];
    let comment4 = null;
    if (isNode$1(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment4 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode$1(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str3 = stringify$2(item, itemCtx, () => comment4 = null, () => chompKeep = true);
    if (comment4)
      str3 += lineComment(str3, itemIndent, commentString(comment4));
    if (chompKeep && comment4)
      chompKeep = false;
    lines.push(blockItemPrefix + str3);
  }
  let str2;
  if (lines.length === 0) {
    str2 = flowChars.start + flowChars.end;
  } else {
    str2 = lines[0];
    for (let i14 = 1; i14 < lines.length; ++i14) {
      const line = lines[i14];
      str2 += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment3) {
    str2 += "\n" + indentComment(commentString(comment3), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str2;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i14 = 0; i14 < items.length; ++i14) {
    const item = items[i14];
    let comment3 = null;
    if (isNode$1(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment3 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode$1(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode$1(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment3 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik?.comment) {
        comment3 = ik.comment;
      }
    }
    if (comment3)
      reqNewline = true;
    let str2 = stringify$2(item, itemCtx, () => comment3 = null);
    if (i14 < items.length - 1)
      str2 += ",";
    if (comment3)
      str2 += lineComment(str2, itemIndent, commentString(comment3));
    if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
      reqNewline = true;
    lines.push(str2);
    linesAtValue = lines.length;
  }
  const { start: start2, end } = flowChars;
  if (lines.length === 0) {
    return start2 + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str2 = start2;
      for (const line of lines)
        str2 += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str2}
${indent}${end}`;
    } else {
      return `${start2}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment3, chompKeep) {
  if (comment3 && chompKeep)
    comment3 = comment3.replace(/^\n+/, "");
  if (comment3) {
    const ic = indentComment(commentString(comment3), indent);
    lines.push(ic.trimStart());
  }
}
function findPair(items, key) {
  const k13 = isScalar$1(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k13)
        return it;
      if (isScalar$1(it.key) && it.key.value === k13)
        return it;
    }
  }
  return void 0;
}
function asItemIndex(key) {
  let idx = isScalar$1(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
function stringifyNumber({ format: format2, minFractionDigits, tag: tag3, value: value2 }) {
  if (typeof value2 === "bigint")
    return String(value2);
  const num = typeof value2 === "number" ? value2 : Number(value2);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n14 = JSON.stringify(value2);
  if (!format2 && minFractionDigits && (!tag3 || tag3 === "tag:yaml.org,2002:float") && /^\d/.test(n14)) {
    let i14 = n14.indexOf(".");
    if (i14 < 0) {
      i14 = n14.length;
      n14 += ".";
    }
    let d20 = minFractionDigits - (n14.length - i14 - 1);
    while (d20-- > 0)
      n14 += "0";
  }
  return n14;
}
function intStringify$1(node3, radix, prefix) {
  const { value: value2 } = node3;
  if (intIdentify$2(value2) && value2 >= 0)
    return prefix + value2.toString(radix);
  return stringifyNumber(node3);
}
function intIdentify$1(value2) {
  return typeof value2 === "bigint" || Number.isInteger(value2);
}
function resolvePairs(seq2, onError2) {
  if (isSeq(seq2)) {
    for (let i14 = 0; i14 < seq2.items.length; ++i14) {
      let item = seq2.items[i14];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError2("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value ?? pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i14] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError2("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema2, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema2);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i14 = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i14++), it);
      let key, value2;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value2 = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value2 = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value2, ctx));
    }
  return pairs2;
}
function boolStringify({ value: value2, source }, ctx) {
  const boolObj = value2 ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value2 ? ctx.options.trueStr : ctx.options.falseStr;
}
function intResolve(str2, offset, radix, { intAsBigInt }) {
  const sign = str2[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str2 = str2.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str2 = `0b${str2}`;
        break;
      case 8:
        str2 = `0o${str2}`;
        break;
      case 16:
        str2 = `0x${str2}`;
        break;
    }
    const n15 = BigInt(str2);
    return sign === "-" ? BigInt(-1) * n15 : n15;
  }
  const n14 = parseInt(str2, radix);
  return sign === "-" ? -1 * n14 : n14;
}
function intStringify(node3, radix, prefix) {
  const { value: value2 } = node3;
  if (intIdentify(value2)) {
    const str2 = value2.toString(radix);
    return value2 < 0 ? "-" + prefix + str2.substr(1) : prefix + str2;
  }
  return stringifyNumber(node3);
}
function parseSexagesimal(str2, asBigInt) {
  const sign = str2[0];
  const parts = sign === "-" || sign === "+" ? str2.substring(1) : str2;
  const num = (n14) => asBigInt ? BigInt(n14) : Number(n14);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p20) => res2 * num(60) + num(p20), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node3) {
  let { value: value2 } = node3;
  let num = (n14) => n14;
  if (typeof value2 === "bigint")
    num = (n14) => BigInt(n14);
  else if (isNaN(value2) || !isFinite(value2))
    return stringifyNumber(node3);
  let sign = "";
  if (value2 < 0) {
    sign = "-";
    value2 *= num(-1);
  }
  const _60 = num(60);
  const parts = [value2 % _60];
  if (value2 < 60) {
    parts.unshift(0);
  } else {
    value2 = (value2 - parts[0]) / _60;
    parts.unshift(value2 % _60);
    if (value2 >= 60) {
      value2 = (value2 - parts[0]) / _60;
      parts.unshift(value2);
    }
  }
  return sign + parts.map((n14) => String(n14).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag3 of customTags)
      tags = tags.concat(tag3);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag3) => {
    if (typeof tag3 !== "string")
      return tag3;
    const tagObj = tagsByName[tag3];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag3}"; use one of ${keys}`);
  });
}
function stringifyDocument(doc, options2) {
  const lines = [];
  let hasDirectives = options2.directives === true;
  if (options2.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options2);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode$1(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify$2(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify$2(doc.contents, ctx));
  }
  if (doc.directives?.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
function assertCollection(contents2) {
  if (isCollection$1(contents2))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
function resolveProps(tokens, { flow, indicator, next, offset, onError: onError2, parentIndent, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment3 = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let tab2 = null;
  let anchor = null;
  let tag3 = null;
  let newlineAfterProp = null;
  let comma4 = null;
  let found = null;
  let start2 = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError2(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    if (tab2) {
      if (atNewline && token.type !== "comment" && token.type !== "newline") {
        onError2(tab2, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      }
      tab2 = null;
    }
    switch (token.type) {
      case "space":
        if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
          tab2 = token;
        }
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError2(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment3)
          comment3 = cb;
        else
          comment3 += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment3)
            comment3 += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag3)
          newlineAfterProp = token;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError2(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError2(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start2 === null)
          start2 = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag3)
          onError2(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag3 = token;
        if (start2 === null)
          start2 = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag3)
          onError2(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError2(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
        found = token;
        atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma4)
            onError2(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma4 = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      // else fallthrough
      default:
        onError2(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
    onError2(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  }
  if (tab2 && (atNewline && tab2.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
    onError2(tab2, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
  return {
    comma: comma4,
    found,
    spaceBefore,
    comment: comment3,
    hasNewline,
    anchor,
    tag: tag3,
    newlineAfterProp,
    end,
    start: start2 ?? end
  };
}
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
function flowIndentCheck(indent, fc, onError2) {
  if (fc?.type === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError2(end, "BAD_INDENT", msg, true);
    }
  }
}
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a20, b18) => a20 === b18 || isScalar$1(a20) && isScalar$1(b18) && a20.value === b18.value && !(a20.value === "<<" && ctx.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError2, tag3) {
  const NodeClass = tag3?.nodeClass ?? YAMLMap;
  const map = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start: start2, key, sep: sep2, value: value2 } = collItem;
    const keyProps = resolveProps(start2, {
      indicator: "explicit-key-ind",
      next: key ?? sep2?.[0],
      offset,
      onError: onError2,
      parentIndent: bm.indent,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError2(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError2(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep2) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map.comment)
            map.comment += "\n" + keyProps.comment;
          else
            map.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.newlineAfterProp || containsNewline(key)) {
        onError2(key ?? start2[start2.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (keyProps.found?.indent !== bm.indent) {
      onError2(offset, "BAD_INDENT", startColMsg);
    }
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError2) : composeEmptyNode2(ctx, keyStart, start2, null, keyProps, onError2);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError2);
    if (mapIncludes(ctx, map.items, keyNode))
      onError2(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep2 ?? [], {
      indicator: "map-value-ind",
      next: value2,
      offset: keyNode.range[2],
      onError: onError2,
      parentIndent: bm.indent,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if (value2?.type === "block-map" && !valueProps.hasNewline)
          onError2(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError2(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value2 ? composeNode2(ctx, value2, valueProps, onError2) : composeEmptyNode2(ctx, offset, sep2, null, valueProps, onError2);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value2, onError2);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map.items.push(pair);
    } else {
      if (implicitKey)
        onError2(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError2(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map.range = [bm.offset, offset, commentEnd ?? offset];
  return map;
}
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError2, tag3) {
  const NodeClass = tag3?.nodeClass ?? YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const { start: start2, value: value2 } of bs.items) {
    const props = resolveProps(start2, {
      indicator: "seq-item-ind",
      next: value2,
      offset,
      onError: onError2,
      parentIndent: bs.indent,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value2) {
        if (value2 && value2.type === "block-seq")
          onError2(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError2(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node3 = value2 ? composeNode2(ctx, value2, props, onError2) : composeEmptyNode2(ctx, props.end, start2, null, props, onError2);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value2, onError2);
    offset = node3.range[2];
    seq2.items.push(node3);
  }
  seq2.range = [bs.offset, offset, commentEnd ?? offset];
  return seq2;
}
function resolveEnd(end, offset, reqSpace, onError2) {
  let comment3 = "";
  if (end) {
    let hasSpace = false;
    let sep2 = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError2(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment3)
            comment3 = cb;
          else
            comment3 += sep2 + cb;
          sep2 = "";
          break;
        }
        case "newline":
          if (comment3)
            sep2 += source;
          hasSpace = true;
          break;
        default:
          onError2(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment: comment3, offset };
}
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError2, tag3) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = tag3?.nodeClass ?? (isMap2 ? YAMLMap : YAMLSeq);
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i14 = 0; i14 < fc.items.length; ++i14) {
    const collItem = fc.items[i14];
    const { start: start2, key, sep: sep2, value: value2 } = collItem;
    const props = resolveProps(start2, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? sep2?.[0],
      offset,
      onError: onError2,
      parentIndent: fc.indent,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep2 && !value2) {
        if (i14 === 0 && props.comma)
          onError2(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i14 < fc.items.length - 1)
          onError2(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError2(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i14 === 0) {
      if (props.comma)
        onError2(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError2(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop: for (const st of start2) {
          switch (st.type) {
            case "comma":
            case "space":
              break;
            case "comment":
              prevItemComment = st.source.substring(1);
              break loop;
            default:
              break loop;
          }
        }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value ?? prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep2 && !props.found) {
      const valueNode = value2 ? composeNode2(ctx, value2, props, onError2) : composeEmptyNode2(ctx, props.end, sep2, null, props, onError2);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock$1(value2))
        onError2(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError2) : composeEmptyNode2(ctx, keyStart, start2, null, props, onError2);
      if (isBlock$1(key))
        onError2(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep2 ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value2,
        offset: keyNode.range[2],
        onError: onError2,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep2)
            for (const st of sep2) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError2(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError2(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value2) {
        if ("source" in value2 && value2.source && value2.source[0] === ":")
          onError2(value2, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError2(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value2 ? composeNode2(ctx, value2, valueProps, onError2) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep2, null, valueProps, onError2) : null;
      if (valueNode) {
        if (isBlock$1(value2))
          onError2(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map = coll;
        if (mapIncludes(ctx, map.items, keyNode))
          onError2(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map.items.push(pair);
      } else {
        const map = new YAMLMap(ctx.schema);
        map.flow = true;
        map.items.push(pair);
        coll.items.push(map);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce3, ...ee3] = fc.end;
  let cePos = offset;
  if (ce3 && ce3.source === expectedEnd)
    cePos = ce3.offset + ce3.source.length;
  else {
    const name2 = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name2} must end with a ${expectedEnd}` : `${name2} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError2(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce3 && ce3.source.length !== 1)
      ee3.unshift(ce3);
  }
  if (ee3.length > 0) {
    const end = resolveEnd(ee3, cePos, ctx.options.strict, onError2);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
function resolveCollection(CN2, ctx, token, onError2, tagName, tag3) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError2, tag3) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError2, tag3) : resolveFlowCollection(CN2, ctx, token, onError2, tag3);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, props, onError2) {
  const tagToken = props.tag;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError2(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (token.type === "block-seq") {
    const { anchor, newlineAfterProp: nl } = props;
    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
    if (lastProp && (!nl || nl.offset < lastProp.offset)) {
      const message = "Missing newline after block sequence props";
      onError2(lastProp, "MISSING_CHAR", message);
    }
  }
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
    return resolveCollection(CN2, ctx, token, onError2, tagName);
  }
  let tag3 = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
  if (!tag3) {
    const kt2 = ctx.schema.knownTags[tagName];
    if (kt2 && kt2.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt2, { default: false }));
      tag3 = kt2;
    } else {
      if (kt2?.collection) {
        onError2(tagToken, "BAD_COLLECTION_TYPE", `${kt2.tag} used for ${expType} collection, but expects ${kt2.collection}`, true);
      } else {
        onError2(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError2, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError2, tagName, tag3);
  const res = tag3.resolve?.(coll, (msg) => onError2(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
  const node3 = isNode$1(res) ? res : new Scalar(res);
  node3.range = coll.range;
  node3.tag = tagName;
  if (tag3?.format)
    node3.format = tag3.format;
  return node3;
}
function resolveBlockScalar(ctx, scalar, onError2) {
  const start2 = scalar.offset;
  const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError2);
  if (!header)
    return { value: "", type: null, comment: "", range: [start2, start2, start2] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i14 = lines.length - 1; i14 >= 0; --i14) {
    const content = lines[i14][1];
    if (content === "" || content === "\r")
      chompStart = i14;
    else
      break;
  }
  if (chompStart === 0) {
    const value3 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start2 + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value3, type, comment: header.comment, range: [start2, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i14 = 0; i14 < chompStart; ++i14) {
    const [indent, content] = lines[i14];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError2(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i14;
      if (trimIndent === 0 && !ctx.atRoot) {
        const message = "Block scalar values in collections must be indented";
        onError2(offset, "BAD_INDENT", message);
      }
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i14 = lines.length - 1; i14 >= chompStart; --i14) {
    if (lines[i14][0].length > trimIndent)
      chompStart = i14 + 1;
  }
  let value2 = "";
  let sep2 = "";
  let prevMoreIndented = false;
  for (let i14 = 0; i14 < contentStart; ++i14)
    value2 += lines[i14][0].slice(trimIndent) + "\n";
  for (let i14 = contentStart; i14 < chompStart; ++i14) {
    let [indent, content] = lines[i14];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src3 = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src3}`;
      onError2(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value2 += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep2 === " ")
        sep2 = "\n";
      else if (!prevMoreIndented && sep2 === "\n")
        sep2 = "\n\n";
      value2 += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep2 === "\n")
        value2 += "\n";
      else
        sep2 = "\n";
    } else {
      value2 += sep2 + content;
      sep2 = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i14 = chompStart; i14 < lines.length; ++i14)
        value2 += "\n" + lines[i14][0].slice(trimIndent);
      if (value2[value2.length - 1] !== "\n")
        value2 += "\n";
      break;
    default:
      value2 += "\n";
  }
  const end = start2 + header.length + scalar.source.length;
  return { value: value2, type, comment: header.comment, range: [start2, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError2) {
  if (props[0].type !== "block-scalar-header") {
    onError2(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode2 = source[0];
  let indent = 0;
  let chomp = "";
  let error2 = -1;
  for (let i14 = 1; i14 < source.length; ++i14) {
    const ch = source[i14];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n14 = Number(ch);
      if (!indent && n14)
        indent = n14;
      else if (error2 === -1)
        error2 = offset + i14;
    }
  }
  if (error2 !== -1)
    onError2(error2, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment3 = "";
  let length = source.length;
  for (let i14 = 1; i14 < props.length; ++i14) {
    const token = props[i14];
    switch (token.type) {
      case "space":
        hasSpace = true;
      // fallthrough
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError2(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment3 = token.source.substring(1);
        break;
      case "error":
        onError2(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError2(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode: mode2, indent, chomp, comment: comment3, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first2 = split[0];
  const m23 = first2.match(/^( *)/);
  const line0 = m23?.[1] ? [m23[1], first2.slice(m23[1].length)] : ["", first2];
  const lines = [line0];
  for (let i14 = 1; i14 < split.length; i14 += 2)
    lines.push([split[i14], split[i14 + 1]]);
  return lines;
}
function resolveFlowScalar(scalar, strict, onError2) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value2;
  const _onError = (rel, code, msg) => onError2(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value2 = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value2 = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value2 = doubleQuotedValue(source, _onError);
      break;
    /* istanbul ignore next should not happen */
    default:
      onError2(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re3 = resolveEnd(end, valueEnd, strict, onError2);
  return {
    value: value2,
    type: _type,
    comment: re3.comment,
    range: [offset, valueEnd, re3.offset]
  };
}
function plainValue(source, onError2) {
  let badChar = "";
  switch (source[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError2(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError2) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError2(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first2, line;
  try {
    first2 = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_22) {
    first2 = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match2 = first2.exec(source);
  if (!match2)
    return source;
  let res = match2[1];
  let sep2 = " ";
  let pos = first2.lastIndex;
  line.lastIndex = pos;
  while (match2 = line.exec(source)) {
    if (match2[1] === "") {
      if (sep2 === "\n")
        res += sep2;
      else
        sep2 = "\n";
    } else {
      res += sep2 + match2[1];
      sep2 = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match2 = last.exec(source);
  return res + sep2 + (match2?.[1] ?? "");
}
function doubleQuotedValue(source, onError2) {
  let res = "";
  for (let i14 = 1; i14 < source.length - 1; ++i14) {
    const ch = source[i14];
    if (ch === "\r" && source[i14 + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i14);
      res += fold;
      i14 = offset;
    } else if (ch === "\\") {
      let next = source[++i14];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i14 + 1];
        while (next === " " || next === "	")
          next = source[++i14 + 1];
      } else if (next === "\r" && source[i14 + 1] === "\n") {
        next = source[++i14 + 1];
        while (next === " " || next === "	")
          next = source[++i14 + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i14 + 1, length, onError2);
        i14 += length;
      } else {
        const raw = source.substr(i14 - 1, 2);
        onError2(i14 - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i14;
      let next = source[i14 + 1];
      while (next === " " || next === "	")
        next = source[++i14 + 1];
      if (next !== "\n" && !(next === "\r" && source[i14 + 2] === "\n"))
        res += i14 > wsStart ? source.slice(wsStart, i14 + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError2(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
function parseCharCode(source, offset, length, onError2) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError2(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}
function composeScalar(ctx, token, tagToken, onError2) {
  const { value: value2, type, comment: comment3, range } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError2) : resolveFlowScalar(token, ctx.options.strict, onError2);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError2(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag3 = tagToken && tagName ? findScalarTagByName(ctx.schema, value2, tagName, tagToken, onError2) : token.type === "scalar" ? findScalarTagByTest(ctx, value2, token, onError2) : ctx.schema[SCALAR$1];
  let scalar;
  try {
    const res = tag3.resolve(value2, (msg) => onError2(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar$1(res) ? res : new Scalar(res);
  } catch (error2) {
    const msg = error2 instanceof Error ? error2.message : String(error2);
    onError2(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value2);
  }
  scalar.range = range;
  scalar.source = value2;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag3.format)
    scalar.format = tag3.format;
  if (comment3)
    scalar.comment = comment3;
  return scalar;
}
function findScalarTagByName(schema2, value2, tagName, tagToken, onError2) {
  if (tagName === "!")
    return schema2[SCALAR$1];
  const matchWithTest = [];
  for (const tag3 of schema2.tags) {
    if (!tag3.collection && tag3.tag === tagName) {
      if (tag3.default && tag3.test)
        matchWithTest.push(tag3);
      else
        return tag3;
    }
  }
  for (const tag3 of matchWithTest)
    if (tag3.test?.test(value2))
      return tag3;
  const kt2 = schema2.knownTags[tagName];
  if (kt2 && !kt2.collection) {
    schema2.tags.push(Object.assign({}, kt2, { default: false, test: void 0 }));
    return kt2;
  }
  onError2(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema2[SCALAR$1];
}
function findScalarTagByTest({ directives, schema: schema2 }, value2, token, onError2) {
  const tag3 = schema2.tags.find((tag4) => tag4.default && tag4.test?.test(value2)) || schema2[SCALAR$1];
  if (schema2.compat) {
    const compat = schema2.compat.find((tag4) => tag4.default && tag4.test?.test(value2)) ?? schema2[SCALAR$1];
    if (tag3.tag !== compat.tag) {
      const ts = directives.tagString(tag3.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError2(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag3;
}
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i14 = pos - 1; i14 >= 0; --i14) {
      let st = before[i14];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i14];
      while (st?.type === "space") {
        offset += st.source.length;
        st = before[++i14];
      }
      break;
    }
  }
  return offset;
}
function composeNode(ctx, token, props, onError2) {
  const { spaceBefore, comment: comment3, anchor, tag: tag3 } = props;
  let node3;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node3 = composeAlias(ctx, token, onError2);
      if (anchor || tag3)
        onError2(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node3 = composeScalar(ctx, token, tag3, onError2);
      if (anchor)
        node3.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node3 = composeCollection(CN, ctx, token, props, onError2);
      if (anchor)
        node3.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError2(token, "UNEXPECTED_TOKEN", message);
      node3 = composeEmptyNode(ctx, token.offset, void 0, null, props, onError2);
      isSrcToken = false;
    }
  }
  if (anchor && node3.anchor === "")
    onError2(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node3.spaceBefore = true;
  if (comment3) {
    if (token.type === "scalar" && token.source === "")
      node3.comment = comment3;
    else
      node3.commentBefore = comment3;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node3.srcToken = token;
  return node3;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment: comment3, anchor, tag: tag3, end }, onError2) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node3 = composeScalar(ctx, token, tag3, onError2);
  if (anchor) {
    node3.anchor = anchor.source.substring(1);
    if (node3.anchor === "")
      onError2(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node3.spaceBefore = true;
  if (comment3) {
    node3.comment = comment3;
    node3.range[2] = end;
  }
  return node3;
}
function composeAlias({ options: options2 }, { offset, source, end }, onError2) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError2(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError2(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re3 = resolveEnd(end, valueEnd, options2.strict, onError2);
  alias.range = [offset, valueEnd, re3.offset];
  if (re3.comment)
    alias.comment = re3.comment;
  return alias;
}
function composeDoc(options2, directives, { offset, start: start2, value: value2, end }, onError2) {
  const opts = Object.assign({ _directives: directives }, options2);
  const doc = new Document(void 0, opts);
  const ctx = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start2, {
    indicator: "doc-start",
    next: value2 ?? end?.[0],
    offset,
    onError: onError2,
    parentIndent: 0,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value2 && (value2.type === "block-map" || value2.type === "block-seq") && !props.hasNewline)
      onError2(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value2 ? composeNode(ctx, value2, props, onError2) : composeEmptyNode(ctx, props.end, start2, null, props, onError2);
  const contentEnd = doc.contents.range[2];
  const re3 = resolveEnd(end, contentEnd, false, onError2);
  if (re3.comment)
    doc.comment = re3.comment;
  doc.range = [offset, contentEnd, re3.offset];
  return doc;
}
function getErrorPos(src3) {
  if (typeof src3 === "number")
    return [src3, src3 + 1];
  if (Array.isArray(src3))
    return src3.length === 2 ? src3 : [src3[0], src3[1]];
  const { offset, source } = src3;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  let comment3 = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i14 = 0; i14 < prelude.length; ++i14) {
    const source = prelude[i14];
    switch (source[0]) {
      case "#":
        comment3 += (comment3 === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (prelude[i14 + 1]?.[0] !== "#")
          i14 += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment: comment3, afterEmptyLine };
}
function resolveAsScalar(token, strict = true, onError2) {
  if (token) {
    const _onError = (pos, code, message) => {
      const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError2)
        onError2(offset, code, message);
      else
        throw new YAMLParseError([offset, offset + 1], code, message);
    };
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar({ options: { strict } }, token, _onError);
    }
  }
  return null;
}
function createScalarToken(value2, context) {
  const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
  const source = stringifyString({ type, value: value2 }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = context.end ?? [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source[0]) {
    case "|":
    case ">": {
      const he3 = source.indexOf("\n");
      const head = source.substring(0, he3);
      const body = source.substring(he3 + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset, indent, source, end };
    case "'":
      return { type: "single-quoted-scalar", offset, indent, source, end };
    default:
      return { type: "scalar", offset, indent, source, end };
  }
}
function setScalarValue(token, value2, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source = stringifyString({ type, value: value2 }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source);
      break;
    case '"':
      setFlowScalarValue(token, source, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source, "scalar");
  }
}
function setBlockScalarValue(token, source) {
  const he3 = source.indexOf("\n");
  const head = source.substring(0, he3);
  const body = source.substring(he3 + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token, source, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset = token.offset + source.length;
      const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type, indent, source, end });
    }
  }
}
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start: start2, key, sep: sep2, value: value2 }) {
  let res = "";
  for (const st of start2)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep2)
    for (const st of sep2)
      res += st.source;
  if (value2)
    res += stringifyToken(value2);
  return res;
}
function visit(cst2, visitor) {
  if ("type" in cst2 && cst2.type === "document")
    cst2 = { start: cst2.start, value: cst2.value };
  _visit(Object.freeze([]), cst2, visitor);
}
function _visit(path7, item, visitor) {
  let ctrl = visitor(item, path7);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i14 = 0; i14 < token.items.length; ++i14) {
        const ci = _visit(Object.freeze(path7.concat([[field, i14]])), token.items[i14], visitor);
        if (typeof ci === "number")
          i14 = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          token.items.splice(i14, 1);
          i14 -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path7);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path7) : ctrl;
}
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
function includesToken(list, type) {
  for (let i14 = 0; i14 < list.length; ++i14)
    if (list[i14].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i14 = 0; i14 < list.length; ++i14) {
    switch (list[i14].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i14;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  if (prev.length === 0)
    return [];
  let i14 = prev.length;
  loop: while (--i14 >= 0) {
    switch (prev[i14].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break loop;
    }
  }
  return prev.splice(i14, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
function parseOptions(options2) {
  const prettyErrors = options2.prettyErrors !== false;
  const lineCounter = options2.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseAllDocuments(source, options2 = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options2);
  const parser2 = new Parser2(lineCounter?.addNewLine);
  const composer = new Composer(options2);
  const docs = Array.from(composer.compose(parser2.parse(source)));
  if (prettyErrors && lineCounter)
    for (const doc of docs) {
      doc.errors.forEach(prettifyError(source, lineCounter));
      doc.warnings.forEach(prettifyError(source, lineCounter));
    }
  if (docs.length > 0)
    return docs;
  return Object.assign([], { empty: true }, composer.streamInfo());
}
function parseDocument(source, options2 = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options2);
  const parser2 = new Parser2(lineCounter?.addNewLine);
  const composer = new Composer(options2);
  let doc = null;
  for (const _doc of composer.compose(parser2.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse$a(src3, reviver, options2) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options2 === void 0 && reviver && typeof reviver === "object") {
    options2 = reviver;
  }
  const doc = parseDocument(src3, options2);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options2));
}
function stringify3(value2, replacer, options2) {
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options2 === void 0 && replacer) {
    options2 = replacer;
  }
  if (typeof options2 === "string")
    options2 = options2.length;
  if (typeof options2 === "number") {
    const indent = Math.round(options2);
    options2 = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value2 === void 0) {
    const { keepUndefined } = options2 ?? replacer ?? {};
    if (!keepUndefined)
      return void 0;
  }
  return new Document(value2, _replacer, options2).toString(options2);
}
function req$2(name2, rootFile) {
  const create = createRequire || createRequireFromPath;
  const require28 = create(rootFile);
  return require28(name2);
}
function parse$9(src3) {
  const obj = {};
  let lines = src3.toString();
  lines = lines.replace(/\r\n?/mg, "\n");
  let match2;
  while ((match2 = LINE.exec(lines)) != null) {
    const key = match2[1];
    let value2 = match2[2] || "";
    value2 = value2.trim();
    const maybeQuote = value2[0];
    value2 = value2.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
    if (maybeQuote === '"') {
      value2 = value2.replace(/\\n/g, "\n");
      value2 = value2.replace(/\\r/g, "\r");
    }
    obj[key] = value2;
  }
  return obj;
}
function _parseVault(options2) {
  const vaultPath = _vaultPath(options2);
  const result = DotenvModule.configDotenv({ path: vaultPath });
  if (!result.parsed) {
    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
    err.code = "MISSING_DATA";
    throw err;
  }
  const keys = _dotenvKey(options2).split(",");
  const length = keys.length;
  let decrypted;
  for (let i14 = 0; i14 < length; i14++) {
    try {
      const key = keys[i14].trim();
      const attrs = _instructions(result, key);
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
      break;
    } catch (error2) {
      if (i14 + 1 >= length) {
        throw error2;
      }
    }
  }
  return DotenvModule.parse(decrypted);
}
function _log(message) {
  console.log(`[dotenv@${version2}][INFO] ${message}`);
}
function _warn(message) {
  console.log(`[dotenv@${version2}][WARN] ${message}`);
}
function _debug(message) {
  console.log(`[dotenv@${version2}][DEBUG] ${message}`);
}
function _dotenvKey(options2) {
  if (options2 && options2.DOTENV_KEY && options2.DOTENV_KEY.length > 0) {
    return options2.DOTENV_KEY;
  }
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY;
  }
  return "";
}
function _instructions(result, dotenvKey) {
  let uri;
  try {
    uri = new URL(dotenvKey);
  } catch (error2) {
    if (error2.code === "ERR_INVALID_URL") {
      const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    throw error2;
  }
  const key = uri.password;
  if (!key) {
    const err = new Error("INVALID_DOTENV_KEY: Missing key part");
    err.code = "INVALID_DOTENV_KEY";
    throw err;
  }
  const environment = uri.searchParams.get("environment");
  if (!environment) {
    const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
    err.code = "INVALID_DOTENV_KEY";
    throw err;
  }
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
  const ciphertext = result.parsed[environmentKey];
  if (!ciphertext) {
    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
    err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
    throw err;
  }
  return { ciphertext, key };
}
function _vaultPath(options2) {
  let possibleVaultPath = null;
  if (options2 && options2.path && options2.path.length > 0) {
    if (Array.isArray(options2.path)) {
      for (const filepath of options2.path) {
        if (fs$9.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
        }
      }
    } else {
      possibleVaultPath = options2.path.endsWith(".vault") ? options2.path : `${options2.path}.vault`;
    }
  } else {
    possibleVaultPath = path$9.resolve(process.cwd(), ".env.vault");
  }
  if (fs$9.existsSync(possibleVaultPath)) {
    return possibleVaultPath;
  }
  return null;
}
function _resolveHome(envPath) {
  return envPath[0] === "~" ? path$9.join(os$2.homedir(), envPath.slice(1)) : envPath;
}
function _configVault(options2) {
  _log("Loading env from encrypted .env.vault");
  const parsed = DotenvModule._parseVault(options2);
  let processEnv = process.env;
  if (options2 && options2.processEnv != null) {
    processEnv = options2.processEnv;
  }
  DotenvModule.populate(processEnv, parsed, options2);
  return { parsed };
}
function configDotenv(options2) {
  const dotenvPath = path$9.resolve(process.cwd(), ".env");
  let encoding = "utf8";
  const debug2 = Boolean(options2 && options2.debug);
  if (options2 && options2.encoding) {
    encoding = options2.encoding;
  } else {
    if (debug2) {
      _debug("No encoding is specified. UTF-8 is used by default");
    }
  }
  let optionPaths = [dotenvPath];
  if (options2 && options2.path) {
    if (!Array.isArray(options2.path)) {
      optionPaths = [_resolveHome(options2.path)];
    } else {
      optionPaths = [];
      for (const filepath of options2.path) {
        optionPaths.push(_resolveHome(filepath));
      }
    }
  }
  let lastError;
  const parsedAll = {};
  for (const path7 of optionPaths) {
    try {
      const parsed = DotenvModule.parse(fs$9.readFileSync(path7, { encoding }));
      DotenvModule.populate(parsedAll, parsed, options2);
    } catch (e2) {
      if (debug2) {
        _debug(`Failed to load ${path7} ${e2.message}`);
      }
      lastError = e2;
    }
  }
  let processEnv = process.env;
  if (options2 && options2.processEnv != null) {
    processEnv = options2.processEnv;
  }
  DotenvModule.populate(processEnv, parsedAll, options2);
  if (lastError) {
    return { parsed: parsedAll, error: lastError };
  } else {
    return { parsed: parsedAll };
  }
}
function config(options2) {
  if (_dotenvKey(options2).length === 0) {
    return DotenvModule.configDotenv(options2);
  }
  const vaultPath = _vaultPath(options2);
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
    return DotenvModule.configDotenv(options2);
  }
  return DotenvModule._configVault(options2);
}
function decrypt(encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), "hex");
  let ciphertext = Buffer.from(encrypted, "base64");
  const nonce = ciphertext.subarray(0, 12);
  const authTag = ciphertext.subarray(-16);
  ciphertext = ciphertext.subarray(12, -16);
  try {
    const aesgcm = crypto$1.createDecipheriv("aes-256-gcm", key, nonce);
    aesgcm.setAuthTag(authTag);
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
  } catch (error2) {
    const isRange = error2 instanceof RangeError;
    const invalidKeyLength = error2.message === "Invalid key length";
    const decryptionFailed = error2.message === "Unsupported state or unable to authenticate data";
    if (isRange || invalidKeyLength) {
      const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    } else if (decryptionFailed) {
      const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
      err.code = "DECRYPTION_FAILED";
      throw err;
    } else {
      throw error2;
    }
  }
}
function populate(processEnv, parsed, options2 = {}) {
  const debug2 = Boolean(options2 && options2.debug);
  const override = Boolean(options2 && options2.override);
  if (typeof parsed !== "object") {
    const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
    err.code = "OBJECT_REQUIRED";
    throw err;
  }
  for (const key of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key];
      }
      if (debug2) {
        if (override === true) {
          _debug(`"${key}" is already defined and WAS overwritten`);
        } else {
          _debug(`"${key}" is already defined and was NOT overwritten`);
        }
      }
    } else {
      processEnv[key] = parsed[key];
    }
  }
}
function createCachedImport(imp) {
  let cached;
  return () => {
    if (!cached) {
      cached = imp().then((module3) => {
        cached = module3;
        return module3;
      });
    }
    return cached;
  };
}
function rewriteCssUrls(css, replacer) {
  return asyncReplace(css, cssUrlRE, async (match2) => {
    const [matched, rawUrl] = match2;
    return await doUrlReplace(rawUrl.trim(), matched, replacer);
  });
}
async function rewriteCssImageSet(css, replacer) {
  return await asyncReplace(css, cssImageSetRE, async (match2) => {
    const [, rawUrl] = match2;
    const url2 = await processSrcSet(rawUrl, async ({ url: url22 }) => {
      if (cssUrlRE.test(url22)) {
        return await rewriteCssUrls(url22, replacer);
      }
      if (!cssNotProcessedRE.test(url22)) {
        return await doUrlReplace(url22, url22, replacer);
      }
      return url22;
    });
    return url2;
  });
}
function skipUrlReplacer(rawUrl) {
  return isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl[0] === "#" || functionCallRE.test(rawUrl);
}
async function doUrlReplace(rawUrl, matched, replacer, funcName = "url") {
  let wrap2 = "";
  const first2 = rawUrl[0];
  if (first2 === `"` || first2 === `'`) {
    wrap2 = first2;
    rawUrl = rawUrl.slice(1, -1);
  }
  if (skipUrlReplacer(rawUrl)) {
    return matched;
  }
  let newUrl = await replacer(rawUrl);
  if (wrap2 === "" && newUrl !== encodeURI(newUrl)) {
    wrap2 = '"';
  }
  if (wrap2 === "'" && newUrl.includes("'")) {
    wrap2 = '"';
  }
  if (wrap2 === '"' && newUrl.includes('"')) {
    newUrl = newUrl.replace(nonEscapedDoubleQuoteRe, '\\"');
  }
  return `${funcName}(${wrap2}${newUrl}${wrap2})`;
}
function formatList(array2, type = "and") {
  return array2.length < 3 ? array2.join(` ${type} `) : `${array2.slice(0, -1).join(", ")}, ${type} ${array2[array2.length - 1]}`;
}
function createError2(sym, value2, constructor) {
  messages.set(sym, value2);
  return makeNodeErrorWithCode(constructor, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...parameters) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    const error2 = new Base();
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
    const message = getMessage(key, parameters, error2);
    Object.defineProperties(error2, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error2);
    error2.code = key;
    return error2;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (v82.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(wrappedFunction) {
  const hidden = nodeInternalPrefix + wrappedFunction.name;
  Object.defineProperty(wrappedFunction, "name", { value: hidden });
  return wrappedFunction;
}
function getMessage(key, parameters, self2) {
  const message = messages.get(key);
  assert$1(message !== void 0, "expected `message` to be found");
  if (typeof message === "function") {
    assert$1(
      message.length <= parameters.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self2, parameters);
  }
  const regex2 = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex2.exec(message) !== null) expectedLength++;
  assert$1(
    expectedLength === parameters.length,
    `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`
  );
  if (parameters.length === 0) return message;
  parameters.unshift(message);
  return Reflect.apply(format$2, null, parameters);
}
function determineSpecificType(value2) {
  if (value2 === null || value2 === void 0) {
    return String(value2);
  }
  if (typeof value2 === "function" && value2.name) {
    return `function ${value2.name}`;
  }
  if (typeof value2 === "object") {
    if (value2.constructor && value2.constructor.name) {
      return `an instance of ${value2.constructor.name}`;
    }
    return `${inspect(value2, { depth: -1 })}`;
  }
  let inspected = inspect(value2, { colors: false });
  if (inspected.length > 28) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return `type ${typeof value2} (${inspected})`;
}
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s12 = 1e3;
  var m23 = s12 * 60;
  var h20 = m23 * 60;
  var d20 = h20 * 24;
  var y20 = d20 * 365.25;
  ms = function(val, options2) {
    options2 = options2 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse6(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse6(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match2) {
      return;
    }
    var n14 = parseFloat(match2[1]);
    var type = (match2[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n14 * y20;
      case "days":
      case "day":
      case "d":
        return n14 * d20;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n14 * h20;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n14 * m23;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n14 * s12;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n14;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    if (ms2 >= d20) {
      return Math.round(ms2 / d20) + "d";
    }
    if (ms2 >= h20) {
      return Math.round(ms2 / h20) + "h";
    }
    if (ms2 >= m23) {
      return Math.round(ms2 / m23) + "m";
    }
    if (ms2 >= s12) {
      return Math.round(ms2 / s12) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    return plural(ms2, d20, "day") || plural(ms2, h20, "hour") || plural(ms2, m23, "minute") || plural(ms2, s12, "second") || ms2 + " ms";
  }
  function plural(ms2, n14, name2) {
    if (ms2 < n14) {
      return;
    }
    if (ms2 < n14 * 1.5) {
      return Math.floor(ms2 / n14) + " " + name2;
    }
    return Math.ceil(ms2 / n14) + " " + name2 + "s";
  }
  return ms;
}
function requireDebug() {
  if (hasRequiredDebug) return debug$f.exports;
  hasRequiredDebug = 1;
  (function(module3, exports4) {
    exports4 = module3.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports4.coerce = coerce;
    exports4.disable = disable;
    exports4.enable = enable;
    exports4.enabled = enabled;
    exports4.humanize = requireMs();
    exports4.names = [];
    exports4.skips = [];
    exports4.formatters = {};
    var prevTime;
    function selectColor(namespace2) {
      var hash3 = 0, i14;
      for (i14 in namespace2) {
        hash3 = (hash3 << 5) - hash3 + namespace2.charCodeAt(i14);
        hash3 |= 0;
      }
      return exports4.colors[Math.abs(hash3) % exports4.colors.length];
    }
    function createDebug(namespace2) {
      function debug2() {
        if (!debug2.enabled) return;
        var self2 = debug2;
        var curr = +/* @__PURE__ */ new Date();
        var ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i14 = 0; i14 < args.length; i14++) {
          args[i14] = arguments[i14];
        }
        args[0] = exports4.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index3 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
          if (match2 === "%%") return match2;
          index3++;
          var formatter2 = exports4.formatters[format2];
          if ("function" === typeof formatter2) {
            var val = args[index3];
            match2 = formatter2.call(self2, val);
            args.splice(index3, 1);
            index3--;
          }
          return match2;
        });
        exports4.formatArgs.call(self2, args);
        var logFn = debug2.log || exports4.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace2;
      debug2.enabled = exports4.enabled(namespace2);
      debug2.useColors = exports4.useColors();
      debug2.color = selectColor(namespace2);
      if ("function" === typeof exports4.init) {
        exports4.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports4.save(namespaces);
      exports4.names = [];
      exports4.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i14 = 0; i14 < len; i14++) {
        if (!split[i14]) continue;
        namespaces = split[i14].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports4.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports4.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports4.enable("");
    }
    function enabled(name2) {
      var i14, len;
      for (i14 = 0, len = exports4.skips.length; i14 < len; i14++) {
        if (exports4.skips[i14].test(name2)) {
          return false;
        }
      }
      for (i14 = 0, len = exports4.names.length; i14 < len; i14++) {
        if (exports4.names[i14].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  })(debug$f, debug$f.exports);
  return debug$f.exports;
}
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module3, exports4) {
    exports4 = module3.exports = requireDebug();
    exports4.log = log;
    exports4.formatArgs = formatArgs;
    exports4.save = save;
    exports4.load = load2;
    exports4.useColors = useColors;
    exports4.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports4.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports4.formatters.j = function(v15) {
      try {
        return JSON.stringify(v15);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports4.humanize(this.diff);
      if (!useColors2) return;
      var c16 = "color: " + this.color;
      args.splice(1, 0, c16, "color: inherit");
      var index3 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match2) {
        if ("%%" === match2) return;
        index3++;
        if ("%c" === match2) {
          lastC = index3;
        }
      });
      args.splice(lastC, 0, c16);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports4.storage.removeItem("debug");
        } else {
          exports4.storage.debug = namespaces;
        }
      } catch (e2) {
      }
    }
    function load2() {
      var r9;
      try {
        r9 = exports4.storage.debug;
      } catch (e2) {
      }
      if (!r9 && typeof process !== "undefined" && "env" in process) {
        r9 = process.env.DEBUG;
      }
      return r9;
    }
    exports4.enable(load2());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e2) {
      }
    }
  })(browser, browser.exports);
  return browser.exports;
}
function requireNode() {
  if (hasRequiredNode) return node2.exports;
  hasRequiredNode = 1;
  (function(module3, exports4) {
    var tty = require$$0$3;
    var util3 = require$$0$5;
    exports4 = module3.exports = requireDebug();
    exports4.init = init2;
    exports4.log = log;
    exports4.formatArgs = formatArgs;
    exports4.save = save;
    exports4.load = load2;
    exports4.useColors = useColors;
    exports4.colors = [6, 2, 3, 4, 5, 1];
    exports4.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_22, k13) {
        return k13.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
      else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
      else if (val === "null") val = null;
      else val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util3.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream4 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports4.inspectOpts ? Boolean(exports4.inspectOpts.colors) : tty.isatty(fd);
    }
    exports4.formatters.o = function(v15) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v15, this.inspectOpts).split("\n").map(function(str2) {
        return str2.trim();
      }).join(" ");
    };
    exports4.formatters.O = function(v15) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v15, this.inspectOpts);
    };
    function formatArgs(args) {
      var name2 = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c16 = this.color;
        var prefix = "  \x1B[3" + c16 + ";1m" + name2 + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c16 + "m+" + exports4.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name2 + " " + args[0];
      }
    }
    function log() {
      return stream4.write(util3.format.apply(util3, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream5;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream5 = new tty.WriteStream(fd2);
          stream5._type = "tty";
          if (stream5._handle && stream5._handle.unref) {
            stream5._handle.unref();
          }
          break;
        case "FILE":
          var fs5 = require$$0__default3;
          stream5 = new fs5.SyncWriteStream(fd2, { autoClose: false });
          stream5._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net2 = require$$4$1;
          stream5 = new net2.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream5.readable = false;
          stream5.read = null;
          stream5._type = "pipe";
          if (stream5._handle && stream5._handle.unref) {
            stream5._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream5.fd = fd2;
      stream5._isStdio = true;
      return stream5;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      var keys = Object.keys(exports4.inspectOpts);
      for (var i14 = 0; i14 < keys.length; i14++) {
        debug2.inspectOpts[keys[i14]] = exports4.inspectOpts[keys[i14]];
      }
    }
    exports4.enable(load2());
  })(node2, node2.exports);
  return node2.exports;
}
function encodeUrl$1(url2) {
  return String(url2).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
}
function escapeHtml$1(string4) {
  var str2 = "" + string4;
  var match2 = matchHtmlRegExp.exec(str2);
  if (!match2) {
    return str2;
  }
  var escape2;
  var html = "";
  var index3 = 0;
  var lastIndex = 0;
  for (index3 = match2.index; index3 < str2.length; index3++) {
    switch (str2.charCodeAt(index3)) {
      case 34:
        escape2 = "&quot;";
        break;
      case 38:
        escape2 = "&amp;";
        break;
      case 39:
        escape2 = "&#39;";
        break;
      case 60:
        escape2 = "&lt;";
        break;
      case 62:
        escape2 = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index3) {
      html += str2.substring(lastIndex, index3);
    }
    lastIndex = index3 + 1;
    html += escape2;
  }
  return lastIndex !== index3 ? html + str2.substring(lastIndex, index3) : html;
}
function first$1(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError("arg must be an array of [ee, events...] arrays");
  var cleanups = [];
  for (var i14 = 0; i14 < stuff.length; i14++) {
    var arr = stuff[i14];
    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError("each array member must be [ee, events...]");
    var ee3 = arr[0];
    for (var j16 = 1; j16 < arr.length; j16++) {
      var event = arr[j16];
      var fn = listener(event, callback);
      ee3.on(event, fn);
      cleanups.push({
        ee: ee3,
        event,
        fn
      });
    }
  }
  function callback() {
    cleanup();
    done.apply(null, arguments);
  }
  function cleanup() {
    var x22;
    for (var i15 = 0; i15 < cleanups.length; i15++) {
      x22 = cleanups[i15];
      x22.ee.removeListener(x22.event, x22.fn);
    }
  }
  function thunk(fn2) {
    done = fn2;
  }
  thunk.cancel = cleanup;
  return thunk;
}
function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length);
    var ee3 = this;
    var err = event === "error" ? arg1 : null;
    for (var i14 = 0; i14 < args.length; i14++) {
      args[i14] = arguments[i14];
    }
    done(err, ee3, event, args);
  };
}
function onFinished$1(msg, listener2) {
  if (isFinished$1(msg) !== false) {
    defer$2(listener2, null, msg);
    return msg;
  }
  attachListener(msg, listener2);
  return msg;
}
function isFinished$1(msg) {
  var socket = msg.socket;
  if (typeof msg.finished === "boolean") {
    return Boolean(msg.finished || socket && !socket.writable);
  }
  if (typeof msg.complete === "boolean") {
    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
  }
  return void 0;
}
function attachFinishedListener(msg, callback) {
  var eeMsg;
  var eeSocket;
  var finished = false;
  function onFinish(error2) {
    eeMsg.cancel();
    eeSocket.cancel();
    finished = true;
    callback(error2);
  }
  eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
  function onSocket(socket) {
    msg.removeListener("socket", onSocket);
    if (finished) return;
    if (eeMsg !== eeSocket) return;
    eeSocket = first([[socket, "error", "close"]], onFinish);
  }
  if (msg.socket) {
    onSocket(msg.socket);
    return;
  }
  msg.on("socket", onSocket);
  if (msg.socket === void 0) {
    patchAssignSocket(msg, onSocket);
  }
}
function attachListener(msg, listener2) {
  var attached = msg.__onFinished;
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg);
    attachFinishedListener(msg, attached);
  }
  attached.queue.push(listener2);
}
function createListener(msg) {
  function listener2(err) {
    if (msg.__onFinished === listener2) msg.__onFinished = null;
    if (!listener2.queue) return;
    var queue2 = listener2.queue;
    listener2.queue = null;
    for (var i14 = 0; i14 < queue2.length; i14++) {
      queue2[i14](err, msg);
    }
  }
  listener2.queue = [];
  return listener2;
}
function patchAssignSocket(res, callback) {
  var assignSocket = res.assignSocket;
  if (typeof assignSocket !== "function") return;
  res.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket);
    callback(socket);
  };
}
function parseurl(req2) {
  var url2 = req2.url;
  if (url2 === void 0) {
    return void 0;
  }
  var parsed = req2._parsedUrl;
  if (fresh(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedUrl = parsed;
}
function originalurl(req2) {
  var url2 = req2.originalUrl;
  if (typeof url2 !== "string") {
    return parseurl(req2);
  }
  var parsed = req2._parsedOriginalUrl;
  if (fresh(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedOriginalUrl = parsed;
}
function fastparse(str2) {
  if (typeof str2 !== "string" || str2.charCodeAt(0) !== 47) {
    return parse$8(str2);
  }
  var pathname = str2;
  var query = null;
  var search = null;
  for (var i14 = 1; i14 < str2.length; i14++) {
    switch (str2.charCodeAt(i14)) {
      case 63:
        if (search === null) {
          pathname = str2.substring(0, i14);
          query = str2.substring(i14 + 1);
          search = str2.substring(i14);
        }
        break;
      case 9:
      /* \t */
      case 10:
      /* \n */
      case 12:
      /* \f */
      case 13:
      /* \r */
      case 32:
      /*    */
      case 35:
      /* #  */
      case 160:
      case 65279:
        return parse$8(str2);
    }
  }
  var url2 = Url !== void 0 ? new Url() : {};
  url2.path = str2;
  url2.href = str2;
  url2.pathname = pathname;
  if (search !== null) {
    url2.query = query;
    url2.search = search;
  }
  return url2;
}
function fresh(url2, parsedUrl) {
  return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
}
function populateStatusesMap(statuses2, codes2) {
  var arr = [];
  Object.keys(codes2).forEach(function forEachCode(code) {
    var message = codes2[code];
    var status2 = Number(code);
    statuses2[status2] = message;
    statuses2[message] = status2;
    statuses2[message.toLowerCase()] = status2;
    arr.push(status2);
  });
  return arr;
}
function status(code) {
  if (typeof code === "number") {
    if (!status[code]) throw new Error("invalid status code: " + code);
    return code;
  }
  if (typeof code !== "string") {
    throw new TypeError("code must be a number or string");
  }
  var n14 = parseInt(code, 10);
  if (!isNaN(n14)) {
    if (!status[n14]) throw new Error("invalid status code: " + n14);
    return n14;
  }
  n14 = status[code.toLowerCase()];
  if (!n14) throw new Error('invalid status message: "' + code + '"');
  return n14;
}
function hasPipeDataListeners(stream4) {
  var listeners = stream4.listeners("data");
  for (var i14 = 0; i14 < listeners.length; i14++) {
    if (listeners[i14].name === "ondata") {
      return true;
    }
  }
  return false;
}
function unpipe$1(stream4) {
  if (!stream4) {
    throw new TypeError("argument stream is required");
  }
  if (typeof stream4.unpipe === "function") {
    stream4.unpipe();
    return;
  }
  if (!hasPipeDataListeners(stream4)) {
    return;
  }
  var listener2;
  var listeners = stream4.listeners("close");
  for (var i14 = 0; i14 < listeners.length; i14++) {
    listener2 = listeners[i14];
    if (listener2.name !== "cleanup" && listener2.name !== "onclose") {
      continue;
    }
    listener2.call(stream4);
  }
}
function createHtmlDocument(message) {
  var body = escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
  return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
}
function finalhandler$1(req2, res, options2) {
  var opts = options2 || {};
  var env2 = opts.env || "development";
  var onerror = opts.onerror;
  return function(err) {
    var headers;
    var msg;
    var status2;
    if (!err && headersSent(res)) {
      debug$e("cannot 404 after headers sent");
      return;
    }
    if (err) {
      status2 = getErrorStatusCode(err);
      if (status2 === void 0) {
        status2 = getResponseStatusCode(res);
      } else {
        headers = getErrorHeaders(err);
      }
      msg = getErrorMessage(err, status2, env2);
    } else {
      status2 = 404;
      msg = "Cannot " + req2.method + " " + encodeUrl(getResourceName(req2));
    }
    debug$e("default %s", status2);
    if (err && onerror) {
      defer$1(onerror, err, req2, res);
    }
    if (headersSent(res)) {
      debug$e("cannot %d after headers sent", status2);
      req2.socket.destroy();
      return;
    }
    send$2(req2, res, status2, headers, msg);
  };
}
function getErrorHeaders(err) {
  if (!err.headers || typeof err.headers !== "object") {
    return void 0;
  }
  var headers = /* @__PURE__ */ Object.create(null);
  var keys = Object.keys(err.headers);
  for (var i14 = 0; i14 < keys.length; i14++) {
    var key = keys[i14];
    headers[key] = err.headers[key];
  }
  return headers;
}
function getErrorMessage(err, status2, env2) {
  var msg;
  if (env2 !== "production") {
    msg = err.stack;
    if (!msg && typeof err.toString === "function") {
      msg = err.toString();
    }
  }
  return msg || statuses[status2];
}
function getErrorStatusCode(err) {
  if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
    return err.status;
  }
  if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
    return err.statusCode;
  }
  return void 0;
}
function getResourceName(req2) {
  try {
    return parseUrl$2.original(req2).pathname;
  } catch (e2) {
    return "resource";
  }
}
function getResponseStatusCode(res) {
  var status2 = res.statusCode;
  if (typeof status2 !== "number" || status2 < 400 || status2 > 599) {
    status2 = 500;
  }
  return status2;
}
function headersSent(res) {
  return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
}
function send$2(req2, res, status2, headers, message) {
  function write() {
    var body = createHtmlDocument(message);
    res.statusCode = status2;
    res.statusMessage = statuses[status2];
    setHeaders(res, headers);
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.setHeader("Content-Type", "text/html; charset=utf-8");
    res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
    if (req2.method === "HEAD") {
      res.end();
      return;
    }
    res.end(body, "utf8");
  }
  if (isFinished(req2)) {
    write();
    return;
  }
  unpipe(req2);
  onFinished(req2, write);
  req2.resume();
}
function setHeaders(res, headers) {
  if (!headers) {
    return;
  }
  var keys = Object.keys(headers);
  for (var i14 = 0; i14 < keys.length; i14++) {
    var key = keys[i14];
    res.setHeader(key, headers[key]);
  }
}
function call(handle2, route, err, req2, res, next) {
  var arity = handle2.length;
  var error2 = err;
  var hasError = Boolean(err);
  debug$d("%s %s : %s", handle2.name || "<anonymous>", route, req2.originalUrl);
  try {
    if (hasError && arity === 4) {
      handle2(err, req2, res, next);
      return;
    } else if (!hasError && arity < 4) {
      handle2(req2, res, next);
      return;
    }
  } catch (e2) {
    error2 = e2;
  }
  next(error2);
}
function logerror(err) {
  if (env !== "test") console.error(err.stack || err.toString());
}
function getProtohost(url2) {
  if (url2.length === 0 || url2[0] === "/") {
    return void 0;
  }
  var fqdnIndex = url2.indexOf("://");
  return fqdnIndex !== -1 && url2.lastIndexOf("?", fqdnIndex) === -1 ? url2.substr(0, url2.indexOf("/", 3 + fqdnIndex)) : void 0;
}
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i14 = 0; i14 < 10; i14++) {
      test2["_" + String.fromCharCode(i14)] = i14;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n14) {
      return test2[n14];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
function append(header, field) {
  if (typeof header !== "string") {
    throw new TypeError("header argument is required");
  }
  if (!field) {
    throw new TypeError("field argument is required");
  }
  var fields = !Array.isArray(field) ? parse$7(String(field)) : field;
  for (var j16 = 0; j16 < fields.length; j16++) {
    if (!FIELD_NAME_REGEXP.test(fields[j16])) {
      throw new TypeError("field argument contains an invalid header name");
    }
  }
  if (header === "*") {
    return header;
  }
  var val = header;
  var vals = parse$7(header.toLowerCase());
  if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
    return "*";
  }
  for (var i14 = 0; i14 < fields.length; i14++) {
    var fld = fields[i14].toLowerCase();
    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val ? val + ", " + fields[i14] : fields[i14];
    }
  }
  return val;
}
function parse$7(header) {
  var end = 0;
  var list = [];
  var start2 = 0;
  for (var i14 = 0, len = header.length; i14 < len; i14++) {
    switch (header.charCodeAt(i14)) {
      case 32:
        if (start2 === end) {
          start2 = end = i14 + 1;
        }
        break;
      case 44:
        list.push(header.substring(start2, end));
        start2 = end = i14 + 1;
        break;
      default:
        end = i14 + 1;
        break;
    }
  }
  list.push(header.substring(start2, end));
  return list;
}
function vary(res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    throw new TypeError("res argument is required");
  }
  var val = res.getHeader("Vary") || "";
  var header = Array.isArray(val) ? val.join(", ") : String(val);
  if (val = append(header, field)) {
    res.setHeader("Vary", val);
  }
}
function createFsWatchInstance(path7, options2, listener2, errHandler, emitRaw) {
  const handleEvent = (rawEvent, evPath) => {
    listener2(path7);
    emitRaw(rawEvent, evPath, { watchedPath: path7 });
    if (evPath && path7 !== evPath) {
      fsWatchBroadcast(
        sysPath$2.resolve(path7, evPath),
        KEY_LISTENERS,
        sysPath$2.join(path7, evPath)
      );
    }
  };
  try {
    return fs$7.watch(path7, options2, handleEvent);
  } catch (error2) {
    errHandler(error2);
  }
}
function setFSEventsListener(path7, realPath, listener2, rawEmitter) {
  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;
  const parentPath = sysPath$1.dirname(watchPath);
  let cont = FSEventsWatchers.get(watchPath);
  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }
  const resolvedPath = sysPath$1.resolve(path7);
  const hasSymlink = resolvedPath !== realPath;
  const filteredListener = (fullPath, flags, info) => {
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath$1.sep)) listener2(fullPath, flags, info);
  };
  let watchedParent = false;
  for (const watchedPath of FSEventsWatchers.keys()) {
    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {
      watchPath = watchedPath;
      cont = FSEventsWatchers.get(watchPath);
      watchedParent = true;
      break;
    }
  }
  if (cont || watchedParent) {
    cont.listeners.add(filteredListener);
  } else {
    cont = {
      listeners: /* @__PURE__ */ new Set([filteredListener]),
      rawEmitter,
      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
        if (!cont.listeners.size) return;
        if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS) return;
        const info = fsevents.getInfo(fullPath, flags);
        cont.listeners.forEach((list) => {
          list(fullPath, flags, info);
        });
        cont.rawEmitter(info.event, fullPath, info);
      })
    };
    FSEventsWatchers.set(watchPath, cont);
  }
  return () => {
    const lst = cont.listeners;
    lst.delete(filteredListener);
    if (!lst.size) {
      FSEventsWatchers.delete(watchPath);
      if (cont.watcher) return cont.watcher.stop().then(() => {
        cont.rawEmitter = cont.watcher = void 0;
        Object.freeze(cont);
      });
    }
  };
}
function matchAll(s12, r9) {
  var origIndex = r9.lastIndex;
  var matches = [];
  var matchObj;
  while (matchObj = r9.exec(s12)) {
    matches.push(matchObj);
    if (r9.lastIndex === matchObj.index) {
      r9.lastIndex += 1;
    }
  }
  r9.lastIndex = origIndex;
  return matches;
}
function getVar(env2, pre, key) {
  var r9 = typeof env2 === "function" ? env2(key) : env2[key];
  if (typeof r9 === "undefined" && key != "") {
    r9 = "";
  } else if (typeof r9 === "undefined") {
    r9 = "$";
  }
  if (typeof r9 === "object") {
    return pre + TOKEN + JSON.stringify(r9) + TOKEN;
  }
  return pre + r9;
}
function parseInternal(string4, env2, opts) {
  if (!opts) {
    opts = {};
  }
  var BS = opts.escape || "\\";
  var BAREWORD = "(\\" + BS + `['"` + META + `]|[^\\s'"` + META + "])+";
  var chunker = new RegExp([
    "(" + CONTROL + ")",
    // control chars
    "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")+"
  ].join("|"), "g");
  var matches = matchAll(string4, chunker);
  if (matches.length === 0) {
    return [];
  }
  if (!env2) {
    env2 = {};
  }
  var commented = false;
  return matches.map(function(match2) {
    var s12 = match2[0];
    if (!s12 || commented) {
      return void 0;
    }
    if (controlRE.test(s12)) {
      return { op: s12 };
    }
    var quote3 = false;
    var esc = false;
    var out = "";
    var isGlob3 = false;
    var i14;
    function parseEnvVar() {
      i14 += 1;
      var varend;
      var varname;
      var char = s12.charAt(i14);
      if (char === "{") {
        i14 += 1;
        if (s12.charAt(i14) === "}") {
          throw new Error("Bad substitution: " + s12.slice(i14 - 2, i14 + 1));
        }
        varend = s12.indexOf("}", i14);
        if (varend < 0) {
          throw new Error("Bad substitution: " + s12.slice(i14));
        }
        varname = s12.slice(i14, varend);
        i14 = varend;
      } else if (/[*@#?$!_-]/.test(char)) {
        varname = char;
        i14 += 1;
      } else {
        var slicedFromI = s12.slice(i14);
        varend = slicedFromI.match(/[^\w\d_]/);
        if (!varend) {
          varname = slicedFromI;
          i14 = s12.length;
        } else {
          varname = slicedFromI.slice(0, varend.index);
          i14 += varend.index - 1;
        }
      }
      return getVar(env2, "", varname);
    }
    for (i14 = 0; i14 < s12.length; i14++) {
      var c16 = s12.charAt(i14);
      isGlob3 = isGlob3 || !quote3 && (c16 === "*" || c16 === "?");
      if (esc) {
        out += c16;
        esc = false;
      } else if (quote3) {
        if (c16 === quote3) {
          quote3 = false;
        } else if (quote3 == SQ) {
          out += c16;
        } else {
          if (c16 === BS) {
            i14 += 1;
            c16 = s12.charAt(i14);
            if (c16 === DQ || c16 === BS || c16 === DS) {
              out += c16;
            } else {
              out += BS + c16;
            }
          } else if (c16 === DS) {
            out += parseEnvVar();
          } else {
            out += c16;
          }
        }
      } else if (c16 === DQ || c16 === SQ) {
        quote3 = c16;
      } else if (controlRE.test(c16)) {
        return { op: s12 };
      } else if (hash2.test(c16)) {
        commented = true;
        var commentObj = { comment: string4.slice(match2.index + i14 + 1) };
        if (out.length) {
          return [out, commentObj];
        }
        return [commentObj];
      } else if (c16 === BS) {
        esc = true;
      } else if (c16 === DS) {
        out += parseEnvVar();
      } else {
        out += c16;
      }
    }
    if (isGlob3) {
      return { op: "glob", pattern: out };
    }
    return out;
  }).reduce(function(prev, arg) {
    return typeof arg === "undefined" ? prev : prev.concat(arg);
  }, []);
}
function tryResolveRealFile(file, preserveSymlinks) {
  const stat3 = tryStatSync(file);
  if (stat3?.isFile()) return getRealPath(file, preserveSymlinks);
}
function tryResolveRealFileWithExtensions(filePath, extensions2, preserveSymlinks) {
  for (const ext2 of extensions2) {
    const res = tryResolveRealFile(filePath + ext2, preserveSymlinks);
    if (res) return res;
  }
}
function tryResolveRealFileOrType(file, preserveSymlinks) {
  const fileStat = tryStatSync(file);
  if (fileStat?.isFile()) {
    return { path: getRealPath(file, preserveSymlinks), type: "file" };
  }
  if (fileStat?.isDirectory()) {
    return { type: "directory" };
  }
  return;
}
function getRealPath(resolved, preserveSymlinks) {
  if (!preserveSymlinks) {
    resolved = safeRealpathSync(resolved);
  }
  return normalizePath$3(resolved);
}
function isDirectory(path22) {
  const stat3 = tryStatSync(path22);
  return stat3?.isDirectory() ?? false;
}
function ansiRegex({ onlyFirst = false } = {}) {
  const pattern2 = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern2, onlyFirst ? void 0 : "g");
}
function hasDockerEnv() {
  try {
    fs$3.statSync("/.dockerenv");
    return true;
  } catch (_22) {
    return false;
  }
}
function hasDockerCGroup() {
  try {
    return fs$3.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
  } catch (_22) {
    return false;
  }
}
function isInsideContainer() {
  if (cachedResult === void 0) {
    cachedResult = hasContainerEnv() || isDocker();
  }
  return cachedResult;
}
function detectArchBinary(binary2) {
  if (typeof binary2 === "string" || Array.isArray(binary2)) {
    return binary2;
  }
  const { [arch]: archBinary } = binary2;
  if (!archBinary) {
    throw new Error(`${arch} is not supported`);
  }
  return archBinary;
}
function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
  if (wsl && isWsl) {
    return detectArchBinary(wsl);
  }
  if (!platformBinary) {
    throw new Error(`${platform} is not supported`);
  }
  return detectArchBinary(platformBinary);
}
function requireWindows() {
  if (hasRequiredWindows) return windows;
  hasRequiredWindows = 1;
  windows = isexe2;
  isexe2.sync = sync2;
  var fs5 = require$$0__default3;
  function checkPathExt(path7, options2) {
    var pathext = options2.pathExt !== void 0 ? options2.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i14 = 0; i14 < pathext.length; i14++) {
      var p20 = pathext[i14].toLowerCase();
      if (p20 && path7.substr(-p20.length).toLowerCase() === p20) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat3, path7, options2) {
    if (!stat3.isSymbolicLink() && !stat3.isFile()) {
      return false;
    }
    return checkPathExt(path7, options2);
  }
  function isexe2(path7, options2, cb) {
    fs5.stat(path7, function(er, stat3) {
      cb(er, er ? false : checkStat(stat3, path7, options2));
    });
  }
  function sync2(path7, options2) {
    return checkStat(fs5.statSync(path7), path7, options2);
  }
  return windows;
}
function requireMode() {
  if (hasRequiredMode) return mode;
  hasRequiredMode = 1;
  mode = isexe2;
  isexe2.sync = sync2;
  var fs5 = require$$0__default3;
  function isexe2(path7, options2, cb) {
    fs5.stat(path7, function(er, stat3) {
      cb(er, er ? false : checkStat(stat3, options2));
    });
  }
  function sync2(path7, options2) {
    return checkStat(fs5.statSync(path7), options2);
  }
  function checkStat(stat3, options2) {
    return stat3.isFile() && checkMode(stat3, options2);
  }
  function checkMode(stat3, options2) {
    var mod = stat3.mode;
    var uid = stat3.uid;
    var gid = stat3.gid;
    var myUid = options2.uid !== void 0 ? options2.uid : process.getuid && process.getuid();
    var myGid = options2.gid !== void 0 ? options2.gid : process.getgid && process.getgid();
    var u17 = parseInt("100", 8);
    var g16 = parseInt("010", 8);
    var o10 = parseInt("001", 8);
    var ug = u17 | g16;
    var ret = mod & o10 || mod & g16 && gid === myGid || mod & u17 && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
  return mode;
}
function isexe$1(path7, options2, cb) {
  if (typeof options2 === "function") {
    cb = options2;
    options2 = {};
  }
  if (!cb) {
    if (typeof Promise !== "function") {
      throw new TypeError("callback not provided");
    }
    return new Promise(function(resolve5, reject) {
      isexe$1(path7, options2 || {}, function(er, is) {
        if (er) {
          reject(er);
        } else {
          resolve5(is);
        }
      });
    });
  }
  core(path7, options2 || {}, function(er, is) {
    if (er) {
      if (er.code === "EACCES" || options2 && options2.ignoreErrors) {
        er = null;
        is = false;
      }
    }
    cb(er, is);
  });
}
function sync(path7, options2) {
  try {
    return core.sync(path7, options2 || {});
  } catch (er) {
    if (options2 && options2.ignoreErrors || er.code === "EACCES") {
      return false;
    } else {
      throw er;
    }
  }
}
function resolveCommandAttempt(parsed, withoutPathExt) {
  const env2 = parsed.options.env || process.env;
  const cwd = process.cwd();
  const hasCustomCwd = parsed.options.cwd != null;
  const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
  if (shouldSwitchCwd) {
    try {
      process.chdir(parsed.options.cwd);
    } catch (err) {
    }
  }
  let resolved;
  try {
    resolved = which.sync(parsed.command, {
      path: env2[getPathKey({ env: env2 })],
      pathExt: withoutPathExt ? path$13.delimiter : void 0
    });
  } catch (e2) {
  } finally {
    if (shouldSwitchCwd) {
      process.chdir(cwd);
    }
  }
  if (resolved) {
    resolved = path$13.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
  }
  return resolved;
}
function resolveCommand$1(parsed) {
  return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}
function escapeCommand(arg) {
  arg = arg.replace(metaCharsRegExp, "^$1");
  return arg;
}
function escapeArgument(arg, doubleEscapeMetaChars) {
  arg = `${arg}`;
  arg = arg.replace(/(\\*)"/g, '$1$1\\"');
  arg = arg.replace(/(\\*)$/, "$1$1");
  arg = `"${arg}"`;
  arg = arg.replace(metaCharsRegExp, "^$1");
  if (doubleEscapeMetaChars) {
    arg = arg.replace(metaCharsRegExp, "^$1");
  }
  return arg;
}
function readShebang$1(command) {
  const size = 150;
  const buffer = Buffer.alloc(size);
  let fd;
  try {
    fd = fs4.openSync(command, "r");
    fs4.readSync(fd, buffer, 0, size, 0);
    fs4.closeSync(fd);
  } catch (e2) {
  }
  return shebangCommand(buffer.toString());
}
function detectShebang(parsed) {
  parsed.file = resolveCommand(parsed);
  const shebang = parsed.file && readShebang(parsed.file);
  if (shebang) {
    parsed.args.unshift(parsed.file);
    parsed.command = shebang;
    return resolveCommand(parsed);
  }
  return parsed.file;
}
function parseNonShell(parsed) {
  if (!isWin$1) {
    return parsed;
  }
  const commandFile = detectShebang(parsed);
  const needsShell = !isExecutableRegExp.test(commandFile);
  if (parsed.options.forceShell || needsShell) {
    const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
    parsed.command = path5.normalize(parsed.command);
    parsed.command = escape$1.command(parsed.command);
    parsed.args = parsed.args.map((arg) => escape$1.argument(arg, needsDoubleEscapeMetaChars));
    const shellCommand = [parsed.command].concat(parsed.args).join(" ");
    parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
    parsed.command = process.env.comspec || "cmd.exe";
    parsed.options.windowsVerbatimArguments = true;
  }
  return parsed;
}
function parse$4(command, args, options2) {
  if (args && !Array.isArray(args)) {
    options2 = args;
    args = null;
  }
  args = args ? args.slice(0) : [];
  options2 = Object.assign({}, options2);
  const parsed = {
    command,
    args,
    options: options2,
    file: void 0,
    original: {
      command,
      args
    }
  };
  return options2.shell ? parsed : parseNonShell(parsed);
}
function notFoundError(original, syscall) {
  return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
    code: "ENOENT",
    errno: "ENOENT",
    syscall: `${syscall} ${original.command}`,
    path: original.command,
    spawnargs: original.args
  });
}
function hookChildProcess(cp2, parsed) {
  if (!isWin) {
    return;
  }
  const originalEmit = cp2.emit;
  cp2.emit = function(name2, arg1) {
    if (name2 === "exit") {
      const err = verifyENOENT(arg1, parsed);
      if (err) {
        return originalEmit.call(cp2, "error", err);
      }
    }
    return originalEmit.apply(cp2, arguments);
  };
}
function verifyENOENT(status2, parsed) {
  if (isWin && status2 === 1 && !parsed.file) {
    return notFoundError(parsed.original, "spawn");
  }
  return null;
}
function verifyENOENTSync(status2, parsed) {
  if (isWin && status2 === 1 && !parsed.file) {
    return notFoundError(parsed.original, "spawnSync");
  }
  return null;
}
function spawn(command, args, options2) {
  const parsed = parse$3(command, args, options2);
  const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
  enoent.hookChildProcess(spawned, parsed);
  return spawned;
}
function spawnSync(command, args, options2) {
  const parsed = parse$3(command, args, options2);
  const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
  result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
  return result;
}
function concat$1(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER$3;
  if (list.length === 1) return list[0];
  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;
  for (let i14 = 0; i14 < list.length; i14++) {
    const buf = list[i14];
    target.set(buf, offset);
    offset += buf.length;
  }
  if (offset < totalLength) {
    return new FastBuffer$2(target.buffer, target.byteOffset, offset);
  }
  return target;
}
function _mask(source, mask, output, offset, length) {
  for (let i14 = 0; i14 < length; i14++) {
    output[offset + i14] = source[i14] ^ mask[i14 & 3];
  }
}
function _unmask(buffer, mask) {
  for (let i14 = 0; i14 < buffer.length; i14++) {
    buffer[i14] ^= mask[i14 & 3];
  }
}
function toArrayBuffer$1(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}
function toBuffer$2(data) {
  toBuffer$2.readOnly = true;
  if (Buffer.isBuffer(data)) return data;
  let buf;
  if (data instanceof ArrayBuffer) {
    buf = new FastBuffer$2(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = new FastBuffer$2(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer$2.readOnly = false;
  }
  return buf;
}
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;
  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
    this[kBuffers].push(chunk);
    return;
  }
  this[kError$1] = new RangeError("Max payload size exceeded");
  this[kError$1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
  this[kError$1][kStatusCode$2] = 1009;
  this.removeListener("data", inflateOnData);
  this.reset();
}
function inflateOnError(err) {
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode$2] = 1007;
  this[kCallback](err);
}
function isValidStatusCode$2(code) {
  return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
}
function _isValidUTF8(buf) {
  const len = buf.length;
  let i14 = 0;
  while (i14 < len) {
    if ((buf[i14] & 128) === 0) {
      i14++;
    } else if ((buf[i14] & 224) === 192) {
      if (i14 + 1 === len || (buf[i14 + 1] & 192) !== 128 || (buf[i14] & 254) === 192) {
        return false;
      }
      i14 += 2;
    } else if ((buf[i14] & 240) === 224) {
      if (i14 + 2 >= len || (buf[i14 + 1] & 192) !== 128 || (buf[i14 + 2] & 192) !== 128 || buf[i14] === 224 && (buf[i14 + 1] & 224) === 128 || // Overlong
      buf[i14] === 237 && (buf[i14 + 1] & 224) === 160) {
        return false;
      }
      i14 += 3;
    } else if ((buf[i14] & 248) === 240) {
      if (i14 + 3 >= len || (buf[i14 + 1] & 192) !== 128 || (buf[i14 + 2] & 192) !== 128 || (buf[i14 + 3] & 192) !== 128 || buf[i14] === 240 && (buf[i14 + 1] & 240) === 128 || // Overlong
      buf[i14] === 244 && buf[i14 + 1] > 143 || buf[i14] > 244) {
        return false;
      }
      i14 += 4;
    } else {
      return false;
    }
  }
  return true;
}
function isBlob$2(value2) {
  return hasBlob && typeof value2 === "object" && typeof value2.arrayBuffer === "function" && typeof value2.type === "string" && typeof value2.stream === "function" && (value2[Symbol.toStringTag] === "Blob" || value2[Symbol.toStringTag] === "File");
}
function callCallbacks(sender2, err, cb) {
  if (typeof cb === "function") cb(err);
  for (let i14 = 0; i14 < sender2._queue.length; i14++) {
    const params = sender2._queue[i14];
    const callback = params[params.length - 1];
    if (typeof callback === "function") callback(err);
  }
}
function onError(sender2, err, cb) {
  callCallbacks(sender2, err, cb);
  sender2.onerror(err);
}
function callListener(listener2, thisArg, event) {
  if (typeof listener2 === "object" && listener2.handleEvent) {
    listener2.handleEvent.call(listener2, event);
  } else {
    listener2.call(thisArg, event);
  }
}
function push(dest, name2, elem) {
  if (dest[name2] === void 0) dest[name2] = [elem];
  else dest[name2].push(elem);
}
function parse$2(header) {
  const offers = /* @__PURE__ */ Object.create(null);
  let params = /* @__PURE__ */ Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start2 = -1;
  let code = -1;
  let end = -1;
  let i14 = 0;
  for (; i14 < header.length; i14++) {
    code = header.charCodeAt(i14);
    if (extensionName === void 0) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start2 === -1) start2 = i14;
      } else if (i14 !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start2 !== -1) end = i14;
      } else if (code === 59 || code === 44) {
        if (start2 === -1) {
          throw new SyntaxError(`Unexpected character at index ${i14}`);
        }
        if (end === -1) end = i14;
        const name2 = header.slice(start2, end);
        if (code === 44) {
          push(offers, name2, params);
          params = /* @__PURE__ */ Object.create(null);
        } else {
          extensionName = name2;
        }
        start2 = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i14}`);
      }
    } else if (paramName === void 0) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start2 === -1) start2 = i14;
      } else if (code === 32 || code === 9) {
        if (end === -1 && start2 !== -1) end = i14;
      } else if (code === 59 || code === 44) {
        if (start2 === -1) {
          throw new SyntaxError(`Unexpected character at index ${i14}`);
        }
        if (end === -1) end = i14;
        push(params, header.slice(start2, end), true);
        if (code === 44) {
          push(offers, extensionName, params);
          params = /* @__PURE__ */ Object.create(null);
          extensionName = void 0;
        }
        start2 = end = -1;
      } else if (code === 61 && start2 !== -1 && end === -1) {
        paramName = header.slice(start2, i14);
        start2 = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i14}`);
      }
    } else {
      if (isEscaping) {
        if (tokenChars$1[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i14}`);
        }
        if (start2 === -1) start2 = i14;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars$1[code] === 1) {
          if (start2 === -1) start2 = i14;
        } else if (code === 34 && start2 !== -1) {
          inQuotes = false;
          end = i14;
        } else if (code === 92) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i14}`);
        }
      } else if (code === 34 && header.charCodeAt(i14 - 1) === 61) {
        inQuotes = true;
      } else if (end === -1 && tokenChars$1[code] === 1) {
        if (start2 === -1) start2 = i14;
      } else if (start2 !== -1 && (code === 32 || code === 9)) {
        if (end === -1) end = i14;
      } else if (code === 59 || code === 44) {
        if (start2 === -1) {
          throw new SyntaxError(`Unexpected character at index ${i14}`);
        }
        if (end === -1) end = i14;
        let value2 = header.slice(start2, end);
        if (mustUnescape) {
          value2 = value2.replace(/\\/g, "");
          mustUnescape = false;
        }
        push(params, paramName, value2);
        if (code === 44) {
          push(offers, extensionName, params);
          params = /* @__PURE__ */ Object.create(null);
          extensionName = void 0;
        }
        paramName = void 0;
        start2 = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i14}`);
      }
    }
  }
  if (start2 === -1 || inQuotes || code === 32 || code === 9) {
    throw new SyntaxError("Unexpected end of input");
  }
  if (end === -1) end = i14;
  const token = header.slice(start2, end);
  if (extensionName === void 0) {
    push(offers, token, params);
  } else {
    if (paramName === void 0) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ""));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }
  return offers;
}
function format$1(extensions2) {
  return Object.keys(extensions2).map((extension2) => {
    let configurations = extensions2[extension2];
    if (!Array.isArray(configurations)) configurations = [configurations];
    return configurations.map((params) => {
      return [extension2].concat(
        Object.keys(params).map((k13) => {
          let values = params[k13];
          if (!Array.isArray(values)) values = [values];
          return values.map((v15) => v15 === true ? k13 : `${k13}=${v15}`).join("; ");
        })
      ).join("; ");
    }).join(", ");
  }).join(", ");
}
function initAsClient(websocket2, address, protocols, options2) {
  const opts = {
    allowSynchronousEvents: true,
    autoPong: true,
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options2,
    socketPath: void 0,
    hostname: void 0,
    protocol: void 0,
    timeout: void 0,
    method: "GET",
    host: void 0,
    path: void 0,
    port: void 0
  };
  websocket2._autoPong = opts.autoPong;
  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
    );
  }
  let parsedUrl;
  if (address instanceof URL$2) {
    parsedUrl = address;
  } else {
    try {
      parsedUrl = new URL$2(address);
    } catch (e2) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
  }
  if (parsedUrl.protocol === "http:") {
    parsedUrl.protocol = "ws:";
  } else if (parsedUrl.protocol === "https:") {
    parsedUrl.protocol = "wss:";
  }
  websocket2._url = parsedUrl.href;
  const isSecure = parsedUrl.protocol === "wss:";
  const isIpcUrl = parsedUrl.protocol === "ws+unix:";
  let invalidUrlMessage;
  if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
    invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"`;
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = "The URL contains a fragment identifier";
  }
  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);
    if (websocket2._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket2, err);
      return;
    }
  }
  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString("base64");
  const request = isSecure ? https$2.request : http$3.request;
  const protocolSet = /* @__PURE__ */ new Set();
  let perMessageDeflate;
  opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    "Sec-WebSocket-Version": opts.protocolVersion,
    "Sec-WebSocket-Key": key,
    Connection: "Upgrade",
    Upgrade: "websocket"
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;
  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate$1(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers["Sec-WebSocket-Extensions"] = format({
      [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
        throw new SyntaxError(
          "An invalid or duplicated subprotocol was specified"
        );
      }
      protocolSet.add(protocol);
    }
    opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers["Sec-WebSocket-Origin"] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }
  if (isIpcUrl) {
    const parts = opts.path.split(":");
    opts.socketPath = parts[0];
    opts.path = parts[1];
  }
  let req2;
  if (opts.followRedirects) {
    if (websocket2._redirects === 0) {
      websocket2._originalIpc = isIpcUrl;
      websocket2._originalSecure = isSecure;
      websocket2._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
      const headers = options2 && options2.headers;
      options2 = { ...options2, headers: {} };
      if (headers) {
        for (const [key2, value2] of Object.entries(headers)) {
          options2.headers[key2.toLowerCase()] = value2;
        }
      }
    } else if (websocket2.listenerCount("redirect") === 0) {
      const isSameHost = isIpcUrl ? websocket2._originalIpc ? opts.socketPath === websocket2._originalHostOrSocketPath : false : websocket2._originalIpc ? false : parsedUrl.host === websocket2._originalHostOrSocketPath;
      if (!isSameHost || websocket2._originalSecure && !isSecure) {
        delete opts.headers.authorization;
        delete opts.headers.cookie;
        if (!isSameHost) delete opts.headers.host;
        opts.auth = void 0;
      }
    }
    if (opts.auth && !options2.headers.authorization) {
      options2.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
    }
    req2 = websocket2._req = request(opts);
    if (websocket2._redirects) {
      websocket2.emit("redirect", websocket2.url, req2);
    }
  } else {
    req2 = websocket2._req = request(opts);
  }
  if (opts.timeout) {
    req2.on("timeout", () => {
      abortHandshake$1(websocket2, req2, "Opening handshake has timed out");
    });
  }
  req2.on("error", (err) => {
    if (req2 === null || req2[kAborted]) return;
    req2 = websocket2._req = null;
    emitErrorAndClose(websocket2, err);
  });
  req2.on("response", (res) => {
    const location2 = res.headers.location;
    const statusCode = res.statusCode;
    if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
      if (++websocket2._redirects > opts.maxRedirects) {
        abortHandshake$1(websocket2, req2, "Maximum redirects exceeded");
        return;
      }
      req2.abort();
      let addr;
      try {
        addr = new URL$2(location2, address);
      } catch (e2) {
        const err = new SyntaxError(`Invalid URL: ${location2}`);
        emitErrorAndClose(websocket2, err);
        return;
      }
      initAsClient(websocket2, addr, protocols, options2);
    } else if (!websocket2.emit("unexpected-response", req2, res)) {
      abortHandshake$1(
        websocket2,
        req2,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });
  req2.on("upgrade", (res, socket, head) => {
    websocket2.emit("upgrade", res);
    if (websocket2.readyState !== WebSocket$1.CONNECTING) return;
    req2 = websocket2._req = null;
    const upgrade = res.headers.upgrade;
    if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
      abortHandshake$1(websocket2, socket, "Invalid Upgrade header");
      return;
    }
    const digest = createHash$1("sha1").update(key + GUID$1).digest("base64");
    if (res.headers["sec-websocket-accept"] !== digest) {
      abortHandshake$1(websocket2, socket, "Invalid Sec-WebSocket-Accept header");
      return;
    }
    const serverProt = res.headers["sec-websocket-protocol"];
    let protError;
    if (serverProt !== void 0) {
      if (!protocolSet.size) {
        protError = "Server sent a subprotocol but none was requested";
      } else if (!protocolSet.has(serverProt)) {
        protError = "Server sent an invalid subprotocol";
      }
    } else if (protocolSet.size) {
      protError = "Server sent no subprotocol";
    }
    if (protError) {
      abortHandshake$1(websocket2, socket, protError);
      return;
    }
    if (serverProt) websocket2._protocol = serverProt;
    const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
    if (secWebSocketExtensions !== void 0) {
      if (!perMessageDeflate) {
        const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      let extensions2;
      try {
        extensions2 = parse$12(secWebSocketExtensions);
      } catch (err) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      const extensionNames = Object.keys(extensions2);
      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {
        const message = "Server indicated an extension that was not requested";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      try {
        perMessageDeflate.accept(extensions2[PerMessageDeflate$1.extensionName]);
      } catch (err) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      websocket2._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;
    }
    websocket2.setSocket(socket, head, {
      allowSynchronousEvents: opts.allowSynchronousEvents,
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });
  if (opts.finishRequest) {
    opts.finishRequest(req2, websocket2);
  } else {
    req2.end();
  }
}
function emitErrorAndClose(websocket2, err) {
  websocket2._readyState = WebSocket$1.CLOSING;
  websocket2._errorEmitted = true;
  websocket2.emit("error", err);
  websocket2.emitClose();
}
function netConnect(options2) {
  options2.path = options2.socketPath;
  return net.connect(options2);
}
function tlsConnect(options2) {
  options2.path = void 0;
  if (!options2.servername && options2.servername !== "") {
    options2.servername = net.isIP(options2.host) ? "" : options2.host;
  }
  return tls.connect(options2);
}
function abortHandshake$1(websocket2, stream4, message) {
  websocket2._readyState = WebSocket$1.CLOSING;
  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake$1);
  if (stream4.setHeader) {
    stream4[kAborted] = true;
    stream4.abort();
    if (stream4.socket && !stream4.socket.destroyed) {
      stream4.socket.destroy();
    }
    process.nextTick(emitErrorAndClose, websocket2, err);
  } else {
    stream4.destroy(err);
    stream4.once("error", websocket2.emit.bind(websocket2, "error"));
    stream4.once("close", websocket2.emitClose.bind(websocket2));
  }
}
function sendAfterClose(websocket2, data, cb) {
  if (data) {
    const length = isBlob(data) ? data.size : toBuffer(data).length;
    if (websocket2._socket) websocket2._sender._bufferedBytes += length;
    else websocket2._bufferedAmount += length;
  }
  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket2.readyState} (${readyStates[websocket2.readyState]})`
    );
    process.nextTick(cb, err);
  }
}
function receiverOnConclude(code, reason) {
  const websocket2 = this[kWebSocket$1];
  websocket2._closeFrameReceived = true;
  websocket2._closeMessage = reason;
  websocket2._closeCode = code;
  if (websocket2._socket[kWebSocket$1] === void 0) return;
  websocket2._socket.removeListener("data", socketOnData);
  process.nextTick(resume, websocket2._socket);
  if (code === 1005) websocket2.close();
  else websocket2.close(code, reason);
}
function receiverOnDrain() {
  const websocket2 = this[kWebSocket$1];
  if (!websocket2.isPaused) websocket2._socket.resume();
}
function receiverOnError(err) {
  const websocket2 = this[kWebSocket$1];
  if (websocket2._socket[kWebSocket$1] !== void 0) {
    websocket2._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket2._socket);
    websocket2.close(err[kStatusCode]);
  }
  if (!websocket2._errorEmitted) {
    websocket2._errorEmitted = true;
    websocket2.emit("error", err);
  }
}
function receiverOnFinish() {
  this[kWebSocket$1].emitClose();
}
function receiverOnMessage(data, isBinary) {
  this[kWebSocket$1].emit("message", data, isBinary);
}
function receiverOnPing(data) {
  const websocket2 = this[kWebSocket$1];
  if (websocket2._autoPong) websocket2.pong(data, !this._isServer, NOOP$1);
  websocket2.emit("ping", data);
}
function receiverOnPong(data) {
  this[kWebSocket$1].emit("pong", data);
}
function resume(stream4) {
  stream4.resume();
}
function senderOnError(err) {
  const websocket2 = this[kWebSocket$1];
  if (websocket2.readyState === WebSocket$1.CLOSED) return;
  if (websocket2.readyState === WebSocket$1.OPEN) {
    websocket2._readyState = WebSocket$1.CLOSING;
    setCloseTimer(websocket2);
  }
  this._socket.end();
  if (!websocket2._errorEmitted) {
    websocket2._errorEmitted = true;
    websocket2.emit("error", err);
  }
}
function setCloseTimer(websocket2) {
  websocket2._closeTimer = setTimeout(
    websocket2._socket.destroy.bind(websocket2._socket),
    closeTimeout
  );
}
function socketOnClose() {
  const websocket2 = this[kWebSocket$1];
  this.removeListener("close", socketOnClose);
  this.removeListener("data", socketOnData);
  this.removeListener("end", socketOnEnd);
  websocket2._readyState = WebSocket$1.CLOSING;
  let chunk;
  if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {
    websocket2._receiver.write(chunk);
  }
  websocket2._receiver.end();
  this[kWebSocket$1] = void 0;
  clearTimeout(websocket2._closeTimer);
  if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {
    websocket2.emitClose();
  } else {
    websocket2._receiver.on("error", receiverOnFinish);
    websocket2._receiver.on("finish", receiverOnFinish);
  }
}
function socketOnData(chunk) {
  if (!this[kWebSocket$1]._receiver.write(chunk)) {
    this.pause();
  }
}
function socketOnEnd() {
  const websocket2 = this[kWebSocket$1];
  websocket2._readyState = WebSocket$1.CLOSING;
  websocket2._receiver.end();
  this.end();
}
function socketOnError$1() {
  const websocket2 = this[kWebSocket$1];
  this.removeListener("error", socketOnError$1);
  this.on("error", NOOP$1);
  if (websocket2) {
    websocket2._readyState = WebSocket$1.CLOSING;
    this.destroy();
  }
}
function parse5(header) {
  const protocols = /* @__PURE__ */ new Set();
  let start2 = -1;
  let end = -1;
  let i14 = 0;
  for (i14; i14 < header.length; i14++) {
    const code = header.charCodeAt(i14);
    if (end === -1 && tokenChars[code] === 1) {
      if (start2 === -1) start2 = i14;
    } else if (i14 !== 0 && (code === 32 || code === 9)) {
      if (end === -1 && start2 !== -1) end = i14;
    } else if (code === 44) {
      if (start2 === -1) {
        throw new SyntaxError(`Unexpected character at index ${i14}`);
      }
      if (end === -1) end = i14;
      const protocol2 = header.slice(start2, end);
      if (protocols.has(protocol2)) {
        throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
      }
      protocols.add(protocol2);
      start2 = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i14}`);
    }
  }
  if (start2 === -1 || end !== -1) {
    throw new SyntaxError("Unexpected end of input");
  }
  const protocol = header.slice(start2, i14);
  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }
  protocols.add(protocol);
  return protocols;
}
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);
  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}
function emitClose(server) {
  server._state = CLOSED;
  server.emit("close");
}
function socketOnError() {
  this.destroy();
}
function abortHandshake(socket, code, message, headers) {
  message = message || http$2.STATUS_CODES[code];
  headers = {
    Connection: "close",
    "Content-Type": "text/html",
    "Content-Length": Buffer.byteLength(message),
    ...headers
  };
  socket.once("finish", socket.destroy);
  socket.end(
    `HTTP/1.1 ${code} ${http$2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h20) => `${h20}: ${headers[h20]}`).join("\r\n") + "\r\n\r\n" + message
  );
}
function abortHandshakeOrEmitwsClientError(server, req2, socket, code, message) {
  if (server.listenerCount("wsClientError")) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
    server.emit("wsClientError", err, socket, req2);
  } else {
    abortHandshake(socket, code, message);
  }
}
function RedirectableRequest(options2, responseCallback) {
  Writable.call(this);
  this._sanitizeOptions(options2);
  this._options = options2;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];
  if (responseCallback) {
    this.on("response", responseCallback);
  }
  var self2 = this;
  this._onNativeResponse = function(response) {
    try {
      self2._processResponse(response);
    } catch (cause) {
      self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
    }
  };
  this._performRequest();
}
function wrap(protocols) {
  var exports4 = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024
  };
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function(scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports4[scheme] = Object.create(nativeProtocol);
    function request(input, options2, callback) {
      if (isURL(input)) {
        input = spreadUrlObject(input);
      } else if (isString2(input)) {
        input = spreadUrlObject(parseUrl(input));
      } else {
        callback = options2;
        options2 = validateUrl(input);
        input = { protocol };
      }
      if (isFunction(options2)) {
        callback = options2;
        options2 = null;
      }
      options2 = Object.assign({
        maxRedirects: exports4.maxRedirects,
        maxBodyLength: exports4.maxBodyLength
      }, input, options2);
      options2.nativeProtocols = nativeProtocols;
      if (!isString2(options2.host) && !isString2(options2.hostname)) {
        options2.hostname = "::1";
      }
      assert.equal(options2.protocol, protocol, "protocol mismatch");
      debug$5("options", options2);
      return new RedirectableRequest(options2, callback);
    }
    function get(input, options2, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options2, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get, configurable: true, enumerable: true, writable: true }
    });
  });
  return exports4;
}
function noop() {
}
function parseUrl(input) {
  var parsed;
  if (useNativeURL) {
    parsed = new URL$1(input);
  } else {
    parsed = validateUrl(url.parse(input));
    if (!isString2(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}
function resolveUrl(relative3, base) {
  return useNativeURL ? new URL$1(relative3, base) : parseUrl(url.resolve(base, relative3));
}
function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}
function spreadUrlObject(urlObject, target) {
  var spread = target || {};
  for (var key of preservedUrlFields) {
    spread[key] = urlObject[key];
  }
  if (spread.hostname.startsWith("[")) {
    spread.hostname = spread.hostname.slice(1, -1);
  }
  if (spread.port !== "") {
    spread.port = Number(spread.port);
  }
  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
  return spread;
}
function removeMatchingHeaders(regex2, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex2.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
}
function createErrorType(code, message, baseClass) {
  function CustomError(properties) {
    Error.captureStackTrace(this, this.constructor);
    Object.assign(this, properties || {});
    this.code = code;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false
    },
    name: {
      value: "Error [" + code + "]",
      enumerable: false
    }
  });
  return CustomError;
}
function destroyRequest(request, error2) {
  for (var event of events) {
    request.removeListener(event, eventHandlers[event]);
  }
  request.on("error", noop);
  request.destroy(error2);
}
function isSubdomain(subdomain, domain) {
  assert(isString2(subdomain) && isString2(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function isString2(value2) {
  return typeof value2 === "string" || value2 instanceof String;
}
function isFunction(value2) {
  return typeof value2 === "function";
}
function isBuffer(value2) {
  return typeof value2 === "object" && "length" in value2;
}
function isURL(value2) {
  return URL$1 && value2 instanceof URL$1;
}
function createProxyServer(options2) {
  return new ProxyServer(options2);
}
function escapeId(id3) {
  if (!needsEscapeRegEx.test(id3)) return id3;
  return id3.replace(backSlashRegEx, "\\\\").replace(quoteNewlineRegEx, "\\$1");
}
var module2, __filename4, __dirname4, require27, __require2, commonjsGlobal, picocolors, argv, env$1, isColorSupported, formatter, replaceClose, createColors, picocolorsExports, colors$1, VALID_ID_PREFIX, SOURCEMAPPING_URL, isWindows$3, windowsSlashRE, postfixRE, AsyncFunction, utils$k, path$m, WIN_SLASH, WIN_NO_SLASH, DOT_LITERAL, PLUS_LITERAL, QMARK_LITERAL, SLASH_LITERAL, ONE_CHAR, QMARK, END_ANCHOR, START_ANCHOR, DOTS_SLASH, NO_DOT, NO_DOTS, NO_DOT_SLASH, NO_DOTS_SLASH, QMARK_NO_DOT, STAR$1, POSIX_CHARS, WINDOWS_CHARS, POSIX_REGEX_SOURCE$1, constants$6, utils$j, CHAR_ASTERISK, CHAR_AT, CHAR_BACKWARD_SLASH, CHAR_COMMA$1, CHAR_DOT$1, CHAR_EXCLAMATION_MARK, CHAR_FORWARD_SLASH, CHAR_LEFT_CURLY_BRACE$1, CHAR_LEFT_PARENTHESES$1, CHAR_LEFT_SQUARE_BRACKET$1, CHAR_PLUS, CHAR_QUESTION_MARK, CHAR_RIGHT_CURLY_BRACE$1, CHAR_RIGHT_PARENTHESES$1, CHAR_RIGHT_SQUARE_BRACKET$1, isPathSeparator, depth, scan$2, scan_1, constants$5, utils$i, MAX_LENGTH$1, POSIX_REGEX_SOURCE, REGEX_NON_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS, expandRange, syntaxError, parse$g, parse_1$3, path$l, scan$1, parse$f, utils$h, constants$4, isObject$3, picomatch$5, picomatch_1, picomatch$3, reservedWords, builtins, forbiddenIdentifiers, hasStringIsWellFormed, balancedMatch, balanced, braceExpansion, escSlash, escOpen, escClose, escComma, escPeriod, expand$4, MAX_PATTERN_LENGTH, assertValidPattern, posixClasses, braceEscape, regexpEscape, rangesToString, parseClass, unescape$1, types$1, isExtglobType, startNoTraversal, startNoDot, addPatternStart, justDots, reSpecials, regExpEscape$1, qmark$1, star$1, starNoEmpty, AST, escape$2, minimatch, starDotExtRE, starDotExtTest, starDotExtTestDot, starDotExtTestNocase, starDotExtTestNocaseDot, starDotStarRE, starDotStarTest, starDotStarTestDot, dotStarRE, dotStarTest, starRE, starTest, starTestDot, qmarksRE, qmarksTestNocase, qmarksTestNocaseDot, qmarksTestDot, qmarksTest, qmarksTestNoExt, qmarksTestNoExtDot, defaultPlatform$2, path$j, sep, GLOBSTAR$2, qmark, star2, twoStarDot, twoStarNoDot, filter$1, ext, defaults, braceExpand, makeRe$1, match, globMagic, regExpEscape, Minimatch, perf, warned$1, PROCESS, emitWarning, AC, AS, shouldWarn, isPosInt, getUintArray, ZeroArray, Stack, LRUCache, proc, isStream, isReadable, isWritable, EOF, MAYBE_EMIT_END, EMITTED_END, EMITTING_END, EMITTED_ERROR, CLOSED$1, READ, FLUSH, FLUSHCHUNK, ENCODING$1, DECODER, FLOWING, PAUSED, RESUME, BUFFER, PIPES, BUFFERLENGTH, BUFFERPUSH, BUFFERSHIFT, OBJECTMODE, DESTROYED, ERROR, EMITDATA, EMITEND, EMITEND2, ASYNC, ABORT, ABORTED, SIGNAL, DATALISTENERS, DISCARDED, defer$3, nodefer, isEndish, isArrayBufferLike, isArrayBufferView, Pipe, PipeProxyErrors, isObjectModeOptions, isEncodingOptions, Minipass, realpathSync, defaultFS, fsFromOption, uncDriveRegexp, uncToDrive, eitherSep, UNKNOWN, IFIFO, IFCHR, IFDIR, IFBLK, IFREG, IFLNK, IFSOCK, IFMT, IFMT_UNKNOWN, READDIR_CALLED, LSTAT_CALLED, ENOTDIR, ENOENT, ENOREADLINK, ENOREALPATH, ENOCHILD, TYPEMASK, entToType, normalizeCache, normalize2, normalizeNocaseCache, normalizeNocase, ResolveCache, ChildrenCache, setAsCwd, PathBase, PathWin32, PathPosix, PathScurryBase, PathScurryWin32, PathScurryPosix, PathScurryDarwin, PathScurry, isPatternList, isGlobList, Pattern, defaultPlatform$1, Ignore, HasWalkedCache, MatchRecord, SubWalks, Processor, makeIgnore, GlobUtil, GlobWalker, GlobStream, defaultPlatform, Glob, hasMagic, streamSync, stream$5, iterateSync, iterate, sync$9, glob$1, comma3, semicolon2, chars$1, intToChar, charToInt, bufLength, src$32, browser$3, ms$1, hasRequiredMs$1, common$b, hasRequiredCommon, hasRequiredBrowser$1, node$12, hasRequiredNode$1, srcExports$12, debug$i, pnp, nodeBuiltins, _require$1, rollupVersion, filter, DEBUG, urlCanParse, isCaseInsensitiveFS, externalRE, isExternalUrl, dataUrlRE, isDataUrl, internalPrefixes, InternalPrefixRE, safeRealpathSync, windowsNetworkMap, parseNetUseRE, firstSafeRealPathSyncRun, escapedSpaceCharacters, imageSetUrlRE, cleanSrcSetRE, blankReplacer, _dirname, groups, POSIX_SEP_RE, NATIVE_SEP_RE, TS_EXTENSIONS, JS_EXTENSIONS, TSJS_EXTENSIONS, TS_EXTENSIONS_RE_GROUP, TSJS_EXTENSIONS_RE_GROUP, IS_POSIX, singleComment, multiComment, debug$h, GIT_LFS_PREFIX, ImportType, A14, C18, init, E10, convertSourceMap$1, debug$g, tasks, utils$g, array$1, errno$1, fs$i, DirentFromStats$1, path$i, os$4, path$h, IS_WINDOWS_PLATFORM, LEADING_DOT_SEGMENT_CHARACTERS_COUNT, POSIX_UNESCAPED_GLOB_SYMBOLS_RE, WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, DOS_DEVICE_PATH_RE, WINDOWS_BACKSLASHES_RE, pattern$1, isExtglob$1, isExtglob2, chars, strictCheck, relaxedCheck, isGlob$2, isGlob$1, pathPosixDirname, isWin32, slash3, backslash3, enclosure, globby, escaped, globParent$2, utils$f, utils$e, stringify$7, isNumber$2, isNumber$1, toRegexRange$1, toRegexRange_1, util$1, toRegexRange, isObject, transform, isValidValue, isNumber, zeros, stringify$6, pad, toMaxLen, toSequence, toRange, toRegex, rangeError, invalidRange, invalidStep, fillNumbers, fillLetters, fill$2, fillRange, fill$1, utils$d, compile$1, compile_1, fill, stringify$5, utils$c, append$1, expand$2, expand_1$1, constants$3, stringify$4, MAX_LENGTH, CHAR_BACKSLASH, CHAR_BACKTICK, CHAR_COMMA, CHAR_DOT, CHAR_LEFT_PARENTHESES, CHAR_RIGHT_PARENTHESES, CHAR_LEFT_CURLY_BRACE, CHAR_RIGHT_CURLY_BRACE, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE, parse$c, parse_1$2, stringify$3, compile, expand$1, parse$b, braces$2, braces_1, util2, braces$1, picomatch$2, utils$b, isEmptyString, hasBraces, micromatch$1, micromatch_1, micromatch$2, path$g, globParent$1, micromatch, GLOBSTAR$1, ESCAPE_SYMBOL, COMMON_GLOB_SYMBOLS_RE, REGEX_CHARACTER_CLASS_SYMBOLS_RE, REGEX_GROUP_SYMBOLS_RE, GLOB_EXTENSION_SYMBOLS_RE, BRACE_EXPANSION_SEPARATORS_RE, DOUBLE_SLASH_RE$1, stream$4, Stream, PassThrough, slice, merge2_1, merge22, string$2, array, errno, fs$h, path$f, pattern, stream$3, string$12, utils$a, async$7, async$6, out$3, async$5, async$4, out$2, async$3, out$1, async$2, sync$8, settings$3, fs$g, fs$f, Settings$2, async$1, sync$7, settings_1$3, promise, queueMicrotask_1, runParallel_1, queueMicrotask$1, constants$2, NODE_PROCESS_VERSION_PARTS, MAJOR_VERSION, MINOR_VERSION, SUPPORTED_MAJOR_VERSION, SUPPORTED_MINOR_VERSION, IS_MATCHED_BY_MAJOR, IS_MATCHED_BY_MAJOR_AND_MINOR, utils$9, fs$e, DirentFromStats2, fs$d, common$a, fsStat$5, rpl, constants_1$1, utils$8, common$9, sync$6, fsStat$4, constants_1, utils$7, common$8, settings$2, fs$c, path$e, fsStat$3, fs$b, Settings$1, async, sync$5, settings_1$2, queue, reusify_1, reusify, queueExports, common$7, reader$1, common$6, Reader$1, events_1, fsScandir$2, fastq, common$5, reader_1$4, AsyncReader, async_1$4, AsyncProvider, stream$2, stream_1$5, async_1$3, StreamProvider, sync$4, sync$3, fsScandir$1, common$4, reader_1$3, SyncReader, sync_1$3, SyncProvider, settings$1, path$d, fsScandir, Settings3, async_1$2, stream_1$4, sync_1$2, settings_1$1, reader, path$c, fsStat$2, utils$6, Reader2, stream$1, stream_1$3, fsStat$1, fsWalk$2, reader_1$2, ReaderStream, fsWalk$1, reader_1$1, stream_1$2, ReaderAsync, provider, deep, partial, matcher, utils$5, Matcher, matcher_1, PartialMatcher, utils$4, partial_1, DeepFilter, entry$1, utils$3, EntryFilter, error$1, utils$2, ErrorFilter, entry, utils$1, EntryTransformer, path$b, deep_1, entry_1, error_1, entry_2, Provider, async_1$1, provider_1$2, ProviderAsync, stream, stream_1$1, stream_2, provider_1$1, ProviderStream, sync$2, sync$1, fsStat, fsWalk, reader_1, ReaderSync, sync_1$1, provider_1, ProviderSync, settings, taskManager, async_1, stream_1, sync_1, settings_1, utils, src$22, path$a, fs$a, os$3, fsReadFileAsync, jsonLoader, requireFunc, defaultLoadersSync, dynamicImport, defaultLoaders, makeEmplace, ALIAS, DOC, MAP, PAIR, SCALAR$1, SEQ, NODE_TYPE, isAlias, isDocument, isMap, isPair, isScalar$1, isSeq, hasAnchor, BREAK$1, SKIP$1, REMOVE$1, escapeChars, escapeTagName, Directives, NodeBase, Alias, isScalarValue, Scalar, defaultTagPrefix, isEmptyPath, Collection, stringifyComment, lineComment, FOLD_FLOW, FOLD_BLOCK, FOLD_QUOTED, getFoldOptions, containsDocumentMarker, blockEndNewlines, MERGE_KEY, isMergeKey, Pair, YAMLMap, map$1, YAMLSeq, seq, string3, nullTag, boolTag, floatNaN$1, floatExp$1, float$1, intIdentify$2, intResolve$1, intOct$1, int$1, intHex$1, schema$2, stringifyJSON, jsonScalars, jsonError, schema$1, binary, pairs, YAMLOMap, omap, trueTag, falseTag, floatNaN, floatExp, float, intIdentify, intBin, intOct, int, intHex, YAMLSet, set, intTime, floatTime, timestamp, schema, schemas, tagsByName, coreKnownTags, sortMapEntriesByKey, Schema, Document, YAMLError, YAMLParseError, YAMLWarning, prettifyError, startColMsg, blockMsg, isBlock$1, escapeCodes, CN, Composer, stringify$12, BREAK, SKIP, REMOVE, BOM, DOCUMENT, FLOW_END, SCALAR, isCollection, isScalar, cst, hexDigits, tagChars, flowIndicatorChars, invalidAnchorChars, isNotAnchorChar, Lexer, LineCounter, Parser2, YAML, browser$2, require$$32, createRequire, createRequireFromPath, req_1, req$1, options, options_1, req, load, plugins, plugins_1, resolve4, url$4, config$1, yaml, loadOptions, loadPlugins, interopRequireDefault, processResult, createContext, importDefault, addTypeScriptLoader, withTypeScriptLoader, rc, HashbangComment, Identifier2, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace, main$1, name, version$1, description, main, types2, exports3, scripts, repository, funding, keywords, readmeFilename, license, devDependencies, engines, browser$1, require$$4, fs$9, path$9, os$2, crypto$1, packageJson, version2, LINE, DotenvModule, parse_1$1, modulePreloadPolyfillId, resolvedModulePreloadPolyfillId, moduleScriptRE, modulePreloadLinkRE, importMapAppendRE, decoder, cssModuleRE, functionCallRE, nonEscapedDoubleQuoteRe, importPostcssImport, importPostcssModules, importPostcss, cssUrlRE, cssImageSetRE, UrlRewritePostcssPlugin, cssNotProcessedRE, importLightningCSS, own$1, classRegExp, kTypes, messages, nodeInternalPrefix, userStackTraceLimit, captureLargerStackTrace, isMatch$1, scan, basename2, dirname2, relative2, join, src2, browser, debug$f, ms, hasRequiredMs, hasRequiredDebug, hasRequiredBrowser, node2, hasRequiredNode, srcExports2, encodeurl, ENCODE_CHARS_REGEXP, UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE, matchHtmlRegExp, escapeHtml_1, onFinished$2, eeFirst, first, defer$2, onFinishedExports, parseurl$1, url$3, parse$8, Url, parseurlExports, require$$0$12, codes, statuses$1, unpipe_1, debug$e, encodeUrl, escapeHtml, onFinished, parseUrl$2, statuses, unpipe, DOUBLE_SPACE_REGEXP, NEWLINE_REGEXP, defer$1, isFinished, finalhandler_1, utilsMerge, utilsMergeExports, debug$d, EventEmitter$3, finalhandler, http$4, parseUrl$1, env, proto, defer, lib2, getOwnPropertySymbols, hasOwnProperty2, propIsEnumerable, objectAssign, vary$1, FIELD_NAME_REGEXP, varyExports, libExports, chokidar, fs$8, Readable, sysPath$3, promisify$3, picomatch$1, readdir$1, stat$3, lstat$2, realpath$1, BANG$2, RECURSIVE_ERROR_CODE, NORMAL_FLOW_ERRORS, FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE, ALL_TYPES, isNormalFlowError, maj, min, wantBigintFsStats, normalizeFilter, ReaddirpStream, readdirp$1, readdirpPromise, readdirp_1, anymatch$2, normalizePath$2, anymatch_1, picomatch, normalizePath$1, BANG$1, DEFAULT_OPTIONS, arrify$1, createPattern, matchPatterns, anymatch$1, anymatchExports, require$$02, binaryExtensions$1, path$8, binaryExtensions, extensions, isBinaryPath$1, constants$1, fs$7, sysPath$2, promisify$2, isBinaryPath, isWindows$2, isLinux, EMPTY_FN$2, EMPTY_STR$1, KEY_LISTENERS, KEY_ERR, KEY_RAW, HANDLER_KEYS, EV_CHANGE$2, EV_ADD$2, EV_ADD_DIR$2, EV_ERROR$2, STR_DATA$1, STR_END$2, BRACE_START$1, STAR, THROTTLE_MODE_WATCH, open$2, stat$2, lstat$1, close, fsrealpath, statMethods$1, foreach, addAndConvert, clearItem, delFromSet, isEmptySet, FsWatchInstances, fsWatchBroadcast, setFsWatchListener, FsWatchFileInstances, setFsWatchFileListener, NodeFsHandler$1, nodefsHandler, fseventsHandler, fs$6, sysPath$1, promisify$1, fsevents, EV_ADD$1, EV_CHANGE$1, EV_ADD_DIR$1, EV_UNLINK$1, EV_ERROR$1, STR_DATA, STR_END$1, FSEVENT_CREATED, FSEVENT_MODIFIED, FSEVENT_DELETED, FSEVENT_MOVED, FSEVENT_UNKNOWN, FSEVENT_FLAG_MUST_SCAN_SUBDIRS, FSEVENT_TYPE_FILE, FSEVENT_TYPE_DIRECTORY, FSEVENT_TYPE_SYMLINK, ROOT_GLOBSTAR, DIR_SUFFIX, DOT_SLASH, FUNCTION_TYPE$1, EMPTY_FN$1, IDENTITY_FN, Depth, stat$1, lstat, realpath, statMethods, FSEventsWatchers, consolidateThreshhold, wrongEventFlags, createFSEventsInstance, couldConsolidate, canUse, calcDepth, sameTypes, FsEventsHandler$1, fseventsHandlerExports, EventEmitter$2, fs$5, sysPath, promisify, readdirp, anymatch, globParent2, isGlob2, braces, normalizePath, NodeFsHandler2, FsEventsHandler2, EV_ALL, EV_READY, EV_ADD, EV_CHANGE, EV_UNLINK, EV_ADD_DIR, EV_UNLINK_DIR, EV_RAW, EV_ERROR, STR_CLOSE, STR_END, BACK_SLASH_RE, DOUBLE_SLASH_RE, SLASH_OR_BACK_SLASH_RE, DOT_RE, REPLACER_RE, SLASH, SLASH_SLASH, BRACE_START, BANG, ONE_DOT, TWO_DOTS, GLOBSTAR, SLASH_GLOBSTAR, ANYMATCH_OPTS, STRING_TYPE, FUNCTION_TYPE, EMPTY_STR, EMPTY_FN, isWindows$1, isMacos, isIBMi, stat2, readdir, arrify, flatten, unifyPaths, toUnix, normalizePathToUnix, normalizeIgnored, getAbsolutePath, undef, DirEntry, STAT_METHOD_F, STAT_METHOD_L, WatchHelper, FSWatcher, watch, shellQuote$1, quote, CONTROL, controlRE, META, SINGLE_QUOTE, DOUBLE_QUOTE, hash2, SQ, DQ, DS, TOKEN, mult, i14, startsWithToken, parse$6, commonFsUtils, Stats, normalizedClientEntry$1, normalizedEnvEntry$1, debug$c, externalTypes, debug$b, jsonLangs, jsonLangRE, debug$a, normalizedClientEntry, normalizedEnvEntry, wasmHelper, wasmHelperCode, regex, EMPTY_OBJECT2, debugSourcemapCombineFilter, debugSourcemapCombine, debugResolve, debugPluginResolve, debugPluginTransform, debug$9, debug$8, debug$7, lockfileFormats, lockfileNames, MAX_TEMP_DIR_AGE_MS, GRACEFUL_RENAME_TIMEOUT, safeRename, debugLoad, debugTransform, debugCache$1, isWsl$2, fs$3, isDocker$2, isDocker_1, os, fs$2, isDocker$1, isWsl$1, isWslExports, defineLazyProp, path$32, childProcess, fs$1, fsConstants, isWsl, isDocker, defineLazyProperty, localXdgOpenPath, platform, arch, hasContainerEnv, cachedResult, getWslDrivesMountPoint, pTryEach, baseOpen, open, openApp, apps, crossSpawn, windows, hasRequiredWindows, mode, hasRequiredMode, core, isexe_1, isWindows, path$22, COLON, isexe, getNotFoundError, getPathInfo, which$1, whichSync, which_1, pathKey$1, pathKey, pathKeyExports, path$13, which, getPathKey, resolveCommand_1, _escape, metaCharsRegExp, shebangRegex$1, shebangRegex, shebangCommand$1, fs4, shebangCommand, readShebang_1, path5, resolveCommand, escape$1, readShebang, isWin$1, isExecutableRegExp, isCmdShimRegExp, parse_1, isWin, enoent$1, cp, parse$3, enoent, crossSpawnExports, OTHER_SOURCE_MAP_REGEXP, bufferUtil$1, BINARY_TYPES$2, hasBlob$1, constants, EMPTY_BUFFER$3, FastBuffer$2, bufferUtilExports, kDone, kRun, Limiter$1, limiter, zlib, bufferUtil, Limiter2, kStatusCode$2, FastBuffer$1, TRAILER, kPerMessageDeflate, kTotalLength, kCallback, kBuffers, kError$1, zlibLimiter, PerMessageDeflate$4, permessageDeflate, validation, isUtf8, hasBlob, tokenChars$2, validationExports, Writable$1, PerMessageDeflate$3, BINARY_TYPES$1, EMPTY_BUFFER$2, kStatusCode$1, kWebSocket$3, concat, toArrayBuffer, unmask, isValidStatusCode$1, isValidUTF8, FastBuffer, GET_INFO, GET_PAYLOAD_LENGTH_16, GET_PAYLOAD_LENGTH_64, GET_MASK, GET_DATA, INFLATING, DEFER_EVENT, Receiver$1, receiver, randomFillSync, PerMessageDeflate$2, EMPTY_BUFFER$1, kWebSocket$2, NOOP$2, isBlob$1, isValidStatusCode, applyMask, toBuffer$1, kByteLength, maskBuffer, RANDOM_POOL_SIZE, randomPool, randomPoolPointer, DEFAULT, DEFLATING, GET_BLOB_DATA, Sender$1, sender, kForOnEventAttribute$1, kListener$1, kCode, kData, kError, kMessage, kReason, kTarget, kType, kWasClean, Event$1, CloseEvent, ErrorEvent, MessageEvent, EventTarget, eventTarget, tokenChars$1, extension$1, EventEmitter$1, https$2, http$3, net, tls, randomBytes, createHash$1, URL$2, PerMessageDeflate$1, Receiver2, Sender2, isBlob, BINARY_TYPES, EMPTY_BUFFER, GUID$1, kForOnEventAttribute, kListener, kStatusCode, kWebSocket$1, NOOP$1, addEventListener, removeEventListener, format, parse$12, toBuffer, closeTimeout, kAborted, protocolVersions, readyStates, subprotocolRegex, WebSocket$1, websocket, tokenChars, subprotocol$1, EventEmitter, http$2, createHash, extension, PerMessageDeflate2, subprotocol, WebSocket2, GUID, kWebSocket, keyRegex, RUNNING, CLOSING, CLOSED, WebSocketServer, websocketServer, WebSocketServerRaw_, WebSocketServerRaw, httpProxy$3, eventemitter3, eventemitter3Exports, common$3, requiresPort, url$1, common$2, redirectRegex, webOutgoing, followRedirects$1, debug$6, debug_1, url, URL$1, http$1, https$1, Writable, assert, debug$5, useNativeURL, preservedUrlFields, events, eventHandlers, InvalidUrlError, RedirectionError, TooManyRedirectsError, MaxBodyLengthExceededError, WriteAfterEndError, destroy, followRedirectsExports, httpNative, httpsNative, web_o, common$1, followRedirects, nativeAgents, webIncoming, http, https, common, wsIncoming, httpProxyExports, ProxyServer, debug$4, debug$3, debug$2, debugCache, logTime, debugHmr, normalizedClientDir, debug$1, clientDir, preloadMarker, preloadMarkerRE, needsEscapeRegEx, quoteNewlineRegEx, backSlashRegEx, getResolveUrl, getRelativeUrlFromDocument, getFileUrlFromFullPath, getFileUrlFromRelativePath, relativeUrlMechanisms, customRelativeUrlMechanisms, debug, promisifiedRealpath, _require, dep_BWSbWtLw_default;
var init_dep_BWSbWtLw = __esm({
  "dist/node/chunks/dep-BWSbWtLw.js"() {
    init_esbuild_0_24();
    init_constants();
    init_parseAst2();
    module2 = module2 || {};
    module2.exports = module2.exports || {};
    __filename4 = __cjs_fileURLToPath4(import.meta.url);
    __dirname4 = __cjs_dirname4(__filename4);
    require27 = __cjs_createRequire4(import.meta.url);
    __require2 = require27;
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    picocolors = { exports: {} };
    argv = process.argv || [];
    env$1 = process.env;
    isColorSupported = !("NO_COLOR" in env$1 || argv.includes("--no-color")) && ("FORCE_COLOR" in env$1 || argv.includes("--color") || process.platform === "win32" || commonjsRequire != null && require$$0$3.isatty(1) && env$1.TERM !== "dumb" || "CI" in env$1);
    formatter = (open2, close2, replace = open2) => (input) => {
      let string4 = "" + input;
      let index3 = string4.indexOf(close2, open2.length);
      return ~index3 ? open2 + replaceClose(string4, close2, replace, index3) + close2 : open2 + string4 + close2;
    };
    replaceClose = (string4, close2, replace, index3) => {
      let result = "";
      let cursor = 0;
      do {
        result += string4.substring(cursor, index3) + replace;
        cursor = index3 + close2.length;
        index3 = string4.indexOf(close2, cursor);
      } while (~index3);
      return result + string4.substring(cursor);
    };
    createColors = (enabled = isColorSupported) => {
      let init2 = enabled ? formatter : () => String;
      return {
        isColorSupported: enabled,
        reset: init2("\x1B[0m", "\x1B[0m"),
        bold: init2("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
        dim: init2("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
        italic: init2("\x1B[3m", "\x1B[23m"),
        underline: init2("\x1B[4m", "\x1B[24m"),
        inverse: init2("\x1B[7m", "\x1B[27m"),
        hidden: init2("\x1B[8m", "\x1B[28m"),
        strikethrough: init2("\x1B[9m", "\x1B[29m"),
        black: init2("\x1B[30m", "\x1B[39m"),
        red: init2("\x1B[31m", "\x1B[39m"),
        green: init2("\x1B[32m", "\x1B[39m"),
        yellow: init2("\x1B[33m", "\x1B[39m"),
        blue: init2("\x1B[34m", "\x1B[39m"),
        magenta: init2("\x1B[35m", "\x1B[39m"),
        cyan: init2("\x1B[36m", "\x1B[39m"),
        white: init2("\x1B[37m", "\x1B[39m"),
        gray: init2("\x1B[90m", "\x1B[39m"),
        bgBlack: init2("\x1B[40m", "\x1B[49m"),
        bgRed: init2("\x1B[41m", "\x1B[49m"),
        bgGreen: init2("\x1B[42m", "\x1B[49m"),
        bgYellow: init2("\x1B[43m", "\x1B[49m"),
        bgBlue: init2("\x1B[44m", "\x1B[49m"),
        bgMagenta: init2("\x1B[45m", "\x1B[49m"),
        bgCyan: init2("\x1B[46m", "\x1B[49m"),
        bgWhite: init2("\x1B[47m", "\x1B[49m")
      };
    };
    picocolors.exports = createColors();
    picocolors.exports.createColors = createColors;
    picocolorsExports = picocolors.exports;
    colors$1 = /* @__PURE__ */ getDefaultExportFromCjs(picocolorsExports);
    VALID_ID_PREFIX = `/@id/`;
    SOURCEMAPPING_URL = "sourceMa";
    SOURCEMAPPING_URL += "ppingURL";
    isWindows$3 = typeof process !== "undefined" && process.platform === "win32";
    windowsSlashRE = /\\/g;
    postfixRE = /[?#].*$/;
    AsyncFunction = async function() {
    }.constructor;
    utils$k = {};
    path$m = require$$0$4;
    WIN_SLASH = "\\\\/";
    WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    DOT_LITERAL = "\\.";
    PLUS_LITERAL = "\\+";
    QMARK_LITERAL = "\\?";
    SLASH_LITERAL = "\\/";
    ONE_CHAR = "(?=.)";
    QMARK = "[^/]";
    END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    NO_DOT = `(?!${DOT_LITERAL})`;
    NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    STAR$1 = `${QMARK}*?`;
    POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR: STAR$1,
      START_ANCHOR
    };
    WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    POSIX_REGEX_SOURCE$1 = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    constants$6 = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path$m.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars2) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars2.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win322) {
        return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
    (function(exports4) {
      const path7 = require$$0$4;
      const win322 = process.platform === "win32";
      const {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = constants$6;
      exports4.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports4.hasRegexChars = (str2) => REGEX_SPECIAL_CHARS.test(str2);
      exports4.isRegexChar = (str2) => str2.length === 1 && exports4.hasRegexChars(str2);
      exports4.escapeRegex = (str2) => str2.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports4.toPosixSlashes = (str2) => str2.replace(REGEX_BACKSLASH, "/");
      exports4.removeBackslashes = (str2) => {
        return str2.replace(REGEX_REMOVE_BACKSLASH, (match2) => {
          return match2 === "\\" ? "" : match2;
        });
      };
      exports4.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports4.isWindows = (options2) => {
        if (options2 && typeof options2.windows === "boolean") {
          return options2.windows;
        }
        return win322 === true || path7.sep === "\\";
      };
      exports4.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1) return input;
        if (input[idx - 1] === "\\") return exports4.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports4.removePrefix = (input, state = {}) => {
        let output = input;
        if (output.startsWith("./")) {
          output = output.slice(2);
          state.prefix = "./";
        }
        return output;
      };
      exports4.wrapOutput = (input, state = {}, options2 = {}) => {
        const prepend = options2.contains ? "" : "^";
        const append2 = options2.contains ? "" : "$";
        let output = `${prepend}(?:${input})${append2}`;
        if (state.negated === true) {
          output = `(?:^(?!${output}).*$)`;
        }
        return output;
      };
    })(utils$k);
    utils$j = utils$k;
    ({
      CHAR_ASTERISK,
      CHAR_AT: (
        /* * */
        CHAR_AT
      ),
      CHAR_BACKWARD_SLASH: (
        /* @ */
        CHAR_BACKWARD_SLASH
      ),
      CHAR_COMMA: CHAR_COMMA$1,
      CHAR_DOT: CHAR_DOT$1,
      CHAR_EXCLAMATION_MARK: (
        /* . */
        CHAR_EXCLAMATION_MARK
      ),
      CHAR_FORWARD_SLASH: (
        /* ! */
        CHAR_FORWARD_SLASH
      ),
      CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1,
      CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1,
      CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1,
      CHAR_PLUS: (
        /* [ */
        CHAR_PLUS
      ),
      CHAR_QUESTION_MARK: (
        /* + */
        CHAR_QUESTION_MARK
      ),
      CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1,
      CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1,
      CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1
    } = constants$6);
    isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    scan$2 = (input, options2) => {
      const opts = options2 || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str2 = input;
      let index3 = -1;
      let start2 = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob3 = false;
      let isExtglob3 = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces2 = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index3 >= length;
      const peek = () => str2.charCodeAt(index3 + 1);
      const advance = () => {
        prev = code;
        return str2.charCodeAt(++index3);
      };
      while (index3 < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE$1) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE$1) {
          braces2++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE$1) {
              braces2++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT$1 && (code = advance()) === CHAR_DOT$1) {
              isBrace = token.isBrace = true;
              isGlob3 = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA$1) {
              isBrace = token.isBrace = true;
              isGlob3 = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE$1) {
              braces2--;
              if (braces2 === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index3);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT$1 && index3 === start2 + 1) {
            start2 += 2;
            continue;
          }
          lastIndex = index3 + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES$1) {
            isGlob3 = token.isGlob = true;
            isExtglob3 = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index3 === start2) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES$1) {
                  isGlob3 = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob3 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob3 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET$1) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {
              isBracket = token.isBracket = true;
              isGlob3 = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index3 === start2) {
          negated = token.negated = true;
          start2++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES$1) {
          isGlob3 = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES$1) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES$1) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob3 === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob3 = false;
        isGlob3 = false;
      }
      let base = str2;
      let prefix = "";
      let glob = "";
      if (start2 > 0) {
        prefix = str2.slice(0, start2);
        str2 = str2.slice(start2);
        lastIndex -= start2;
      }
      if (base && isGlob3 === true && lastIndex > 0) {
        base = str2.slice(0, lastIndex);
        glob = str2.slice(lastIndex);
      } else if (isGlob3 === true) {
        base = "";
        glob = str2;
      } else {
        base = str2;
      }
      if (base && base !== "" && base !== "/" && base !== str2) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob) glob = utils$j.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils$j.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start: start2,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob: isGlob3,
        isExtglob: isExtglob3,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n14 = prevIndex ? prevIndex + 1 : start2;
          const i14 = slashes[idx];
          const value2 = input.slice(n14, i14);
          if (opts.tokens) {
            if (idx === 0 && start2 !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value2;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value2 !== "") {
            parts.push(value2);
          }
          prevIndex = i14;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value2 = input.slice(prevIndex + 1);
          parts.push(value2);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value2;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    scan_1 = scan$2;
    constants$5 = constants$6;
    utils$i = utils$k;
    ({
      MAX_LENGTH: MAX_LENGTH$1,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants$5);
    expandRange = (args, options2) => {
      if (typeof options2.expandRange === "function") {
        return options2.expandRange(...args, options2);
      }
      args.sort();
      const value2 = `[${args.join("-")}]`;
      return value2;
    };
    syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    parse$g = (input, options2) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options2 };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win322 = utils$i.isWindows(options2);
      const PLATFORM_CHARS = constants$5.globChars(win322);
      const EXTGLOB_CHARS = constants$5.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        PLUS_LITERAL: PLUS_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOT_SLASH: NO_DOT_SLASH2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        QMARK: QMARK2,
        QMARK_NO_DOT: QMARK_NO_DOT2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT2;
      const qmarkNoDot = opts.dot ? QMARK2 : QMARK_NO_DOT2;
      let star3 = opts.bash === true ? globstar(opts) : STAR2;
      if (opts.capture) {
        star3 = `(${star3})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils$i.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces2 = [];
      const stack = [];
      let prev = bos;
      let value2;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n14 = 1) => input[state.index + n14];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value3 = "", num = 0) => {
        state.consumed += value3;
        state.index += num;
      };
      const append2 = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push2 = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob3 = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob3) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star3;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append2(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value3) => {
        const token = { ...EXTGLOB_CHARS[value3], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push2({ type, value: value3, output: state.output ? "" : ONE_CHAR2 });
        push2({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star3;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star3 || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse$g(rest, { ...options2, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push2({ type: "paren", extglob: true, value: value2, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m23, esc, chars2, first2, rest, index3) => {
          if (first2 === "\\") {
            backslashes = true;
            return m23;
          }
          if (first2 === "?") {
            if (esc) {
              return esc + first2 + (rest ? QMARK2.repeat(rest.length) : "");
            }
            if (index3 === 0) {
              return qmarkNoDot + (rest ? QMARK2.repeat(rest.length) : "");
            }
            return QMARK2.repeat(chars2.length);
          }
          if (first2 === ".") {
            return DOT_LITERAL2.repeat(chars2.length);
          }
          if (first2 === "*") {
            if (esc) {
              return esc + first2 + (rest ? star3 : "");
            }
            return star3;
          }
          return esc ? m23 : `\\${m23}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m23) => {
              return m23.length % 2 === 0 ? "\\\\" : m23 ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils$i.wrapOutput(output, state, options2);
        return state;
      }
      while (!eos()) {
        value2 = advance();
        if (value2 === "\0") {
          continue;
        }
        if (value2 === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value2 += "\\";
            push2({ type: "text", value: value2 });
            continue;
          }
          const match2 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match2 && match2[0].length > 2) {
            slashes = match2[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value2 += "\\";
            }
          }
          if (opts.unescape === true) {
            value2 = advance();
          } else {
            value2 += advance();
          }
          if (state.brackets === 0) {
            push2({ type: "text", value: value2 });
            continue;
          }
        }
        if (state.brackets > 0 && (value2 !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value2 === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix2 = POSIX_REGEX_SOURCE[rest2];
                if (posix2) {
                  prev.value = pre + posix2;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR2;
                  }
                  continue;
                }
              }
            }
          }
          if (value2 === "[" && peek() !== ":" || value2 === "-" && peek() === "]") {
            value2 = `\\${value2}`;
          }
          if (value2 === "]" && (prev.value === "[" || prev.value === "[^")) {
            value2 = `\\${value2}`;
          }
          if (opts.posix === true && value2 === "!" && prev.value === "[") {
            value2 = "^";
          }
          prev.value += value2;
          append2({ value: value2 });
          continue;
        }
        if (state.quotes === 1 && value2 !== '"') {
          value2 = utils$i.escapeRegex(value2);
          prev.value += value2;
          append2({ value: value2 });
          continue;
        }
        if (value2 === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push2({ type: "text", value: value2 });
          }
          continue;
        }
        if (value2 === "(") {
          increment("parens");
          push2({ type: "paren", value: value2 });
          continue;
        }
        if (value2 === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push2({ type: "paren", value: value2, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value2 === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value2 = `\\${value2}`;
          } else {
            increment("brackets");
          }
          push2({ type: "bracket", value: value2 });
          continue;
        }
        if (value2 === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push2({ type: "text", value: value2, output: `\\${value2}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push2({ type: "text", value: value2, output: `\\${value2}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value2 = `/${value2}`;
          }
          prev.value += value2;
          append2({ value: value2 });
          if (opts.literalBrackets === false || utils$i.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped2 = utils$i.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped2;
            prev.value = escaped2;
            continue;
          }
          prev.value = `(${capture}${escaped2}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value2 === "{" && opts.nobrace !== true) {
          increment("braces");
          const open2 = {
            type: "brace",
            value: value2,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces2.push(open2);
          push2(open2);
          continue;
        }
        if (value2 === "}") {
          const brace = braces2[braces2.length - 1];
          if (opts.nobrace === true || !brace) {
            push2({ type: "text", value: value2, output: value2 });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i14 = arr.length - 1; i14 >= 0; i14--) {
              tokens.pop();
              if (arr[i14].type === "brace") {
                break;
              }
              if (arr[i14].type !== "dots") {
                range.unshift(arr[i14].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value2 = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push2({ type: "brace", value: value2, output });
          decrement("braces");
          braces2.pop();
          continue;
        }
        if (value2 === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === ",") {
          let output = value2;
          const brace = braces2[braces2.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push2({ type: "comma", value: value2, output });
          continue;
        }
        if (value2 === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push2({ type: "slash", value: value2, output: SLASH_LITERAL2 });
          continue;
        }
        if (value2 === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL2;
            const brace = braces2[braces2.length - 1];
            prev.type = "dots";
            prev.output += value2;
            prev.value += value2;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push2({ type: "text", value: value2, output: DOT_LITERAL2 });
            continue;
          }
          push2({ type: "dot", value: value2, output: DOT_LITERAL2 });
          continue;
        }
        if (value2 === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value2);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value2;
            if (next === "<" && !utils$i.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value2}`;
            }
            push2({ type: "text", value: value2, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push2({ type: "qmark", value: value2, output: QMARK_NO_DOT2 });
            continue;
          }
          push2({ type: "qmark", value: value2, output: QMARK2 });
          continue;
        }
        if (value2 === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value2);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value2 === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value2);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push2({ type: "plus", value: value2, output: PLUS_LITERAL2 });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push2({ type: "plus", value: value2 });
            continue;
          }
          push2({ type: "plus", value: PLUS_LITERAL2 });
          continue;
        }
        if (value2 === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push2({ type: "at", extglob: true, value: value2, output: "" });
            continue;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 !== "*") {
          if (value2 === "$" || value2 === "^") {
            value2 = `\\${value2}`;
          }
          const match2 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match2) {
            value2 += match2[0];
            state.index += match2[0].length;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value2;
          prev.output = star3;
          state.backtrack = true;
          state.globstar = true;
          consume(value2);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value2);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value2);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push2({ type: "star", value: value2, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob3 = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob3) {
            push2({ type: "star", value: value2, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value2;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value2);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value2;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value2);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL2}|${SLASH_LITERAL2}${end})`;
            prev.value += value2;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value2 + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value2;
            prev.output = `(?:^|${SLASH_LITERAL2}|${globstar(opts)}${SLASH_LITERAL2})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value2 + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value2;
          state.output += prev.output;
          state.globstar = true;
          consume(value2);
          continue;
        }
        const token = { type: "star", value: value2, output: star3 };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push2(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value2;
          push2(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH2;
            prev.output += NO_DOT_SLASH2;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH2;
            prev.output += NO_DOTS_SLASH2;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR2;
            prev.output += ONE_CHAR2;
          }
        }
        push2(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils$i.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils$i.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils$i.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL2}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse$g.fastpaths = (input, options2) => {
      const opts = { ...options2 };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win322 = utils$i.isWindows(options2);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOTS: NO_DOTS2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = constants$5.globChars(win322);
      const nodot = opts.dot ? NO_DOTS2 : NO_DOT2;
      const slashDot = opts.dot ? NO_DOTS_SLASH2 : NO_DOT2;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star3 = opts.bash === true ? ".*?" : STAR2;
      if (opts.capture) {
        star3 = `(${star3})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star3;
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const create = (str2) => {
        switch (str2) {
          case "*":
            return `${nodot}${ONE_CHAR2}${star3}`;
          case ".*":
            return `${DOT_LITERAL2}${ONE_CHAR2}${star3}`;
          case "*.*":
            return `${nodot}${star3}${DOT_LITERAL2}${ONE_CHAR2}${star3}`;
          case "*/*":
            return `${nodot}${star3}${SLASH_LITERAL2}${ONE_CHAR2}${slashDot}${star3}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${ONE_CHAR2}${star3}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${star3}${DOT_LITERAL2}${ONE_CHAR2}${star3}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${DOT_LITERAL2}${ONE_CHAR2}${star3}`;
          default: {
            const match2 = /^(.*?)\.(\w+)$/.exec(str2);
            if (!match2) return;
            const source2 = create(match2[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL2 + match2[2];
          }
        }
      };
      const output = utils$i.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL2}?`;
      }
      return source;
    };
    parse_1$3 = parse$g;
    path$l = require$$0$4;
    scan$1 = scan_1;
    parse$f = parse_1$3;
    utils$h = utils$k;
    constants$4 = constants$6;
    isObject$3 = (val) => val && typeof val === "object" && !Array.isArray(val);
    picomatch$5 = (glob, options2, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch$5(input, options2, returnState));
        const arrayMatcher = (str2) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str2);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject$3(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options2 || {};
      const posix2 = utils$h.isWindows(options2);
      const regex2 = isState ? picomatch$5.compileRe(glob, options2) : picomatch$5.makeRe(glob, options2, false, true);
      const state = regex2.state;
      delete regex2.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options2, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch$5(opts.ignore, ignoreOpts, returnState);
      }
      const matcher2 = (input, returnObject = false) => {
        const { isMatch, match: match2, output } = picomatch$5.test(input, regex2, options2, { glob, posix: posix2 });
        const result = { glob, state, regex: regex2, posix: posix2, input, output, match: match2, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher2.state = state;
      }
      return matcher2;
    };
    picomatch$5.test = (input, regex2, options2, { glob, posix: posix2 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options2 || {};
      const format2 = opts.format || (posix2 ? utils$h.toPosixSlashes : null);
      let match2 = input === glob;
      let output = match2 && format2 ? format2(input) : input;
      if (match2 === false) {
        output = format2 ? format2(input) : input;
        match2 = output === glob;
      }
      if (match2 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match2 = picomatch$5.matchBase(input, regex2, options2, posix2);
        } else {
          match2 = regex2.exec(output);
        }
      }
      return { isMatch: Boolean(match2), match: match2, output };
    };
    picomatch$5.matchBase = (input, glob, options2, posix2 = utils$h.isWindows(options2)) => {
      const regex2 = glob instanceof RegExp ? glob : picomatch$5.makeRe(glob, options2);
      return regex2.test(path$l.basename(input));
    };
    picomatch$5.isMatch = (str2, patterns, options2) => picomatch$5(patterns, options2)(str2);
    picomatch$5.parse = (pattern2, options2) => {
      if (Array.isArray(pattern2)) return pattern2.map((p20) => picomatch$5.parse(p20, options2));
      return parse$f(pattern2, { ...options2, fastpaths: false });
    };
    picomatch$5.scan = (input, options2) => scan$1(input, options2);
    picomatch$5.compileRe = (state, options2, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options2 || {};
      const prepend = opts.contains ? "" : "^";
      const append2 = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append2}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex2 = picomatch$5.toRegex(source, options2);
      if (returnState === true) {
        regex2.state = state;
      }
      return regex2;
    };
    picomatch$5.makeRe = (input, options2 = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options2.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse$f.fastpaths(input, options2);
      }
      if (!parsed.output) {
        parsed = parse$f(input, options2);
      }
      return picomatch$5.compileRe(parsed, options2, returnOutput, returnState);
    };
    picomatch$5.toRegex = (source, options2) => {
      try {
        const opts = options2 || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options2 && options2.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch$5.constants = constants$4;
    picomatch_1 = picomatch$5;
    picomatch$3 = picomatch_1;
    reservedWords = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
    builtins = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
    forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(" "));
    forbiddenIdentifiers.add("");
    hasStringIsWellFormed = "isWellFormed" in String.prototype;
    balancedMatch = balanced$1;
    balanced$1.range = range$1;
    balanced = balancedMatch;
    braceExpansion = expandTop;
    escSlash = "\0SLASH" + Math.random() + "\0";
    escOpen = "\0OPEN" + Math.random() + "\0";
    escClose = "\0CLOSE" + Math.random() + "\0";
    escComma = "\0COMMA" + Math.random() + "\0";
    escPeriod = "\0PERIOD" + Math.random() + "\0";
    expand$4 = /* @__PURE__ */ getDefaultExportFromCjs(braceExpansion);
    MAX_PATTERN_LENGTH = 1024 * 64;
    assertValidPattern = (pattern2) => {
      if (typeof pattern2 !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern2.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    posixClasses = {
      "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
      "[:alpha:]": ["\\p{L}\\p{Nl}", true],
      "[:ascii:]": ["\\x00-\\x7f", false],
      "[:blank:]": ["\\p{Zs}\\t", true],
      "[:cntrl:]": ["\\p{Cc}", true],
      "[:digit:]": ["\\p{Nd}", true],
      "[:graph:]": ["\\p{Z}\\p{C}", true, true],
      "[:lower:]": ["\\p{Ll}", true],
      "[:print:]": ["\\p{C}", true],
      "[:punct:]": ["\\p{P}", true],
      "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
      "[:upper:]": ["\\p{Lu}", true],
      "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
      "[:xdigit:]": ["A-Fa-f0-9", false]
    };
    braceEscape = (s12) => s12.replace(/[[\]\\-]/g, "\\$&");
    regexpEscape = (s12) => s12.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    rangesToString = (ranges) => ranges.join("");
    parseClass = (glob, position) => {
      const pos = position;
      if (glob.charAt(pos) !== "[") {
        throw new Error("not in a brace expression");
      }
      const ranges = [];
      const negs = [];
      let i14 = pos + 1;
      let sawStart = false;
      let uflag = false;
      let escaping = false;
      let negate = false;
      let endPos = pos;
      let rangeStart = "";
      WHILE: while (i14 < glob.length) {
        const c16 = glob.charAt(i14);
        if ((c16 === "!" || c16 === "^") && i14 === pos + 1) {
          negate = true;
          i14++;
          continue;
        }
        if (c16 === "]" && sawStart && !escaping) {
          endPos = i14 + 1;
          break;
        }
        sawStart = true;
        if (c16 === "\\") {
          if (!escaping) {
            escaping = true;
            i14++;
            continue;
          }
        }
        if (c16 === "[" && !escaping) {
          for (const [cls, [unip, u17, neg]] of Object.entries(posixClasses)) {
            if (glob.startsWith(cls, i14)) {
              if (rangeStart) {
                return ["$.", false, glob.length - pos, true];
              }
              i14 += cls.length;
              if (neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u17;
              continue WHILE;
            }
          }
        }
        escaping = false;
        if (rangeStart) {
          if (c16 > rangeStart) {
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c16));
          } else if (c16 === rangeStart) {
            ranges.push(braceEscape(c16));
          }
          rangeStart = "";
          i14++;
          continue;
        }
        if (glob.startsWith("-]", i14 + 1)) {
          ranges.push(braceEscape(c16 + "-"));
          i14 += 2;
          continue;
        }
        if (glob.startsWith("-", i14 + 1)) {
          rangeStart = c16;
          i14 += 2;
          continue;
        }
        ranges.push(braceEscape(c16));
        i14++;
      }
      if (endPos < i14) {
        return ["", false, 0, false];
      }
      if (!ranges.length && !negs.length) {
        return ["$.", false, glob.length - pos, true];
      }
      if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
        const r9 = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r9), false, endPos - pos, false];
      }
      const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
      const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
      const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
      return [comb, uflag, endPos - pos, true];
    };
    unescape$1 = (s12, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s12.replace(/\[([^\/\\])\]/g, "$1") : s12.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
    };
    types$1 = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
    isExtglobType = (c16) => types$1.has(c16);
    startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
    startNoDot = "(?!\\.)";
    addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
    justDots = /* @__PURE__ */ new Set(["..", "."]);
    reSpecials = new Set("().*{}+?[]^$\\!");
    regExpEscape$1 = (s12) => s12.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    qmark$1 = "[^/]";
    star$1 = qmark$1 + "*?";
    starNoEmpty = qmark$1 + "+?";
    AST = class _AST {
      type;
      #root;
      #hasMagic;
      #uflag = false;
      #parts = [];
      #parent;
      #parentIndex;
      #negs;
      #filledNegs = false;
      #options;
      #toString;
      // set to true if it's an extglob with no children
      // (which really means one child of '')
      #emptyExt = false;
      constructor(type, parent, options2 = {}) {
        this.type = type;
        if (type)
          this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options2 : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === "!" && !this.#root.#filledNegs)
          this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
      }
      get hasMagic() {
        if (this.#hasMagic !== void 0)
          return this.#hasMagic;
        for (const p20 of this.#parts) {
          if (typeof p20 === "string")
            continue;
          if (p20.type || p20.hasMagic)
            return this.#hasMagic = true;
        }
        return this.#hasMagic;
      }
      // reconstructs the pattern
      toString() {
        if (this.#toString !== void 0)
          return this.#toString;
        if (!this.type) {
          return this.#toString = this.#parts.map((p20) => String(p20)).join("");
        } else {
          return this.#toString = this.type + "(" + this.#parts.map((p20) => String(p20)).join("|") + ")";
        }
      }
      #fillNegs() {
        if (this !== this.#root)
          throw new Error("should only call on root");
        if (this.#filledNegs)
          return this;
        this.toString();
        this.#filledNegs = true;
        let n14;
        while (n14 = this.#negs.pop()) {
          if (n14.type !== "!")
            continue;
          let p20 = n14;
          let pp = p20.#parent;
          while (pp) {
            for (let i14 = p20.#parentIndex + 1; !pp.type && i14 < pp.#parts.length; i14++) {
              for (const part of n14.#parts) {
                if (typeof part === "string") {
                  throw new Error("string part in extglob AST??");
                }
                part.copyIn(pp.#parts[i14]);
              }
            }
            p20 = pp;
            pp = p20.#parent;
          }
        }
        return this;
      }
      push(...parts) {
        for (const p20 of parts) {
          if (p20 === "")
            continue;
          if (typeof p20 !== "string" && !(p20 instanceof _AST && p20.#parent === this)) {
            throw new Error("invalid part: " + p20);
          }
          this.#parts.push(p20);
        }
      }
      toJSON() {
        const ret = this.type === null ? this.#parts.slice().map((p20) => typeof p20 === "string" ? p20 : p20.toJSON()) : [this.type, ...this.#parts.map((p20) => p20.toJSON())];
        if (this.isStart() && !this.type)
          ret.unshift([]);
        if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
          ret.push({});
        }
        return ret;
      }
      isStart() {
        if (this.#root === this)
          return true;
        if (!this.#parent?.isStart())
          return false;
        if (this.#parentIndex === 0)
          return true;
        const p20 = this.#parent;
        for (let i14 = 0; i14 < this.#parentIndex; i14++) {
          const pp = p20.#parts[i14];
          if (!(pp instanceof _AST && pp.type === "!")) {
            return false;
          }
        }
        return true;
      }
      isEnd() {
        if (this.#root === this)
          return true;
        if (this.#parent?.type === "!")
          return true;
        if (!this.#parent?.isEnd())
          return false;
        if (!this.type)
          return this.#parent?.isEnd();
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        return this.#parentIndex === pl - 1;
      }
      copyIn(part) {
        if (typeof part === "string")
          this.push(part);
        else
          this.push(part.clone(this));
      }
      clone(parent) {
        const c16 = new _AST(this.type, parent);
        for (const p20 of this.#parts) {
          c16.copyIn(p20);
        }
        return c16;
      }
      static #parseAST(str2, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
          let i15 = pos;
          let acc2 = "";
          while (i15 < str2.length) {
            const c16 = str2.charAt(i15++);
            if (escaping || c16 === "\\") {
              escaping = !escaping;
              acc2 += c16;
              continue;
            }
            if (inBrace) {
              if (i15 === braceStart + 1) {
                if (c16 === "^" || c16 === "!") {
                  braceNeg = true;
                }
              } else if (c16 === "]" && !(i15 === braceStart + 2 && braceNeg)) {
                inBrace = false;
              }
              acc2 += c16;
              continue;
            } else if (c16 === "[") {
              inBrace = true;
              braceStart = i15;
              braceNeg = false;
              acc2 += c16;
              continue;
            }
            if (!opt.noext && isExtglobType(c16) && str2.charAt(i15) === "(") {
              ast.push(acc2);
              acc2 = "";
              const ext2 = new _AST(c16, ast);
              i15 = _AST.#parseAST(str2, ext2, i15, opt);
              ast.push(ext2);
              continue;
            }
            acc2 += c16;
          }
          ast.push(acc2);
          return i15;
        }
        let i14 = pos + 1;
        let part = new _AST(null, ast);
        const parts = [];
        let acc = "";
        while (i14 < str2.length) {
          const c16 = str2.charAt(i14++);
          if (escaping || c16 === "\\") {
            escaping = !escaping;
            acc += c16;
            continue;
          }
          if (inBrace) {
            if (i14 === braceStart + 1) {
              if (c16 === "^" || c16 === "!") {
                braceNeg = true;
              }
            } else if (c16 === "]" && !(i14 === braceStart + 2 && braceNeg)) {
              inBrace = false;
            }
            acc += c16;
            continue;
          } else if (c16 === "[") {
            inBrace = true;
            braceStart = i14;
            braceNeg = false;
            acc += c16;
            continue;
          }
          if (isExtglobType(c16) && str2.charAt(i14) === "(") {
            part.push(acc);
            acc = "";
            const ext2 = new _AST(c16, part);
            part.push(ext2);
            i14 = _AST.#parseAST(str2, ext2, i14, opt);
            continue;
          }
          if (c16 === "|") {
            part.push(acc);
            acc = "";
            parts.push(part);
            part = new _AST(null, ast);
            continue;
          }
          if (c16 === ")") {
            if (acc === "" && ast.#parts.length === 0) {
              ast.#emptyExt = true;
            }
            part.push(acc);
            acc = "";
            ast.push(...parts, part);
            return i14;
          }
          acc += c16;
        }
        ast.type = null;
        ast.#hasMagic = void 0;
        ast.#parts = [str2.substring(pos - 1)];
        return i14;
      }
      static fromGlob(pattern2, options2 = {}) {
        const ast = new _AST(null, void 0, options2);
        _AST.#parseAST(pattern2, ast, 0, options2);
        return ast;
      }
      // returns the regular expression if there's magic, or the unescaped
      // string if not.
      toMMPattern() {
        if (this !== this.#root)
          return this.#root.toMMPattern();
        const glob = this.toString();
        const [re3, body, hasMagic2, uflag] = this.toRegExpSource();
        const anyMagic = hasMagic2 || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
        if (!anyMagic) {
          return body;
        }
        const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
        return Object.assign(new RegExp(`^${re3}$`, flags), {
          _src: re3,
          _glob: glob
        });
      }
      get options() {
        return this.#options;
      }
      // returns the string match, the regexp source, whether there's magic
      // in the regexp (so a regular expression is required) and whether or
      // not the uflag is needed for the regular expression (for posix classes)
      // TODO: instead of injecting the start/end at this point, just return
      // the BODY of the regexp, along with the start/end portions suitable
      // for binding the start/end in either a joined full-path makeRe context
      // (where we bind to (^|/), or a standalone matchPart context (where
      // we bind to ^, and not /).  Otherwise slashes get duped!
      //
      // In part-matching mode, the start is:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: ^(?!\.\.?$)
      // - if dots allowed or not possible: ^
      // - if dots possible and not allowed: ^(?!\.)
      // end is:
      // - if not isEnd(): nothing
      // - else: $
      //
      // In full-path matching mode, we put the slash at the START of the
      // pattern, so start is:
      // - if first pattern: same as part-matching mode
      // - if not isStart(): nothing
      // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
      // - if dots allowed or not possible: /
      // - if dots possible and not allowed: /(?!\.)
      // end is:
      // - if last pattern, same as part-matching mode
      // - else nothing
      //
      // Always put the (?:$|/) on negated tails, though, because that has to be
      // there to bind the end of the negated pattern portion, and it's easier to
      // just stick it in now rather than try to inject it later in the middle of
      // the pattern.
      //
      // We can just always return the same end, and leave it up to the caller
      // to know whether it's going to be used joined or in parts.
      // And, if the start is adjusted slightly, can do the same there:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
      // - if dots allowed or not possible: (?:/|^)
      // - if dots possible and not allowed: (?:/|^)(?!\.)
      //
      // But it's better to have a simpler binding without a conditional, for
      // performance, so probably better to return both start options.
      //
      // Then the caller just ignores the end if it's not the first pattern,
      // and the start always gets applied.
      //
      // But that's always going to be $ if it's the ending pattern, or nothing,
      // so the caller can just attach $ at the end of the pattern when building.
      //
      // So the todo is:
      // - better detect what kind of start is needed
      // - return both flavors of starting pattern
      // - attach $ at the end of the pattern when creating the actual RegExp
      //
      // Ah, but wait, no, that all only applies to the root when the first pattern
      // is not an extglob. If the first pattern IS an extglob, then we need all
      // that dot prevention biz to live in the extglob portions, because eg
      // +(*|.x*) can match .xy but not .yx.
      //
      // So, return the two flavors if it's #root and the first child is not an
      // AST, otherwise leave it to the child AST to handle it, and there,
      // use the (?:^|/) style of start binding.
      //
      // Even simplified further:
      // - Since the start for a join is eg /(?!\.) and the start for a part
      // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
      // or start or whatever) and prepend ^ or / at the Regexp construction.
      toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
          this.#fillNegs();
        if (!this.type) {
          const noEmpty = this.isStart() && this.isEnd();
          const src3 = this.#parts.map((p20) => {
            const [re3, _22, hasMagic2, uflag] = typeof p20 === "string" ? _AST.#parseGlob(p20, this.#hasMagic, noEmpty) : p20.toRegExpSource(allowDot);
            this.#hasMagic = this.#hasMagic || hasMagic2;
            this.#uflag = this.#uflag || uflag;
            return re3;
          }).join("");
          let start3 = "";
          if (this.isStart()) {
            if (typeof this.#parts[0] === "string") {
              const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
              if (!dotTravAllowed) {
                const aps = addPatternStart;
                const needNoTrav = (
                  // dots are allowed, and the pattern starts with [ or .
                  dot && aps.has(src3.charAt(0)) || // the pattern starts with \., and then [ or .
                  src3.startsWith("\\.") && aps.has(src3.charAt(2)) || // the pattern starts with \.\., and then [ or .
                  src3.startsWith("\\.\\.") && aps.has(src3.charAt(4))
                );
                const needNoDot = !dot && !allowDot && aps.has(src3.charAt(0));
                start3 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
              }
            }
          }
          let end = "";
          if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
            end = "(?:$|\\/)";
          }
          const final2 = start3 + src3 + end;
          return [
            final2,
            unescape$1(src3),
            this.#hasMagic = !!this.#hasMagic,
            this.#uflag
          ];
        }
        const repeated = this.type === "*" || this.type === "+";
        const start2 = this.type === "!" ? "(?:(?!(?:" : "(?:";
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
          const s12 = this.toString();
          this.#parts = [s12];
          this.type = null;
          this.#hasMagic = void 0;
          return [s12, unescape$1(this.toString()), false, false];
        }
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
          bodyDotAllowed = "";
        }
        if (bodyDotAllowed) {
          body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        let final = "";
        if (this.type === "!" && this.#emptyExt) {
          final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
        } else {
          const close2 = this.type === "!" ? (
            // !() must match something,but !(x) can match ''
            "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star$1 + ")"
          ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
          final = start2 + body + close2;
        }
        return [
          final,
          unescape$1(body),
          this.#hasMagic = !!this.#hasMagic,
          this.#uflag
        ];
      }
      #partsToRegExp(dot) {
        return this.#parts.map((p20) => {
          if (typeof p20 === "string") {
            throw new Error("string type in extglob ast??");
          }
          const [re3, _22, _hasMagic, uflag] = p20.toRegExpSource(dot);
          this.#uflag = this.#uflag || uflag;
          return re3;
        }).filter((p20) => !(this.isStart() && this.isEnd()) || !!p20).join("|");
      }
      static #parseGlob(glob, hasMagic2, noEmpty = false) {
        let escaping = false;
        let re3 = "";
        let uflag = false;
        for (let i14 = 0; i14 < glob.length; i14++) {
          const c16 = glob.charAt(i14);
          if (escaping) {
            escaping = false;
            re3 += (reSpecials.has(c16) ? "\\" : "") + c16;
            continue;
          }
          if (c16 === "\\") {
            if (i14 === glob.length - 1) {
              re3 += "\\\\";
            } else {
              escaping = true;
            }
            continue;
          }
          if (c16 === "[") {
            const [src3, needUflag, consumed, magic] = parseClass(glob, i14);
            if (consumed) {
              re3 += src3;
              uflag = uflag || needUflag;
              i14 += consumed - 1;
              hasMagic2 = hasMagic2 || magic;
              continue;
            }
          }
          if (c16 === "*") {
            if (noEmpty && glob === "*")
              re3 += starNoEmpty;
            else
              re3 += star$1;
            hasMagic2 = true;
            continue;
          }
          if (c16 === "?") {
            re3 += qmark$1;
            hasMagic2 = true;
            continue;
          }
          re3 += regExpEscape$1(c16);
        }
        return [re3, unescape$1(glob), !!hasMagic2, uflag];
      }
    };
    escape$2 = (s12, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s12.replace(/[?*()[\]]/g, "[$&]") : s12.replace(/[?*()[\]\\]/g, "\\$&");
    };
    minimatch = (p20, pattern2, options2 = {}) => {
      assertValidPattern(pattern2);
      if (!options2.nocomment && pattern2.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern2, options2).match(p20);
    };
    starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
    starDotExtTest = (ext2) => (f15) => !f15.startsWith(".") && f15.endsWith(ext2);
    starDotExtTestDot = (ext2) => (f15) => f15.endsWith(ext2);
    starDotExtTestNocase = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f15) => !f15.startsWith(".") && f15.toLowerCase().endsWith(ext2);
    };
    starDotExtTestNocaseDot = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f15) => f15.toLowerCase().endsWith(ext2);
    };
    starDotStarRE = /^\*+\.\*+$/;
    starDotStarTest = (f15) => !f15.startsWith(".") && f15.includes(".");
    starDotStarTestDot = (f15) => f15 !== "." && f15 !== ".." && f15.includes(".");
    dotStarRE = /^\.\*+$/;
    dotStarTest = (f15) => f15 !== "." && f15 !== ".." && f15.startsWith(".");
    starRE = /^\*+$/;
    starTest = (f15) => f15.length !== 0 && !f15.startsWith(".");
    starTestDot = (f15) => f15.length !== 0 && f15 !== "." && f15 !== "..";
    qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
    qmarksTestNocase = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f15) => noext(f15) && f15.toLowerCase().endsWith(ext2);
    };
    qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f15) => noext(f15) && f15.toLowerCase().endsWith(ext2);
    };
    qmarksTestDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      return !ext2 ? noext : (f15) => noext(f15) && f15.endsWith(ext2);
    };
    qmarksTest = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      return !ext2 ? noext : (f15) => noext(f15) && f15.endsWith(ext2);
    };
    qmarksTestNoExt = ([$0]) => {
      const len = $0.length;
      return (f15) => f15.length === len && !f15.startsWith(".");
    };
    qmarksTestNoExtDot = ([$0]) => {
      const len = $0.length;
      return (f15) => f15.length === len && f15 !== "." && f15 !== "..";
    };
    defaultPlatform$2 = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
    path$j = {
      win32: { sep: "\\" },
      posix: { sep: "/" }
    };
    sep = defaultPlatform$2 === "win32" ? path$j.win32.sep : path$j.posix.sep;
    minimatch.sep = sep;
    GLOBSTAR$2 = Symbol("globstar **");
    minimatch.GLOBSTAR = GLOBSTAR$2;
    qmark = "[^/]";
    star2 = qmark + "*?";
    twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    filter$1 = (pattern2, options2 = {}) => (p20) => minimatch(p20, pattern2, options2);
    minimatch.filter = filter$1;
    ext = (a20, b18 = {}) => Object.assign({}, a20, b18);
    defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      const orig = minimatch;
      const m23 = (p20, pattern2, options2 = {}) => orig(p20, pattern2, ext(def, options2));
      return Object.assign(m23, {
        Minimatch: class Minimatch extends orig.Minimatch {
          constructor(pattern2, options2 = {}) {
            super(pattern2, ext(def, options2));
          }
          static defaults(options2) {
            return orig.defaults(ext(def, options2)).Minimatch;
          }
        },
        AST: class AST extends orig.AST {
          /* c8 ignore start */
          constructor(type, parent, options2 = {}) {
            super(type, parent, ext(def, options2));
          }
          /* c8 ignore stop */
          static fromGlob(pattern2, options2 = {}) {
            return orig.AST.fromGlob(pattern2, ext(def, options2));
          }
        },
        unescape: (s12, options2 = {}) => orig.unescape(s12, ext(def, options2)),
        escape: (s12, options2 = {}) => orig.escape(s12, ext(def, options2)),
        filter: (pattern2, options2 = {}) => orig.filter(pattern2, ext(def, options2)),
        defaults: (options2) => orig.defaults(ext(def, options2)),
        makeRe: (pattern2, options2 = {}) => orig.makeRe(pattern2, ext(def, options2)),
        braceExpand: (pattern2, options2 = {}) => orig.braceExpand(pattern2, ext(def, options2)),
        match: (list, pattern2, options2 = {}) => orig.match(list, pattern2, ext(def, options2)),
        sep: orig.sep,
        GLOBSTAR: GLOBSTAR$2
      });
    };
    minimatch.defaults = defaults;
    braceExpand = (pattern2, options2 = {}) => {
      assertValidPattern(pattern2);
      if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern2)) {
        return [pattern2];
      }
      return expand$4(pattern2);
    };
    minimatch.braceExpand = braceExpand;
    makeRe$1 = (pattern2, options2 = {}) => new Minimatch(pattern2, options2).makeRe();
    minimatch.makeRe = makeRe$1;
    match = (list, pattern2, options2 = {}) => {
      const mm = new Minimatch(pattern2, options2);
      list = list.filter((f15) => mm.match(f15));
      if (mm.options.nonull && !list.length) {
        list.push(pattern2);
      }
      return list;
    };
    minimatch.match = match;
    globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
    regExpEscape = (s12) => s12.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    Minimatch = class {
      options;
      set;
      pattern;
      windowsPathsNoEscape;
      nonegate;
      negate;
      comment;
      empty;
      preserveMultipleSlashes;
      partial;
      globSet;
      globParts;
      nocase;
      isWindows;
      platform;
      windowsNoMagicRoot;
      regexp;
      constructor(pattern2, options2 = {}) {
        assertValidPattern(pattern2);
        options2 = options2 || {};
        this.options = options2;
        this.pattern = pattern2;
        this.platform = options2.platform || defaultPlatform$2;
        this.isWindows = this.platform === "win32";
        this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.preserveMultipleSlashes = !!options2.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options2.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options2.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot = options2.windowsNoMagicRoot !== void 0 ? options2.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        this.make();
      }
      hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
          return true;
        }
        for (const pattern2 of this.set) {
          for (const part of pattern2) {
            if (typeof part !== "string")
              return true;
          }
        }
        return false;
      }
      debug(..._22) {
      }
      make() {
        const pattern2 = this.pattern;
        const options2 = this.options;
        if (!options2.nocomment && pattern2.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern2) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        this.globSet = [...new Set(this.braceExpand())];
        if (options2.debug) {
          this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        const rawGlobParts = this.globSet.map((s12) => this.slashSplit(s12));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        let set2 = this.globParts.map((s12, _22, __) => {
          if (this.isWindows && this.windowsNoMagicRoot) {
            const isUNC = s12[0] === "" && s12[1] === "" && (s12[2] === "?" || !globMagic.test(s12[2])) && !globMagic.test(s12[3]);
            const isDrive = /^[a-z]:/i.test(s12[0]);
            if (isUNC) {
              return [...s12.slice(0, 4), ...s12.slice(4).map((ss) => this.parse(ss))];
            } else if (isDrive) {
              return [s12[0], ...s12.slice(1).map((ss) => this.parse(ss))];
            }
          }
          return s12.map((ss) => this.parse(ss));
        });
        this.debug(this.pattern, set2);
        this.set = set2.filter((s12) => s12.indexOf(false) === -1);
        if (this.isWindows) {
          for (let i14 = 0; i14 < this.set.length; i14++) {
            const p20 = this.set[i14];
            if (p20[0] === "" && p20[1] === "" && this.globParts[i14][2] === "?" && typeof p20[3] === "string" && /^[a-z]:$/i.test(p20[3])) {
              p20[2] = "?";
            }
          }
        }
        this.debug(this.pattern, this.set);
      }
      // various transforms to equivalent pattern sets that are
      // faster to process in a filesystem walk.  The goal is to
      // eliminate what we can, and push all ** patterns as far
      // to the right as possible, even if it increases the number
      // of patterns that we have to process.
      preprocess(globParts) {
        if (this.options.noglobstar) {
          for (let i14 = 0; i14 < globParts.length; i14++) {
            for (let j16 = 0; j16 < globParts[i14].length; j16++) {
              if (globParts[i14][j16] === "**") {
                globParts[i14][j16] = "*";
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          globParts = this.firstPhasePreProcess(globParts);
          globParts = this.secondPhasePreProcess(globParts);
        } else if (optimizationLevel >= 1) {
          globParts = this.levelOneOptimize(globParts);
        } else {
          globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
      }
      // just get rid of adjascent ** portions
      adjascentGlobstarOptimize(globParts) {
        return globParts.map((parts) => {
          let gs = -1;
          while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
            let i14 = gs;
            while (parts[i14 + 1] === "**") {
              i14++;
            }
            if (i14 !== gs) {
              parts.splice(gs, i14 - gs);
            }
          }
          return parts;
        });
      }
      // get rid of adjascent ** and resolve .. portions
      levelOneOptimize(globParts) {
        return globParts.map((parts) => {
          parts = parts.reduce((set2, part) => {
            const prev = set2[set2.length - 1];
            if (part === "**" && prev === "**") {
              return set2;
            }
            if (part === "..") {
              if (prev && prev !== ".." && prev !== "." && prev !== "**") {
                set2.pop();
                return set2;
              }
            }
            set2.push(part);
            return set2;
          }, []);
          return parts.length === 0 ? [""] : parts;
        });
      }
      levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
          parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
          didSomething = false;
          if (!this.preserveMultipleSlashes) {
            for (let i14 = 1; i14 < parts.length - 1; i14++) {
              const p20 = parts[i14];
              if (i14 === 1 && p20 === "" && parts[0] === "")
                continue;
              if (p20 === "." || p20 === "") {
                didSomething = true;
                parts.splice(i14, 1);
                i14--;
              }
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
              didSomething = true;
              parts.pop();
            }
          }
          let dd = 0;
          while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
            const p20 = parts[dd - 1];
            if (p20 && p20 !== "." && p20 !== ".." && p20 !== "**") {
              didSomething = true;
              parts.splice(dd - 1, 2);
              dd -= 2;
            }
          }
        } while (didSomething);
        return parts.length === 0 ? [""] : parts;
      }
      // First phase: single-pattern processing
      // <pre> is 1 or more portions
      // <rest> is 1 or more portions
      // <p> is any portion other than ., .., '', or **
      // <e> is . or ''
      //
      // **/.. is *brutal* for filesystem walking performance, because
      // it effectively resets the recursive walk each time it occurs,
      // and ** cannot be reduced out by a .. pattern part like a regexp
      // or most strings (other than .., ., and '') can be.
      //
      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
      // <pre>/<e>/<rest> -> <pre>/<rest>
      // <pre>/<p>/../<rest> -> <pre>/<rest>
      // **/**/<rest> -> **/<rest>
      //
      // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
      // this WOULD be allowed if ** did follow symlinks, or * didn't
      firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
          didSomething = false;
          for (let parts of globParts) {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
              let gss = gs;
              while (parts[gss + 1] === "**") {
                gss++;
              }
              if (gss > gs) {
                parts.splice(gs + 1, gss - gs);
              }
              let next = parts[gs + 1];
              const p20 = parts[gs + 2];
              const p22 = parts[gs + 3];
              if (next !== "..")
                continue;
              if (!p20 || p20 === "." || p20 === ".." || !p22 || p22 === "." || p22 === "..") {
                continue;
              }
              didSomething = true;
              parts.splice(gs, 1);
              const other = parts.slice(0);
              other[gs] = "**";
              globParts.push(other);
              gs--;
            }
            if (!this.preserveMultipleSlashes) {
              for (let i14 = 1; i14 < parts.length - 1; i14++) {
                const p20 = parts[i14];
                if (i14 === 1 && p20 === "" && parts[0] === "")
                  continue;
                if (p20 === "." || p20 === "") {
                  didSomething = true;
                  parts.splice(i14, 1);
                  i14--;
                }
              }
              if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
                didSomething = true;
                parts.pop();
              }
            }
            let dd = 0;
            while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
              const p20 = parts[dd - 1];
              if (p20 && p20 !== "." && p20 !== ".." && p20 !== "**") {
                didSomething = true;
                const needDot = dd === 1 && parts[dd + 1] === "**";
                const splin = needDot ? ["."] : [];
                parts.splice(dd - 1, 2, ...splin);
                if (parts.length === 0)
                  parts.push("");
                dd -= 2;
              }
            }
          }
        } while (didSomething);
        return globParts;
      }
      // second phase: multi-pattern dedupes
      // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
      // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
      // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
      //
      // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
      // ^-- not valid because ** doens't follow symlinks
      secondPhasePreProcess(globParts) {
        for (let i14 = 0; i14 < globParts.length - 1; i14++) {
          for (let j16 = i14 + 1; j16 < globParts.length; j16++) {
            const matched = this.partsMatch(globParts[i14], globParts[j16], !this.preserveMultipleSlashes);
            if (matched) {
              globParts[i14] = [];
              globParts[j16] = matched;
              break;
            }
          }
        }
        return globParts.filter((gs) => gs.length);
      }
      partsMatch(a20, b18, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which2 = "";
        while (ai < a20.length && bi < b18.length) {
          if (a20[ai] === b18[bi]) {
            result.push(which2 === "b" ? b18[bi] : a20[ai]);
            ai++;
            bi++;
          } else if (emptyGSMatch && a20[ai] === "**" && b18[bi] === a20[ai + 1]) {
            result.push(a20[ai]);
            ai++;
          } else if (emptyGSMatch && b18[bi] === "**" && a20[ai] === b18[bi + 1]) {
            result.push(b18[bi]);
            bi++;
          } else if (a20[ai] === "*" && b18[bi] && (this.options.dot || !b18[bi].startsWith(".")) && b18[bi] !== "**") {
            if (which2 === "b")
              return false;
            which2 = "a";
            result.push(a20[ai]);
            ai++;
            bi++;
          } else if (b18[bi] === "*" && a20[ai] && (this.options.dot || !a20[ai].startsWith(".")) && a20[ai] !== "**") {
            if (which2 === "a")
              return false;
            which2 = "b";
            result.push(b18[bi]);
            ai++;
            bi++;
          } else {
            return false;
          }
        }
        return a20.length === b18.length && result;
      }
      parseNegate() {
        if (this.nonegate)
          return;
        const pattern2 = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i14 = 0; i14 < pattern2.length && pattern2.charAt(i14) === "!"; i14++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern2.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern2, partial2 = false) {
        const options2 = this.options;
        if (this.isWindows) {
          const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
          const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
          const patternDrive = typeof pattern2[0] === "string" && /^[a-z]:$/i.test(pattern2[0]);
          const patternUNC = !patternDrive && pattern2[0] === "" && pattern2[1] === "" && pattern2[2] === "?" && typeof pattern2[3] === "string" && /^[a-z]:$/i.test(pattern2[3]);
          const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
          const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
          if (typeof fdi === "number" && typeof pdi === "number") {
            const [fd, pd] = [file[fdi], pattern2[pdi]];
            if (fd.toLowerCase() === pd.toLowerCase()) {
              pattern2[pdi] = fd;
              if (pdi > fdi) {
                pattern2 = pattern2.slice(pdi);
              } else if (fdi > pdi) {
                file = file.slice(fdi);
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          file = this.levelTwoFileOptimize(file);
        }
        this.debug("matchOne", this, { file, pattern: pattern2 });
        this.debug("matchOne", file.length, pattern2.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern2.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p20 = pattern2[pi];
          var f15 = file[fi];
          this.debug(pattern2, p20, f15);
          if (p20 === false) {
            return false;
          }
          if (p20 === GLOBSTAR$2) {
            this.debug("GLOBSTAR", [pattern2, p20, f15]);
            var fr = fi;
            var pr2 = pi + 1;
            if (pr2 === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern2, pr2, swallowee);
              if (this.matchOne(file.slice(fr), pattern2.slice(pr2), partial2)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern2, pr2);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial2) {
              this.debug("\n>>> no match, partial?", file, fr, pattern2, pr2);
              if (fr === fl) {
                return true;
              }
            }
            return false;
          }
          let hit;
          if (typeof p20 === "string") {
            hit = f15 === p20;
            this.debug("string match", p20, f15, hit);
          } else {
            hit = p20.test(f15);
            this.debug("pattern match", p20, f15, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial2;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        } else {
          throw new Error("wtf?");
        }
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern2) {
        assertValidPattern(pattern2);
        const options2 = this.options;
        if (pattern2 === "**")
          return GLOBSTAR$2;
        if (pattern2 === "")
          return "";
        let m23;
        let fastTest = null;
        if (m23 = pattern2.match(starRE)) {
          fastTest = options2.dot ? starTestDot : starTest;
        } else if (m23 = pattern2.match(starDotExtRE)) {
          fastTest = (options2.nocase ? options2.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options2.dot ? starDotExtTestDot : starDotExtTest)(m23[1]);
        } else if (m23 = pattern2.match(qmarksRE)) {
          fastTest = (options2.nocase ? options2.dot ? qmarksTestNocaseDot : qmarksTestNocase : options2.dot ? qmarksTestDot : qmarksTest)(m23);
        } else if (m23 = pattern2.match(starDotStarRE)) {
          fastTest = options2.dot ? starDotStarTestDot : starDotStarTest;
        } else if (m23 = pattern2.match(dotStarRE)) {
          fastTest = dotStarTest;
        }
        const re3 = AST.fromGlob(pattern2, this.options).toMMPattern();
        if (fastTest && typeof re3 === "object") {
          Reflect.defineProperty(re3, "test", { value: fastTest });
        }
        return re3;
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set2 = this.set;
        if (!set2.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options2 = this.options;
        const twoStar = options2.noglobstar ? star2 : options2.dot ? twoStarDot : twoStarNoDot;
        const flags = new Set(options2.nocase ? ["i"] : []);
        let re3 = set2.map((pattern2) => {
          const pp = pattern2.map((p20) => {
            if (p20 instanceof RegExp) {
              for (const f15 of p20.flags.split(""))
                flags.add(f15);
            }
            return typeof p20 === "string" ? regExpEscape(p20) : p20 === GLOBSTAR$2 ? GLOBSTAR$2 : p20._src;
          });
          pp.forEach((p20, i14) => {
            const next = pp[i14 + 1];
            const prev = pp[i14 - 1];
            if (p20 !== GLOBSTAR$2 || prev === GLOBSTAR$2) {
              return;
            }
            if (prev === void 0) {
              if (next !== void 0 && next !== GLOBSTAR$2) {
                pp[i14 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
              } else {
                pp[i14] = twoStar;
              }
            } else if (next === void 0) {
              pp[i14 - 1] = prev + "(?:\\/|" + twoStar + ")?";
            } else if (next !== GLOBSTAR$2) {
              pp[i14 - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
              pp[i14 + 1] = GLOBSTAR$2;
            }
          });
          return pp.filter((p20) => p20 !== GLOBSTAR$2).join("/");
        }).join("|");
        const [open2, close2] = set2.length > 1 ? ["(?:", ")"] : ["", ""];
        re3 = "^" + open2 + re3 + close2 + "$";
        if (this.negate)
          re3 = "^(?!" + re3 + ").+$";
        try {
          this.regexp = new RegExp(re3, [...flags].join(""));
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      slashSplit(p20) {
        if (this.preserveMultipleSlashes) {
          return p20.split("/");
        } else if (this.isWindows && /^\/\/[^\/]+/.test(p20)) {
          return ["", ...p20.split(/\/+/)];
        } else {
          return p20.split(/\/+/);
        }
      }
      match(f15, partial2 = this.partial) {
        this.debug("match", f15, this.pattern);
        if (this.comment) {
          return false;
        }
        if (this.empty) {
          return f15 === "";
        }
        if (f15 === "/" && partial2) {
          return true;
        }
        const options2 = this.options;
        if (this.isWindows) {
          f15 = f15.split("\\").join("/");
        }
        const ff = this.slashSplit(f15);
        this.debug(this.pattern, "split", ff);
        const set2 = this.set;
        this.debug(this.pattern, "set", set2);
        let filename = ff[ff.length - 1];
        if (!filename) {
          for (let i14 = ff.length - 2; !filename && i14 >= 0; i14--) {
            filename = ff[i14];
          }
        }
        for (let i14 = 0; i14 < set2.length; i14++) {
          const pattern2 = set2[i14];
          let file = ff;
          if (options2.matchBase && pattern2.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern2, partial2);
          if (hit) {
            if (options2.flipNegate) {
              return true;
            }
            return !this.negate;
          }
        }
        if (options2.flipNegate) {
          return false;
        }
        return this.negate;
      }
      static defaults(def) {
        return minimatch.defaults(def).Minimatch;
      }
    };
    minimatch.AST = AST;
    minimatch.Minimatch = Minimatch;
    minimatch.escape = escape$2;
    minimatch.unescape = unescape$1;
    perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    warned$1 = /* @__PURE__ */ new Set();
    PROCESS = typeof process === "object" && !!process ? process : {};
    emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    AC = globalThis.AbortController;
    AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_22, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    shouldWarn = (code) => !warned$1.has(code);
    isPosInt = (n14) => n14 && n14 === Math.floor(n14) && n14 > 0 && isFinite(n14);
    getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    Stack = class _Stack {
      heap;
      length;
      // private constructor
      static #constructing = false;
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        _Stack.#constructing = true;
        const s12 = new _Stack(max, HeapCls);
        _Stack.#constructing = false;
        return s12;
      }
      constructor(max, HeapCls) {
        if (!_Stack.#constructing) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      push(n14) {
        this.heap[this.length++] = n14;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    LRUCache = class _LRUCache {
      // options that cannot be changed without disaster
      #max;
      #maxSize;
      #dispose;
      #disposeAfter;
      #fetchMethod;
      #memoMethod;
      /**
       * {@link LRUCache.OptionsBase.ttl}
       */
      ttl;
      /**
       * {@link LRUCache.OptionsBase.ttlResolution}
       */
      ttlResolution;
      /**
       * {@link LRUCache.OptionsBase.ttlAutopurge}
       */
      ttlAutopurge;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnGet}
       */
      updateAgeOnGet;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnHas}
       */
      updateAgeOnHas;
      /**
       * {@link LRUCache.OptionsBase.allowStale}
       */
      allowStale;
      /**
       * {@link LRUCache.OptionsBase.noDisposeOnSet}
       */
      noDisposeOnSet;
      /**
       * {@link LRUCache.OptionsBase.noUpdateTTL}
       */
      noUpdateTTL;
      /**
       * {@link LRUCache.OptionsBase.maxEntrySize}
       */
      maxEntrySize;
      /**
       * {@link LRUCache.OptionsBase.sizeCalculation}
       */
      sizeCalculation;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
       */
      noDeleteOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
       */
      noDeleteOnStaleGet;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
       */
      allowStaleOnFetchAbort;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
       */
      allowStaleOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.ignoreFetchAbort}
       */
      ignoreFetchAbort;
      // computed properties
      #size;
      #calculatedSize;
      #keyMap;
      #keyList;
      #valList;
      #next;
      #prev;
      #head;
      #tail;
      #free;
      #disposed;
      #sizes;
      #starts;
      #ttls;
      #hasDispose;
      #hasFetchMethod;
      #hasDisposeAfter;
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c16) {
        return {
          // properties
          starts: c16.#starts,
          ttls: c16.#ttls,
          sizes: c16.#sizes,
          keyMap: c16.#keyMap,
          keyList: c16.#keyList,
          valList: c16.#valList,
          next: c16.#next,
          prev: c16.#prev,
          get head() {
            return c16.#head;
          },
          get tail() {
            return c16.#tail;
          },
          free: c16.#free,
          // methods
          isBackgroundFetch: (p20) => c16.#isBackgroundFetch(p20),
          backgroundFetch: (k13, index3, options2, context) => c16.#backgroundFetch(k13, index3, options2, context),
          moveToTail: (index3) => c16.#moveToTail(index3),
          indexes: (options2) => c16.#indexes(options2),
          rindexes: (options2) => c16.#rindexes(options2),
          isStale: (index3) => c16.#isStale(index3)
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return this.#max;
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return this.#maxSize;
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return this.#calculatedSize;
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return this.#size;
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return this.#fetchMethod;
      }
      get memoMethod() {
        return this.#memoMethod;
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return this.#dispose;
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return this.#disposeAfter;
      }
      constructor(options2) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options2;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!this.#maxSize && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (memoMethod !== void 0 && typeof memoMethod !== "function") {
          throw new TypeError("memoMethod must be a function if defined");
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = /* @__PURE__ */ new Map();
        this.#keyList = new Array(max).fill(void 0);
        this.#valList = new Array(max).fill(void 0);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === "function") {
          this.#dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.#disposeAfter = disposeAfter;
          this.#disposed = [];
        } else {
          this.#disposeAfter = void 0;
          this.#disposed = void 0;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.#maxSize !== 0) {
            if (!isPosInt(this.#maxSize)) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          this.#initializeTTLTracking();
        }
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned$1.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      /**
       * Return the number of ms left in the item's TTL. If item is not in cache,
       * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
       */
      getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
      }
      #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index3, ttl, start2 = perf.now()) => {
          starts[index3] = ttl !== 0 ? start2 : 0;
          ttls[index3] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.#isStale(index3)) {
                this.#delete(this.#keyList[index3], "expire");
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.#updateItemAge = (index3) => {
          starts[index3] = ttls[index3] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status2, index3) => {
          if (ttls[index3]) {
            const ttl = ttls[index3];
            const start2 = starts[index3];
            if (!ttl || !start2)
              return;
            status2.ttl = ttl;
            status2.start = start2;
            status2.now = cachedNow || getNow();
            const age = status2.now - start2;
            status2.remainingTTL = ttl - age;
          }
        };
        let cachedNow = 0;
        const getNow = () => {
          const n14 = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n14;
            const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
            if (t.unref) {
              t.unref();
            }
          }
          return n14;
        };
        this.getRemainingTTL = (key) => {
          const index3 = this.#keyMap.get(key);
          if (index3 === void 0) {
            return 0;
          }
          const ttl = ttls[index3];
          const start2 = starts[index3];
          if (!ttl || !start2) {
            return Infinity;
          }
          const age = (cachedNow || getNow()) - start2;
          return ttl - age;
        };
        this.#isStale = (index3) => {
          const s12 = starts[index3];
          const t = ttls[index3];
          return !!t && !!s12 && (cachedNow || getNow()) - s12 > t;
        };
      }
      // conditionally set private methods related to TTL
      #updateItemAge = () => {
      };
      #statusTTL = () => {
      };
      #setItemTTL = () => {
      };
      /* c8 ignore stop */
      #isStale = () => false;
      #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = (index3) => {
          this.#calculatedSize -= sizes[index3];
          sizes[index3] = 0;
        };
        this.#requireSize = (k13, v15, size, sizeCalculation) => {
          if (this.#isBackgroundFetch(v15)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v15, k13);
              if (!isPosInt(size)) {
                throw new TypeError("sizeCalculation return invalid (expect positive integer)");
              }
            } else {
              throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
            }
          }
          return size;
        };
        this.#addItemSize = (index3, size, status2) => {
          sizes[index3] = size;
          if (this.#maxSize) {
            const maxSize = this.#maxSize - sizes[index3];
            while (this.#calculatedSize > maxSize) {
              this.#evict(true);
            }
          }
          this.#calculatedSize += sizes[index3];
          if (status2) {
            status2.entrySize = size;
            status2.totalCalculatedSize = this.#calculatedSize;
          }
        };
      }
      #removeItemSize = (_i) => {
      };
      #addItemSize = (_i, _s, _st) => {
      };
      #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        }
        return 0;
      };
      *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i14 = this.#tail; true; ) {
            if (!this.#isValidIndex(i14)) {
              break;
            }
            if (allowStale || !this.#isStale(i14)) {
              yield i14;
            }
            if (i14 === this.#head) {
              break;
            } else {
              i14 = this.#prev[i14];
            }
          }
        }
      }
      *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i14 = this.#head; true; ) {
            if (!this.#isValidIndex(i14)) {
              break;
            }
            if (allowStale || !this.#isStale(i14)) {
              yield i14;
            }
            if (i14 === this.#tail) {
              break;
            } else {
              i14 = this.#next[i14];
            }
          }
        }
      }
      #isValidIndex(index3) {
        return index3 !== void 0 && this.#keyMap.get(this.#keyList[index3]) === index3;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i14 of this.#indexes()) {
          if (this.#valList[i14] !== void 0 && this.#keyList[i14] !== void 0 && !this.#isBackgroundFetch(this.#valList[i14])) {
            yield [this.#keyList[i14], this.#valList[i14]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i14 of this.#rindexes()) {
          if (this.#valList[i14] !== void 0 && this.#keyList[i14] !== void 0 && !this.#isBackgroundFetch(this.#valList[i14])) {
            yield [this.#keyList[i14], this.#valList[i14]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i14 of this.#indexes()) {
          const k13 = this.#keyList[i14];
          if (k13 !== void 0 && !this.#isBackgroundFetch(this.#valList[i14])) {
            yield k13;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i14 of this.#rindexes()) {
          const k13 = this.#keyList[i14];
          if (k13 !== void 0 && !this.#isBackgroundFetch(this.#valList[i14])) {
            yield k13;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i14 of this.#indexes()) {
          const v15 = this.#valList[i14];
          if (v15 !== void 0 && !this.#isBackgroundFetch(this.#valList[i14])) {
            yield this.#valList[i14];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i14 of this.#rindexes()) {
          const v15 = this.#valList[i14];
          if (v15 !== void 0 && !this.#isBackgroundFetch(this.#valList[i14])) {
            yield this.#valList[i14];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * A String value that is used in the creation of the default string
       * description of an object. Called by the built-in method
       * `Object.prototype.toString`.
       */
      [Symbol.toStringTag] = "LRUCache";
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
       */
      find(fn, getOptions2 = {}) {
        for (const i14 of this.#indexes()) {
          const v15 = this.#valList[i14];
          const value2 = this.#isBackgroundFetch(v15) ? v15.__staleWhileFetching : v15;
          if (value2 === void 0)
            continue;
          if (fn(value2, this.#keyList[i14], this)) {
            return this.get(this.#keyList[i14], getOptions2);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from most
       * recently used to least recently used.
       *
       * `fn` is called as `fn(value, key, cache)`.
       *
       * If `thisp` is provided, function will be called in the `this`-context of
       * the provided object, or the cache if no `thisp` object is provided.
       *
       * Does not update age or recenty of use, or iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i14 of this.#indexes()) {
          const v15 = this.#valList[i14];
          const value2 = this.#isBackgroundFetch(v15) ? v15.__staleWhileFetching : v15;
          if (value2 === void 0)
            continue;
          fn.call(thisp, value2, this.#keyList[i14], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i14 of this.#rindexes()) {
          const v15 = this.#valList[i14];
          const value2 = this.#isBackgroundFetch(v15) ? v15.__staleWhileFetching : v15;
          if (value2 === void 0)
            continue;
          fn.call(thisp, value2, this.#keyList[i14], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i14 of this.#rindexes({ allowStale: true })) {
          if (this.#isStale(i14)) {
            this.#delete(this.#keyList[i14], "expire");
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Returns `undefined` if the key is not present.
       *
       * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
       * serialization, the `start` value is always the current timestamp, and the
       * `ttl` is a calculated remaining time to live (negative if expired).
       *
       * Always returns stale values, if their info is found in the cache, so be
       * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
       * if relevant.
       */
      info(key) {
        const i14 = this.#keyMap.get(key);
        if (i14 === void 0)
          return void 0;
        const v15 = this.#valList[i14];
        const value2 = this.#isBackgroundFetch(v15) ? v15.__staleWhileFetching : v15;
        if (value2 === void 0)
          return void 0;
        const entry2 = { value: value2 };
        if (this.#ttls && this.#starts) {
          const ttl = this.#ttls[i14];
          const start2 = this.#starts[i14];
          if (ttl && start2) {
            const remain = ttl - (perf.now() - start2);
            entry2.ttl = remain;
            entry2.start = Date.now();
          }
        }
        if (this.#sizes) {
          entry2.size = this.#sizes[i14];
        }
        return entry2;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to {@link LRLUCache#load}.
       *
       * The `start` fields are calculated relative to a portable `Date.now()`
       * timestamp, even if `performance.now()` is available.
       *
       * Stale entries are always included in the `dump`, even if
       * {@link LRUCache.OptionsBase.allowStale} is false.
       *
       * Note: this returns an actual array, not a generator, so it can be more
       * easily passed around.
       */
      dump() {
        const arr = [];
        for (const i14 of this.#indexes({ allowStale: true })) {
          const key = this.#keyList[i14];
          const v15 = this.#valList[i14];
          const value2 = this.#isBackgroundFetch(v15) ? v15.__staleWhileFetching : v15;
          if (value2 === void 0 || key === void 0)
            continue;
          const entry2 = { value: value2 };
          if (this.#ttls && this.#starts) {
            entry2.ttl = this.#ttls[i14];
            const age = perf.now() - this.#starts[i14];
            entry2.start = Math.floor(Date.now() - age);
          }
          if (this.#sizes) {
            entry2.size = this.#sizes[i14];
          }
          arr.unshift([key, entry2]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       *
       * The shape of the resulting cache may be different if the same options are
       * not used in both caches.
       *
       * The `start` fields are assumed to be calculated relative to a portable
       * `Date.now()` timestamp, even if `performance.now()` is available.
       */
      load(arr) {
        this.clear();
        for (const [key, entry2] of arr) {
          if (entry2.start) {
            const age = Date.now() - entry2.start;
            entry2.start = perf.now() - age;
          }
          this.set(key, entry2.value, entry2);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       *
       * Fields on the {@link LRUCache.SetOptions} options param will override
       * their corresponding values in the constructor options for the scope
       * of this single `set()` operation.
       *
       * If `start` is provided, then that will set the effective start
       * time for the TTL calculation. Note that this must be a previous
       * value of `performance.now()` if supported, or a previous value of
       * `Date.now()` if not.
       *
       * Options object may also include `size`, which will prevent
       * calling the `sizeCalculation` function and just use the specified
       * number if it is a positive integer, and `noDisposeOnSet` which
       * will prevent calling a `dispose` function in the case of
       * overwrites.
       *
       * If the `size` (or return value of `sizeCalculation`) for a given
       * entry is greater than `maxEntrySize`, then the item will not be
       * added to the cache.
       *
       * Will update the recency of the entry.
       *
       * If the value is `undefined`, then this is an alias for
       * `cache.delete(key)`. `undefined` is never stored in the cache.
       */
      set(k13, v15, setOptions = {}) {
        if (v15 === void 0) {
          this.delete(k13);
          return this;
        }
        const { ttl = this.ttl, start: start2, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status: status2 } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k13, v15, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status2) {
            status2.set = "miss";
            status2.maxEntrySizeExceeded = true;
          }
          this.#delete(k13, "set");
          return this;
        }
        let index3 = this.#size === 0 ? void 0 : this.#keyMap.get(k13);
        if (index3 === void 0) {
          index3 = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
          this.#keyList[index3] = k13;
          this.#valList[index3] = v15;
          this.#keyMap.set(k13, index3);
          this.#next[this.#tail] = index3;
          this.#prev[index3] = this.#tail;
          this.#tail = index3;
          this.#size++;
          this.#addItemSize(index3, size, status2);
          if (status2)
            status2.set = "add";
          noUpdateTTL = false;
        } else {
          this.#moveToTail(index3);
          const oldVal = this.#valList[index3];
          if (v15 !== oldVal) {
            if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s12 } = oldVal;
              if (s12 !== void 0 && !noDisposeOnSet) {
                if (this.#hasDispose) {
                  this.#dispose?.(s12, k13, "set");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([s12, k13, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(oldVal, k13, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([oldVal, k13, "set"]);
              }
            }
            this.#removeItemSize(index3);
            this.#addItemSize(index3, size, status2);
            this.#valList[index3] = v15;
            if (status2) {
              status2.set = "replace";
              const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status2.oldValue = oldValue;
            }
          } else if (status2) {
            status2.set = "update";
          }
        }
        if (ttl !== 0 && !this.#ttls) {
          this.#initializeTTLTracking();
        }
        if (this.#ttls) {
          if (!noUpdateTTL) {
            this.#setItemTTL(index3, ttl, start2);
          }
          if (status2)
            this.#statusTTL(status2, index3);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        try {
          while (this.#size) {
            const val = this.#valList[this.#head];
            this.#evict(true);
            if (this.#isBackgroundFetch(val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while (task = dt?.shift()) {
              this.#disposeAfter?.(...task);
            }
          }
        }
      }
      #evict(free) {
        const head = this.#head;
        const k13 = this.#keyList[head];
        const v15 = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v15)) {
          v15.__abortController.abort(new Error("evicted"));
        } else if (this.#hasDispose || this.#hasDisposeAfter) {
          if (this.#hasDispose) {
            this.#dispose?.(v15, k13, "evict");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v15, k13, "evict"]);
          }
        }
        this.#removeItemSize(head);
        if (free) {
          this.#keyList[head] = void 0;
          this.#valList[head] = void 0;
          this.#free.push(head);
        }
        if (this.#size === 1) {
          this.#head = this.#tail = 0;
          this.#free.length = 0;
        } else {
          this.#head = this.#next[head];
        }
        this.#keyMap.delete(k13);
        this.#size--;
        return head;
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Check if a key is in the cache, without updating the recency of
       * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
       * to `true` in either the options or the constructor.
       *
       * Will return `false` if the item is stale, even though it is technically in
       * the cache. The difference can be determined (if it matters) by using a
       * `status` argument, and inspecting the `has` field.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k13, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status: status2 } = hasOptions;
        const index3 = this.#keyMap.get(k13);
        if (index3 !== void 0) {
          const v15 = this.#valList[index3];
          if (this.#isBackgroundFetch(v15) && v15.__staleWhileFetching === void 0) {
            return false;
          }
          if (!this.#isStale(index3)) {
            if (updateAgeOnHas) {
              this.#updateItemAge(index3);
            }
            if (status2) {
              status2.has = "hit";
              this.#statusTTL(status2, index3);
            }
            return true;
          } else if (status2) {
            status2.has = "stale";
            this.#statusTTL(status2, index3);
          }
        } else if (status2) {
          status2.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k13, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index3 = this.#keyMap.get(k13);
        if (index3 === void 0 || !allowStale && this.#isStale(index3)) {
          return;
        }
        const v15 = this.#valList[index3];
        return this.#isBackgroundFetch(v15) ? v15.__staleWhileFetching : v15;
      }
      #backgroundFetch(k13, index3, options2, context) {
        const v15 = index3 === void 0 ? void 0 : this.#valList[index3];
        if (this.#isBackgroundFetch(v15)) {
          return v15;
        }
        const ac = new AC();
        const { signal } = options2;
        signal?.addEventListener("abort", () => ac.abort(signal.reason), {
          signal: ac.signal
        });
        const fetchOpts = {
          signal: ac.signal,
          options: options2,
          context
        };
        const cb = (v16, updateCache = false) => {
          const { aborted } = ac.signal;
          const ignoreAbort = options2.ignoreFetchAbort && v16 !== void 0;
          if (options2.status) {
            if (aborted && !updateCache) {
              options2.status.fetchAborted = true;
              options2.status.fetchError = ac.signal.reason;
              if (ignoreAbort)
                options2.status.fetchAbortIgnored = true;
            } else {
              options2.status.fetchResolved = true;
            }
          }
          if (aborted && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          const bf2 = p20;
          if (this.#valList[index3] === p20) {
            if (v16 === void 0) {
              if (bf2.__staleWhileFetching) {
                this.#valList[index3] = bf2.__staleWhileFetching;
              } else {
                this.#delete(k13, "fetch");
              }
            } else {
              if (options2.status)
                options2.status.fetchUpdated = true;
              this.set(k13, v16, fetchOpts.options);
            }
          }
          return v16;
        };
        const eb = (er) => {
          if (options2.status) {
            options2.status.fetchRejected = true;
            options2.status.fetchError = er;
          }
          return fetchFail(er);
        };
        const fetchFail = (er) => {
          const { aborted } = ac.signal;
          const allowStaleAborted = aborted && options2.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options2.allowStaleOnFetchRejection;
          const noDelete = allowStale || options2.noDeleteOnFetchRejection;
          const bf2 = p20;
          if (this.#valList[index3] === p20) {
            const del = !noDelete || bf2.__staleWhileFetching === void 0;
            if (del) {
              this.#delete(k13, "fetch");
            } else if (!allowStaleAborted) {
              this.#valList[index3] = bf2.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options2.status && bf2.__staleWhileFetching !== void 0) {
              options2.status.returnedStale = true;
            }
            return bf2.__staleWhileFetching;
          } else if (bf2.__returned === bf2) {
            throw er;
          }
        };
        const pcall = (res, rej) => {
          const fmp = this.#fetchMethod?.(k13, v15, fetchOpts);
          if (fmp && fmp instanceof Promise) {
            fmp.then((v16) => res(v16 === void 0 ? void 0 : v16), rej);
          }
          ac.signal.addEventListener("abort", () => {
            if (!options2.ignoreFetchAbort || options2.allowStaleOnFetchAbort) {
              res(void 0);
              if (options2.allowStaleOnFetchAbort) {
                res = (v16) => cb(v16, true);
              }
            }
          });
        };
        if (options2.status)
          options2.status.fetchDispatched = true;
        const p20 = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p20, {
          __abortController: ac,
          __staleWhileFetching: v15,
          __returned: void 0
        });
        if (index3 === void 0) {
          this.set(k13, bf, { ...fetchOpts.options, status: void 0 });
          index3 = this.#keyMap.get(k13);
        } else {
          this.#valList[index3] = bf;
        }
        return bf;
      }
      #isBackgroundFetch(p20) {
        if (!this.#hasFetchMethod)
          return false;
        const b18 = p20;
        return !!b18 && b18 instanceof Promise && b18.hasOwnProperty("__staleWhileFetching") && b18.__abortController instanceof AC;
      }
      async fetch(k13, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context,
          forceRefresh = false,
          status: status2,
          signal
        } = fetchOptions;
        if (!this.#hasFetchMethod) {
          if (status2)
            status2.fetch = "get";
          return this.get(k13, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status: status2
          });
        }
        const options2 = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status: status2,
          signal
        };
        let index3 = this.#keyMap.get(k13);
        if (index3 === void 0) {
          if (status2)
            status2.fetch = "miss";
          const p20 = this.#backgroundFetch(k13, index3, options2, context);
          return p20.__returned = p20;
        } else {
          const v15 = this.#valList[index3];
          if (this.#isBackgroundFetch(v15)) {
            const stale = allowStale && v15.__staleWhileFetching !== void 0;
            if (status2) {
              status2.fetch = "inflight";
              if (stale)
                status2.returnedStale = true;
            }
            return stale ? v15.__staleWhileFetching : v15.__returned = v15;
          }
          const isStale = this.#isStale(index3);
          if (!forceRefresh && !isStale) {
            if (status2)
              status2.fetch = "hit";
            this.#moveToTail(index3);
            if (updateAgeOnGet) {
              this.#updateItemAge(index3);
            }
            if (status2)
              this.#statusTTL(status2, index3);
            return v15;
          }
          const p20 = this.#backgroundFetch(k13, index3, options2, context);
          const hasStale = p20.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status2) {
            status2.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status2.returnedStale = true;
          }
          return staleVal ? p20.__staleWhileFetching : p20.__returned = p20;
        }
      }
      async forceFetch(k13, fetchOptions = {}) {
        const v15 = await this.fetch(k13, fetchOptions);
        if (v15 === void 0)
          throw new Error("fetch() returned undefined");
        return v15;
      }
      memo(k13, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
          throw new Error("no memoMethod provided to constructor");
        }
        const { context, forceRefresh, ...options2 } = memoOptions;
        const v15 = this.get(k13, options2);
        if (!forceRefresh && v15 !== void 0)
          return v15;
        const vv = memoMethod(k13, v15, {
          options: options2,
          context
        });
        this.set(k13, vv, options2);
        return vv;
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k13, getOptions2 = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status: status2 } = getOptions2;
        const index3 = this.#keyMap.get(k13);
        if (index3 !== void 0) {
          const value2 = this.#valList[index3];
          const fetching = this.#isBackgroundFetch(value2);
          if (status2)
            this.#statusTTL(status2, index3);
          if (this.#isStale(index3)) {
            if (status2)
              status2.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.#delete(k13, "expire");
              }
              if (status2 && allowStale)
                status2.returnedStale = true;
              return allowStale ? value2 : void 0;
            } else {
              if (status2 && allowStale && value2.__staleWhileFetching !== void 0) {
                status2.returnedStale = true;
              }
              return allowStale ? value2.__staleWhileFetching : void 0;
            }
          } else {
            if (status2)
              status2.get = "hit";
            if (fetching) {
              return value2.__staleWhileFetching;
            }
            this.#moveToTail(index3);
            if (updateAgeOnGet) {
              this.#updateItemAge(index3);
            }
            return value2;
          }
        } else if (status2) {
          status2.get = "miss";
        }
      }
      #connect(p20, n14) {
        this.#prev[n14] = p20;
        this.#next[p20] = n14;
      }
      #moveToTail(index3) {
        if (index3 !== this.#tail) {
          if (index3 === this.#head) {
            this.#head = this.#next[index3];
          } else {
            this.#connect(this.#prev[index3], this.#next[index3]);
          }
          this.#connect(this.#tail, index3);
          this.#tail = index3;
        }
      }
      /**
       * Deletes a key out of the cache.
       *
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k13) {
        return this.#delete(k13, "delete");
      }
      #delete(k13, reason) {
        let deleted = false;
        if (this.#size !== 0) {
          const index3 = this.#keyMap.get(k13);
          if (index3 !== void 0) {
            deleted = true;
            if (this.#size === 1) {
              this.#clear(reason);
            } else {
              this.#removeItemSize(index3);
              const v15 = this.#valList[index3];
              if (this.#isBackgroundFetch(v15)) {
                v15.__abortController.abort(new Error("deleted"));
              } else if (this.#hasDispose || this.#hasDisposeAfter) {
                if (this.#hasDispose) {
                  this.#dispose?.(v15, k13, reason);
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([v15, k13, reason]);
                }
              }
              this.#keyMap.delete(k13);
              this.#keyList[index3] = void 0;
              this.#valList[index3] = void 0;
              if (index3 === this.#tail) {
                this.#tail = this.#prev[index3];
              } else if (index3 === this.#head) {
                this.#head = this.#next[index3];
              } else {
                const pi = this.#prev[index3];
                this.#next[pi] = this.#next[index3];
                const ni = this.#next[index3];
                this.#prev[ni] = this.#prev[index3];
              }
              this.#size--;
              this.#free.push(index3);
            }
          }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return deleted;
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        return this.#clear("delete");
      }
      #clear(reason) {
        for (const index3 of this.#rindexes({ allowStale: true })) {
          const v15 = this.#valList[index3];
          if (this.#isBackgroundFetch(v15)) {
            v15.__abortController.abort(new Error("deleted"));
          } else {
            const k13 = this.#keyList[index3];
            if (this.#hasDispose) {
              this.#dispose?.(v15, k13, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v15, k13, reason]);
            }
          }
        }
        this.#keyMap.clear();
        this.#valList.fill(void 0);
        this.#keyList.fill(void 0);
        if (this.#ttls && this.#starts) {
          this.#ttls.fill(0);
          this.#starts.fill(0);
        }
        if (this.#sizes) {
          this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    };
    proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    isStream = (s12) => !!s12 && typeof s12 === "object" && (s12 instanceof Minipass || s12 instanceof Stream$1 || isReadable(s12) || isWritable(s12));
    isReadable = (s12) => !!s12 && typeof s12 === "object" && s12 instanceof EventEmitter$4 && typeof s12.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
    s12.pipe !== Stream$1.Writable.prototype.pipe;
    isWritable = (s12) => !!s12 && typeof s12 === "object" && s12 instanceof EventEmitter$4 && typeof s12.write === "function" && typeof s12.end === "function";
    EOF = Symbol("EOF");
    MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    EMITTED_END = Symbol("emittedEnd");
    EMITTING_END = Symbol("emittingEnd");
    EMITTED_ERROR = Symbol("emittedError");
    CLOSED$1 = Symbol("closed");
    READ = Symbol("read");
    FLUSH = Symbol("flush");
    FLUSHCHUNK = Symbol("flushChunk");
    ENCODING$1 = Symbol("encoding");
    DECODER = Symbol("decoder");
    FLOWING = Symbol("flowing");
    PAUSED = Symbol("paused");
    RESUME = Symbol("resume");
    BUFFER = Symbol("buffer");
    PIPES = Symbol("pipes");
    BUFFERLENGTH = Symbol("bufferLength");
    BUFFERPUSH = Symbol("bufferPush");
    BUFFERSHIFT = Symbol("bufferShift");
    OBJECTMODE = Symbol("objectMode");
    DESTROYED = Symbol("destroyed");
    ERROR = Symbol("error");
    EMITDATA = Symbol("emitData");
    EMITEND = Symbol("emitEnd");
    EMITEND2 = Symbol("emitEnd2");
    ASYNC = Symbol("async");
    ABORT = Symbol("abort");
    ABORTED = Symbol("aborted");
    SIGNAL = Symbol("signal");
    DATALISTENERS = Symbol("dataListeners");
    DISCARDED = Symbol("discarded");
    defer$3 = (fn) => Promise.resolve().then(fn);
    nodefer = (fn) => fn();
    isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    isArrayBufferLike = (b18) => b18 instanceof ArrayBuffer || !!b18 && typeof b18 === "object" && b18.constructor && b18.constructor.name === "ArrayBuffer" && b18.byteLength >= 0;
    isArrayBufferView = (b18) => !Buffer.isBuffer(b18) && ArrayBuffer.isView(b18);
    Pipe = class {
      src;
      dest;
      opts;
      ondrain;
      constructor(src3, dest, opts) {
        this.src = src3;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src3[RESUME]();
        this.dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // only here for the prototype
      /* c8 ignore start */
      proxyErrors(_er) {
      }
      /* c8 ignore stop */
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src3, dest, opts) {
        super(src3, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src3.on("error", this.proxyErrors);
      }
    };
    isObjectModeOptions = (o10) => !!o10.objectMode;
    isEncodingOptions = (o10) => !o10.objectMode && !!o10.encoding && o10.encoding !== "buffer";
    Minipass = class extends EventEmitter$4 {
      [FLOWING] = false;
      [PAUSED] = false;
      [PIPES] = [];
      [BUFFER] = [];
      [OBJECTMODE];
      [ENCODING$1];
      [ASYNC];
      [DECODER];
      [EOF] = false;
      [EMITTED_END] = false;
      [EMITTING_END] = false;
      [CLOSED$1] = false;
      [EMITTED_ERROR] = null;
      [BUFFERLENGTH] = 0;
      [DESTROYED] = false;
      [SIGNAL];
      [ABORTED] = false;
      [DATALISTENERS] = 0;
      [DISCARDED] = false;
      /**
       * true if the stream can be written
       */
      writable = true;
      /**
       * true if the stream can be read
       */
      readable = true;
      /**
       * If `RType` is Buffer, then options do not need to be provided.
       * Otherwise, an options object must be provided to specify either
       * {@link Minipass.SharedOptions.objectMode} or
       * {@link Minipass.SharedOptions.encoding}, as appropriate.
       */
      constructor(...args) {
        const options2 = args[0] || {};
        super();
        if (options2.objectMode && typeof options2.encoding === "string") {
          throw new TypeError("Encoding and objectMode may not be used together");
        }
        if (isObjectModeOptions(options2)) {
          this[OBJECTMODE] = true;
          this[ENCODING$1] = null;
        } else if (isEncodingOptions(options2)) {
          this[ENCODING$1] = options2.encoding;
          this[OBJECTMODE] = false;
        } else {
          this[OBJECTMODE] = false;
          this[ENCODING$1] = null;
        }
        this[ASYNC] = !!options2.async;
        this[DECODER] = this[ENCODING$1] ? new StringDecoder(this[ENCODING$1]) : null;
        if (options2 && options2.debugExposeBuffer === true) {
          Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
        }
        if (options2 && options2.debugExposePipes === true) {
          Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
        }
        const { signal } = options2;
        if (signal) {
          this[SIGNAL] = signal;
          if (signal.aborted) {
            this[ABORT]();
          } else {
            signal.addEventListener("abort", () => this[ABORT]());
          }
        }
      }
      /**
       * The amount of data stored in the buffer waiting to be read.
       *
       * For Buffer strings, this will be the total byte length.
       * For string encoding streams, this will be the string character length,
       * according to JavaScript's `string.length` logic.
       * For objectMode streams, this is a count of the items waiting to be
       * emitted.
       */
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      /**
       * The `BufferEncoding` currently in use, or `null`
       */
      get encoding() {
        return this[ENCODING$1];
      }
      /**
       * @deprecated - This is a read only property
       */
      set encoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * @deprecated - Encoding may only be set at instantiation time
       */
      setEncoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * True if this is an objectMode stream
       */
      get objectMode() {
        return this[OBJECTMODE];
      }
      /**
       * @deprecated - This is a read-only property
       */
      set objectMode(_om) {
        throw new Error("objectMode must be set at instantiation time");
      }
      /**
       * true if this is an async stream
       */
      get ["async"]() {
        return this[ASYNC];
      }
      /**
       * Set to true to make this stream async.
       *
       * Once set, it cannot be unset, as this would potentially cause incorrect
       * behavior.  Ie, a sync stream can be made async, but an async stream
       * cannot be safely made sync.
       */
      set ["async"](a20) {
        this[ASYNC] = this[ASYNC] || !!a20;
      }
      // drop everything and get out of the flow completely
      [ABORT]() {
        this[ABORTED] = true;
        this.emit("abort", this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
      }
      /**
       * True if the stream has been aborted.
       */
      get aborted() {
        return this[ABORTED];
      }
      /**
       * No-op setter. Stream aborted status is set via the AbortSignal provided
       * in the constructor options.
       */
      set aborted(_22) {
      }
      write(chunk, encoding, cb) {
        if (this[ABORTED])
          return false;
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
          return true;
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = "utf8";
        }
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer$3 : nodefer;
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk)) {
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          } else if (isArrayBufferLike(chunk)) {
            chunk = Buffer.from(chunk);
          } else if (typeof chunk !== "string") {
            throw new Error("Non-contiguous data written to non-objectMode stream");
          }
        }
        if (this[OBJECTMODE]) {
          if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this[FLOWING])
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING$1] && !this[DECODER]?.lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING$1]) {
          chunk = this[DECODER].write(chunk);
        }
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this[FLOWING])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      /**
       * Low-level explicit read method.
       *
       * In objectMode, the argument is ignored, and one item is returned if
       * available.
       *
       * `n` is the number of bytes (or in the case of encoding streams,
       * characters) to consume. If `n` is not provided, then the entire buffer
       * is returned, or `null` is returned if no data is available.
       *
       * If `n` is greater that the amount of data in the internal buffer,
       * then `null` is returned.
       */
      read(n14) {
        if (this[DESTROYED])
          return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 || n14 === 0 || n14 && n14 > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n14 = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
          this[BUFFER] = [
            this[ENCODING$1] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
          ];
        }
        const ret = this[READ](n14 || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n14, chunk) {
        if (this[OBJECTMODE])
          this[BUFFERSHIFT]();
        else {
          const c16 = chunk;
          if (n14 === c16.length || n14 === null)
            this[BUFFERSHIFT]();
          else if (typeof c16 === "string") {
            this[BUFFER][0] = c16.slice(n14);
            chunk = c16.slice(0, n14);
            this[BUFFERLENGTH] -= n14;
          } else {
            this[BUFFER][0] = c16.subarray(n14);
            chunk = c16.subarray(0, n14);
            this[BUFFERLENGTH] -= n14;
          }
        }
        this.emit("data", chunk);
        if (!this[BUFFER].length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = void 0;
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = "utf8";
        }
        if (chunk !== void 0)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this[FLOWING] || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
          this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this[BUFFER].length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      /**
       * Resume the stream if it is currently in a paused state
       *
       * If called when there are no pipe destinations or `data` event listeners,
       * this will place the stream in a "discarded" state, where all data will
       * be thrown away. The discarded state is removed if a pipe destination or
       * data handler is added, if pause() is called, or if any synchronous or
       * asynchronous iteration is started.
       */
      resume() {
        return this[RESUME]();
      }
      /**
       * Pause the stream
       */
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
      }
      /**
       * true if the stream has been forcibly destroyed
       */
      get destroyed() {
        return this[DESTROYED];
      }
      /**
       * true if the stream is currently in a flowing state, meaning that
       * any writes will be immediately emitted.
       */
      get flowing() {
        return this[FLOWING];
      }
      /**
       * true if the stream is currently in a paused state
       */
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
      }
      [FLUSH](noDrain = false) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        this.emit("data", chunk);
        return this[FLOWING];
      }
      /**
       * Pipe all data emitted by this stream into the destination provided.
       *
       * Triggers the flow of data.
       */
      pipe(dest, opts) {
        if (this[DESTROYED])
          return dest;
        this[DISCARDED] = false;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer$3(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      /**
       * Fully unhook a piped destination stream.
       *
       * If the destination stream was the only consumer of this stream (ie,
       * there are no other piped destinations or `'data'` event listeners)
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      unpipe(dest) {
        const p20 = this[PIPES].find((p21) => p21.dest === dest);
        if (p20) {
          if (this[PIPES].length === 1) {
            if (this[FLOWING] && this[DATALISTENERS] === 0) {
              this[FLOWING] = false;
            }
            this[PIPES] = [];
          } else
            this[PIPES].splice(this[PIPES].indexOf(p20), 1);
          p20.unpipe();
        }
      }
      /**
       * Alias for {@link Minipass#on}
       */
      addListener(ev, handler) {
        return this.on(ev, handler);
      }
      /**
       * Mostly identical to `EventEmitter.on`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * - Adding a 'data' event handler will trigger the flow of data
       *
       * - Adding a 'readable' event handler when there is data waiting to be read
       *   will cause 'readable' to be emitted immediately.
       *
       * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
       *   already passed will cause the event to be emitted immediately and all
       *   handlers removed.
       *
       * - Adding an 'error' event handler after an error has been emitted will
       *   cause the event to be re-emitted immediately with the error previously
       *   raised.
       */
      on(ev, handler) {
        const ret = super.on(ev, handler);
        if (ev === "data") {
          this[DISCARDED] = false;
          this[DATALISTENERS]++;
          if (!this[PIPES].length && !this[FLOWING]) {
            this[RESUME]();
          }
        } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
          super.emit("readable");
        } else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          const h20 = handler;
          if (this[ASYNC])
            defer$3(() => h20.call(this, this[EMITTED_ERROR]));
          else
            h20.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      /**
       * Alias for {@link Minipass#off}
       */
      removeListener(ev, handler) {
        return this.off(ev, handler);
      }
      /**
       * Mostly identical to `EventEmitter.off`
       *
       * If a 'data' event handler is removed, and it was the last consumer
       * (ie, there are no pipe destinations or other 'data' event listeners),
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      off(ev, handler) {
        const ret = super.off(ev, handler);
        if (ev === "data") {
          this[DATALISTENERS] = this.listeners("data").length;
          if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * Mostly identical to `EventEmitter.removeAllListeners`
       *
       * If all 'data' event handlers are removed, and they were the last consumer
       * (ie, there are no pipe destinations), then the flow of data will stop
       * until there is another consumer or {@link Minipass#resume} is explicitly
       * called.
       */
      removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === "data" || ev === void 0) {
          this[DATALISTENERS] = 0;
          if (!this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * true if the 'end' event has been emitted
       */
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED$1])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      /**
       * Mostly identical to `EventEmitter.emit`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * If the stream has been destroyed, and the event is something other
       * than 'close' or 'error', then `false` is returned and no handlers
       * are called.
       *
       * If the event is 'end', and has already been emitted, then the event
       * is ignored. If the stream is in a paused or non-flowing state, then
       * the event will be deferred until data flow resumes. If the stream is
       * async, then handlers will be called on the next tick rather than
       * immediately.
       *
       * If the event is 'close', and 'end' has not yet been emitted, then
       * the event will be deferred until after 'end' is emitted.
       *
       * If the event is 'error', and an AbortSignal was provided for the stream,
       * and there are no listeners, then the event is ignored, matching the
       * behavior of node core streams in the presense of an AbortSignal.
       *
       * If the event is 'finish' or 'prefinish', then all listeners will be
       * removed after emitting the event, to prevent double-firing.
       */
      emit(ev, ...args) {
        const data = args[0];
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
          return false;
        } else if (ev === "data") {
          return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer$3(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED$1] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return false;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          super.emit(ERROR, data);
          const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p20 of this[PIPES]) {
          if (p20.dest.write(data) === false)
            this.pause();
        }
        const ret = this[DISCARDED] ? false : super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return false;
        this[EMITTED_END] = true;
        this.readable = false;
        return this[ASYNC] ? (defer$3(() => this[EMITEND2]()), true) : this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p20 of this[PIPES]) {
              p20.dest.write(data);
            }
            if (!this[DISCARDED])
              super.emit("data", data);
          }
        }
        for (const p20 of this[PIPES]) {
          p20.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      /**
       * Return a Promise that resolves to an array of all emitted data once
       * the stream ends.
       */
      async collect() {
        const buf = Object.assign([], {
          dataLength: 0
        });
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p20 = this.promise();
        this.on("data", (c16) => {
          buf.push(c16);
          if (!this[OBJECTMODE])
            buf.dataLength += c16.length;
        });
        await p20;
        return buf;
      }
      /**
       * Return a Promise that resolves to the concatenation of all emitted data
       * once the stream ends.
       *
       * Not allowed on objectMode streams.
       */
      async concat() {
        if (this[OBJECTMODE]) {
          throw new Error("cannot concat in objectMode");
        }
        const buf = await this.collect();
        return this[ENCODING$1] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
      }
      /**
       * Return a void Promise that resolves once the stream ends.
       */
      async promise() {
        return new Promise((resolve5, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve5());
        });
      }
      /**
       * Asynchronous `for await of` iteration.
       *
       * This will continue emitting all chunks until the stream terminates.
       */
      [Symbol.asyncIterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
          this.pause();
          stopped = true;
          return { value: void 0, done: true };
        };
        const next = () => {
          if (stopped)
            return stop();
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return stop();
          let resolve5;
          let reject;
          const onerr = (er) => {
            this.off("data", ondata);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            stop();
            reject(er);
          };
          const ondata = (value2) => {
            this.off("error", onerr);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            this.pause();
            resolve5({ value: value2, done: !!this[EOF] });
          };
          const onend = () => {
            this.off("error", onerr);
            this.off("data", ondata);
            this.off(DESTROYED, ondestroy);
            stop();
            resolve5({ done: true, value: void 0 });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve5 = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
      /**
       * Synchronous `for of` iteration.
       *
       * The iteration will terminate when the internal buffer runs out, even
       * if the stream has not yet terminated.
       */
      [Symbol.iterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
          this.pause();
          this.off(ERROR, stop);
          this.off(DESTROYED, stop);
          this.off("end", stop);
          stopped = true;
          return { done: true, value: void 0 };
        };
        const next = () => {
          if (stopped)
            return stop();
          const value2 = this.read();
          return value2 === null ? stop() : { done: false, value: value2 };
        };
        this.once("end", stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.iterator]() {
            return this;
          }
        };
      }
      /**
       * Destroy a stream, preventing it from being used for any further purpose.
       *
       * If the stream has a `close()` method, then it will be called on
       * destruction.
       *
       * After destruction, any attempt to write data, read data, or emit most
       * events will be ignored.
       *
       * If an error argument is provided, then it will be emitted in an
       * 'error' event.
       */
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === "function" && !this[CLOSED$1])
          wc.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      /**
       * Alias for {@link isStream}
       *
       * Former export location, maintained for backwards compatibility.
       *
       * @deprecated
       */
      static get isStream() {
        return isStream;
      }
    };
    realpathSync = realpathSync$1.native;
    defaultFS = {
      lstatSync,
      readdir: readdir$4,
      readdirSync,
      readlinkSync,
      realpathSync,
      promises: {
        lstat: lstat$3,
        readdir: readdir$5,
        readlink,
        realpath: realpath$2
      }
    };
    fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === fs$j ? defaultFS : {
      ...defaultFS,
      ...fsOption,
      promises: {
        ...defaultFS.promises,
        ...fsOption.promises || {}
      }
    };
    uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
    uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    eitherSep = /[\\\/]/;
    UNKNOWN = 0;
    IFIFO = 1;
    IFCHR = 2;
    IFDIR = 4;
    IFBLK = 6;
    IFREG = 8;
    IFLNK = 10;
    IFSOCK = 12;
    IFMT = 15;
    IFMT_UNKNOWN = ~IFMT;
    READDIR_CALLED = 16;
    LSTAT_CALLED = 32;
    ENOTDIR = 64;
    ENOENT = 128;
    ENOREADLINK = 256;
    ENOREALPATH = 512;
    ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
    TYPEMASK = 1023;
    entToType = (s12) => s12.isFile() ? IFREG : s12.isDirectory() ? IFDIR : s12.isSymbolicLink() ? IFLNK : s12.isCharacterDevice() ? IFCHR : s12.isBlockDevice() ? IFBLK : s12.isSocket() ? IFSOCK : s12.isFIFO() ? IFIFO : UNKNOWN;
    normalizeCache = /* @__PURE__ */ new Map();
    normalize2 = (s12) => {
      const c16 = normalizeCache.get(s12);
      if (c16)
        return c16;
      const n14 = s12.normalize("NFKD");
      normalizeCache.set(s12, n14);
      return n14;
    };
    normalizeNocaseCache = /* @__PURE__ */ new Map();
    normalizeNocase = (s12) => {
      const c16 = normalizeNocaseCache.get(s12);
      if (c16)
        return c16;
      const n14 = normalize2(s12.toLowerCase());
      normalizeNocaseCache.set(s12, n14);
      return n14;
    };
    ResolveCache = class extends LRUCache {
      constructor() {
        super({ max: 256 });
      }
    };
    ChildrenCache = class extends LRUCache {
      constructor(maxSize = 16 * 1024) {
        super({
          maxSize,
          // parent + children
          sizeCalculation: (a20) => a20.length + 1
        });
      }
    };
    setAsCwd = Symbol("PathScurry setAsCwd");
    PathBase = class {
      /**
       * the basename of this path
       *
       * **Important**: *always* test the path name against any test string
       * usingthe {@link isNamed} method, and not by directly comparing this
       * string. Otherwise, unicode path strings that the system sees as identical
       * will not be properly treated as the same path, leading to incorrect
       * behavior and possible security issues.
       */
      name;
      /**
       * the Path entry corresponding to the path root.
       *
       * @internal
       */
      root;
      /**
       * All roots found within the current PathScurry family
       *
       * @internal
       */
      roots;
      /**
       * a reference to the parent path, or undefined in the case of root entries
       *
       * @internal
       */
      parent;
      /**
       * boolean indicating whether paths are compared case-insensitively
       * @internal
       */
      nocase;
      /**
       * boolean indicating that this path is the current working directory
       * of the PathScurry collection that contains it.
       */
      isCWD = false;
      // potential default fs override
      #fs;
      // Stats fields
      #dev;
      get dev() {
        return this.#dev;
      }
      #mode;
      get mode() {
        return this.#mode;
      }
      #nlink;
      get nlink() {
        return this.#nlink;
      }
      #uid;
      get uid() {
        return this.#uid;
      }
      #gid;
      get gid() {
        return this.#gid;
      }
      #rdev;
      get rdev() {
        return this.#rdev;
      }
      #blksize;
      get blksize() {
        return this.#blksize;
      }
      #ino;
      get ino() {
        return this.#ino;
      }
      #size;
      get size() {
        return this.#size;
      }
      #blocks;
      get blocks() {
        return this.#blocks;
      }
      #atimeMs;
      get atimeMs() {
        return this.#atimeMs;
      }
      #mtimeMs;
      get mtimeMs() {
        return this.#mtimeMs;
      }
      #ctimeMs;
      get ctimeMs() {
        return this.#ctimeMs;
      }
      #birthtimeMs;
      get birthtimeMs() {
        return this.#birthtimeMs;
      }
      #atime;
      get atime() {
        return this.#atime;
      }
      #mtime;
      get mtime() {
        return this.#mtime;
      }
      #ctime;
      get ctime() {
        return this.#ctime;
      }
      #birthtime;
      get birthtime() {
        return this.#birthtime;
      }
      #matchName;
      #depth;
      #fullpath;
      #fullpathPosix;
      #relative;
      #relativePosix;
      #type;
      #children;
      #linkTarget;
      #realpath;
      /**
       * This property is for compatibility with the Dirent class as of
       * Node v20, where Dirent['parentPath'] refers to the path of the
       * directory that was passed to readdir. For root entries, it's the path
       * to the entry itself.
       */
      get parentPath() {
        return (this.parent || this).fullpath();
      }
      /**
       * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
       * this property refers to the *parent* path, not the path object itself.
       */
      get path() {
        return this.parentPath;
      }
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name2, type = UNKNOWN, root3, roots, nocase, children, opts) {
        this.name = name2;
        this.#matchName = nocase ? normalizeNocase(name2) : normalize2(name2);
        this.#type = type & TYPEMASK;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root3 || this;
        this.#children = children;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
          this.#fs = this.parent.#fs;
        } else {
          this.#fs = fsFromOption(opts.fs);
        }
      }
      /**
       * Returns the depth of the Path object from its root.
       *
       * For example, a path at `/foo/bar` would have a depth of 2.
       */
      depth() {
        if (this.#depth !== void 0)
          return this.#depth;
        if (!this.parent)
          return this.#depth = 0;
        return this.#depth = this.parent.depth() + 1;
      }
      /**
       * @internal
       */
      childrenCache() {
        return this.#children;
      }
      /**
       * Get the Path object referenced by the string path, resolved from this Path
       */
      resolve(path7) {
        if (!path7) {
          return this;
        }
        const rootPath = this.getRootString(path7);
        const dir = path7.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
        return result;
      }
      #resolveParts(dirParts) {
        let p20 = this;
        for (const part of dirParts) {
          p20 = p20.child(part);
        }
        return p20;
      }
      /**
       * Returns the cached children Path objects, if still available.  If they
       * have fallen out of the cache, then returns an empty array, and resets the
       * READDIR_CALLED bit, so that future calls to readdir() will require an fs
       * lookup.
       *
       * @internal
       */
      children() {
        const cached = this.#children.get(this);
        if (cached) {
          return cached;
        }
        const children = Object.assign([], { provisional: 0 });
        this.#children.set(this, children);
        this.#type &= ~READDIR_CALLED;
        return children;
      }
      /**
       * Resolves a path portion and returns or creates the child Path.
       *
       * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
       * `'..'`.
       *
       * This should not be called directly.  If `pathPart` contains any path
       * separators, it will lead to unsafe undefined behavior.
       *
       * Use `Path.resolve()` instead.
       *
       * @internal
       */
      child(pathPart, opts) {
        if (pathPart === "" || pathPart === ".") {
          return this;
        }
        if (pathPart === "..") {
          return this.parent || this;
        }
        const children = this.children();
        const name2 = this.nocase ? normalizeNocase(pathPart) : normalize2(pathPart);
        for (const p20 of children) {
          if (p20.#matchName === name2) {
            return p20;
          }
        }
        const s12 = this.parent ? this.sep : "";
        const fullpath = this.#fullpath ? this.#fullpath + s12 + pathPart : void 0;
        const pchild = this.newChild(pathPart, UNKNOWN, {
          ...opts,
          parent: this,
          fullpath
        });
        if (!this.canReaddir()) {
          pchild.#type |= ENOENT;
        }
        children.push(pchild);
        return pchild;
      }
      /**
       * The relative path from the cwd. If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpath()
       */
      relative() {
        if (this.isCWD)
          return "";
        if (this.#relative !== void 0) {
          return this.#relative;
        }
        const name2 = this.name;
        const p20 = this.parent;
        if (!p20) {
          return this.#relative = this.name;
        }
        const pv = p20.relative();
        return pv + (!pv || !p20.parent ? "" : this.sep) + name2;
      }
      /**
       * The relative path from the cwd, using / as the path separator.
       * If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpathPosix()
       * On posix systems, this is identical to relative().
       */
      relativePosix() {
        if (this.sep === "/")
          return this.relative();
        if (this.isCWD)
          return "";
        if (this.#relativePosix !== void 0)
          return this.#relativePosix;
        const name2 = this.name;
        const p20 = this.parent;
        if (!p20) {
          return this.#relativePosix = this.fullpathPosix();
        }
        const pv = p20.relativePosix();
        return pv + (!pv || !p20.parent ? "" : "/") + name2;
      }
      /**
       * The fully resolved path string for this Path entry
       */
      fullpath() {
        if (this.#fullpath !== void 0) {
          return this.#fullpath;
        }
        const name2 = this.name;
        const p20 = this.parent;
        if (!p20) {
          return this.#fullpath = this.name;
        }
        const pv = p20.fullpath();
        const fp = pv + (!p20.parent ? "" : this.sep) + name2;
        return this.#fullpath = fp;
      }
      /**
       * On platforms other than windows, this is identical to fullpath.
       *
       * On windows, this is overridden to return the forward-slash form of the
       * full UNC path.
       */
      fullpathPosix() {
        if (this.#fullpathPosix !== void 0)
          return this.#fullpathPosix;
        if (this.sep === "/")
          return this.#fullpathPosix = this.fullpath();
        if (!this.parent) {
          const p21 = this.fullpath().replace(/\\/g, "/");
          if (/^[a-z]:\//i.test(p21)) {
            return this.#fullpathPosix = `//?/${p21}`;
          } else {
            return this.#fullpathPosix = p21;
          }
        }
        const p20 = this.parent;
        const pfpp = p20.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p20.parent ? "" : "/") + this.name;
        return this.#fullpathPosix = fpp;
      }
      /**
       * Is the Path of an unknown type?
       *
       * Note that we might know *something* about it if there has been a previous
       * filesystem operation, for example that it does not exist, or is not a
       * link, or whether it has child entries.
       */
      isUnknown() {
        return (this.#type & IFMT) === UNKNOWN;
      }
      isType(type) {
        return this[`is${type}`]();
      }
      getType() {
        return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
          /* c8 ignore start */
          this.isSocket() ? "Socket" : "Unknown"
        );
      }
      /**
       * Is the Path a regular file?
       */
      isFile() {
        return (this.#type & IFMT) === IFREG;
      }
      /**
       * Is the Path a directory?
       */
      isDirectory() {
        return (this.#type & IFMT) === IFDIR;
      }
      /**
       * Is the path a character device?
       */
      isCharacterDevice() {
        return (this.#type & IFMT) === IFCHR;
      }
      /**
       * Is the path a block device?
       */
      isBlockDevice() {
        return (this.#type & IFMT) === IFBLK;
      }
      /**
       * Is the path a FIFO pipe?
       */
      isFIFO() {
        return (this.#type & IFMT) === IFIFO;
      }
      /**
       * Is the path a socket?
       */
      isSocket() {
        return (this.#type & IFMT) === IFSOCK;
      }
      /**
       * Is the path a symbolic link?
       */
      isSymbolicLink() {
        return (this.#type & IFLNK) === IFLNK;
      }
      /**
       * Return the entry if it has been subject of a successful lstat, or
       * undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* simply
       * mean that we haven't called lstat on it.
       */
      lstatCached() {
        return this.#type & LSTAT_CALLED ? this : void 0;
      }
      /**
       * Return the cached link target if the entry has been the subject of a
       * successful readlink, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readlink() has been called at some point.
       */
      readlinkCached() {
        return this.#linkTarget;
      }
      /**
       * Returns the cached realpath target if the entry has been the subject
       * of a successful realpath, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * realpath() has been called at some point.
       */
      realpathCached() {
        return this.#realpath;
      }
      /**
       * Returns the cached child Path entries array if the entry has been the
       * subject of a successful readdir(), or [] otherwise.
       *
       * Does not read the filesystem, so an empty array *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readdir() has been called recently enough to still be valid.
       */
      readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
      }
      /**
       * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
       * any indication that readlink will definitely fail.
       *
       * Returns false if the path is known to not be a symlink, if a previous
       * readlink failed, or if the entry does not exist.
       */
      canReadlink() {
        if (this.#linkTarget)
          return true;
        if (!this.parent)
          return false;
        const ifmt = this.#type & IFMT;
        return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
      }
      /**
       * Return true if readdir has previously been successfully called on this
       * path, indicating that cachedReaddir() is likely valid.
       */
      calledReaddir() {
        return !!(this.#type & READDIR_CALLED);
      }
      /**
       * Returns true if the path is known to not exist. That is, a previous lstat
       * or readdir failed to verify its existence when that would have been
       * expected, or a parent entry was marked either enoent or enotdir.
       */
      isENOENT() {
        return !!(this.#type & ENOENT);
      }
      /**
       * Return true if the path is a match for the given path name.  This handles
       * case sensitivity and unicode normalization.
       *
       * Note: even on case-sensitive systems, it is **not** safe to test the
       * equality of the `.name` property to determine whether a given pathname
       * matches, due to unicode normalization mismatches.
       *
       * Always use this method instead of testing the `path.name` property
       * directly.
       */
      isNamed(n14) {
        return !this.nocase ? this.#matchName === normalize2(n14) : this.#matchName === normalizeNocase(n14);
      }
      /**
       * Return the Path object corresponding to the target of a symbolic link.
       *
       * If the Path is not a symbolic link, or if the readlink call fails for any
       * reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       */
      async readlink() {
        const target = this.#linkTarget;
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read2 = await this.#fs.promises.readlink(this.fullpath());
          const linkTarget = (await this.parent.realpath())?.resolve(read2);
          if (linkTarget) {
            return this.#linkTarget = linkTarget;
          }
        } catch (er) {
          this.#readlinkFail(er.code);
          return void 0;
        }
      }
      /**
       * Synchronous {@link PathBase.readlink}
       */
      readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read2 = this.#fs.readlinkSync(this.fullpath());
          const linkTarget = this.parent.realpathSync()?.resolve(read2);
          if (linkTarget) {
            return this.#linkTarget = linkTarget;
          }
        } catch (er) {
          this.#readlinkFail(er.code);
          return void 0;
        }
      }
      #readdirSuccess(children) {
        this.#type |= READDIR_CALLED;
        for (let p20 = children.provisional; p20 < children.length; p20++) {
          const c16 = children[p20];
          if (c16)
            c16.#markENOENT();
        }
      }
      #markENOENT() {
        if (this.#type & ENOENT)
          return;
        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
        this.#markChildrenENOENT();
      }
      #markChildrenENOENT() {
        const children = this.children();
        children.provisional = 0;
        for (const p20 of children) {
          p20.#markENOENT();
        }
      }
      #markENOREALPATH() {
        this.#type |= ENOREALPATH;
        this.#markENOTDIR();
      }
      // save the information when we know the entry is not a dir
      #markENOTDIR() {
        if (this.#type & ENOTDIR)
          return;
        let t = this.#type;
        if ((t & IFMT) === IFDIR)
          t &= IFMT_UNKNOWN;
        this.#type = t | ENOTDIR;
        this.#markChildrenENOENT();
      }
      #readdirFail(code = "") {
        if (code === "ENOTDIR" || code === "EPERM") {
          this.#markENOTDIR();
        } else if (code === "ENOENT") {
          this.#markENOENT();
        } else {
          this.children().provisional = 0;
        }
      }
      #lstatFail(code = "") {
        if (code === "ENOTDIR") {
          const p20 = this.parent;
          p20.#markENOTDIR();
        } else if (code === "ENOENT") {
          this.#markENOENT();
        }
      }
      #readlinkFail(code = "") {
        let ter = this.#type;
        ter |= ENOREADLINK;
        if (code === "ENOENT")
          ter |= ENOENT;
        if (code === "EINVAL" || code === "UNKNOWN") {
          ter &= IFMT_UNKNOWN;
        }
        this.#type = ter;
        if (code === "ENOTDIR" && this.parent) {
          this.parent.#markENOTDIR();
        }
      }
      #readdirAddChild(e2, c16) {
        return this.#readdirMaybePromoteChild(e2, c16) || this.#readdirAddNewChild(e2, c16);
      }
      #readdirAddNewChild(e2, c16) {
        const type = entToType(e2);
        const child = this.newChild(e2.name, type, { parent: this });
        const ifmt = child.#type & IFMT;
        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
          child.#type |= ENOTDIR;
        }
        c16.unshift(child);
        c16.provisional++;
        return child;
      }
      #readdirMaybePromoteChild(e2, c16) {
        for (let p20 = c16.provisional; p20 < c16.length; p20++) {
          const pchild = c16[p20];
          const name2 = this.nocase ? normalizeNocase(e2.name) : normalize2(e2.name);
          if (name2 !== pchild.#matchName) {
            continue;
          }
          return this.#readdirPromoteChild(e2, pchild, p20, c16);
        }
      }
      #readdirPromoteChild(e2, p20, index3, c16) {
        const v15 = p20.name;
        p20.#type = p20.#type & IFMT_UNKNOWN | entToType(e2);
        if (v15 !== e2.name)
          p20.name = e2.name;
        if (index3 !== c16.provisional) {
          if (index3 === c16.length - 1)
            c16.pop();
          else
            c16.splice(index3, 1);
          c16.unshift(p20);
        }
        c16.provisional++;
        return p20;
      }
      /**
       * Call lstat() on this Path, and update all known information that can be
       * determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat() {
        if ((this.#type & ENOENT) === 0) {
          try {
            this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
            return this;
          } catch (er) {
            this.#lstatFail(er.code);
          }
        }
      }
      /**
       * synchronous {@link PathBase.lstat}
       */
      lstatSync() {
        if ((this.#type & ENOENT) === 0) {
          try {
            this.#applyStat(this.#fs.lstatSync(this.fullpath()));
            return this;
          } catch (er) {
            this.#lstatFail(er.code);
          }
        }
      }
      #applyStat(st) {
        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode: mode2, mtime, mtimeMs, nlink, rdev, size, uid } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode2;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType(st);
        this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
          this.#type |= ENOTDIR;
        }
      }
      #onReaddirCB = [];
      #readdirCBInFlight = false;
      #callOnReaddirCB(children) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach((cb) => cb(null, children));
      }
      /**
       * Standard node-style callback interface to get list of directory entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       *
       * @param cb The callback called with (er, entries).  Note that the `er`
       * param is somewhat extraneous, as all readdir() errors are handled and
       * simply result in an empty set of entries being returned.
       * @param allowZalgo Boolean indicating that immediately known results should
       * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
       * zalgo at your peril, the dark pony lord is devious and unforgiving.
       */
      readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
          if (allowZalgo)
            cb(null, []);
          else
            queueMicrotask(() => cb(null, []));
          return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
          const c16 = children.slice(0, children.provisional);
          if (allowZalgo)
            cb(null, c16);
          else
            queueMicrotask(() => cb(null, c16));
          return;
        }
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
          return;
        }
        this.#readdirCBInFlight = true;
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
          if (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
          } else {
            for (const e2 of entries) {
              this.#readdirAddChild(e2, children);
            }
            this.#readdirSuccess(children);
          }
          this.#callOnReaddirCB(children.slice(0, children.provisional));
          return;
        });
      }
      #asyncReaddirInFlight;
      /**
       * Return an array of known child entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async readdir() {
        if (!this.canReaddir()) {
          return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
          return children.slice(0, children.provisional);
        }
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
          await this.#asyncReaddirInFlight;
        } else {
          let resolve5 = () => {
          };
          this.#asyncReaddirInFlight = new Promise((res) => resolve5 = res);
          try {
            for (const e2 of await this.#fs.promises.readdir(fullpath, {
              withFileTypes: true
            })) {
              this.#readdirAddChild(e2, children);
            }
            this.#readdirSuccess(children);
          } catch (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
          }
          this.#asyncReaddirInFlight = void 0;
          resolve5();
        }
        return children.slice(0, children.provisional);
      }
      /**
       * synchronous {@link PathBase.readdir}
       */
      readdirSync() {
        if (!this.canReaddir()) {
          return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
          return children.slice(0, children.provisional);
        }
        const fullpath = this.fullpath();
        try {
          for (const e2 of this.#fs.readdirSync(fullpath, {
            withFileTypes: true
          })) {
            this.#readdirAddChild(e2, children);
          }
          this.#readdirSuccess(children);
        } catch (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        }
        return children.slice(0, children.provisional);
      }
      canReaddir() {
        if (this.#type & ENOCHILD)
          return false;
        const ifmt = IFMT & this.#type;
        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
          return false;
        }
        return true;
      }
      shouldWalk(dirs, walkFilter) {
        return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
      }
      /**
       * Return the Path object corresponding to path as resolved
       * by realpath(3).
       *
       * If the realpath call fails for any reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       * On success, returns a Path object.
       */
      async realpath() {
        if (this.#realpath)
          return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
          return void 0;
        try {
          const rp = await this.#fs.promises.realpath(this.fullpath());
          return this.#realpath = this.resolve(rp);
        } catch (_22) {
          this.#markENOREALPATH();
        }
      }
      /**
       * Synchronous {@link realpath}
       */
      realpathSync() {
        if (this.#realpath)
          return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
          return void 0;
        try {
          const rp = this.#fs.realpathSync(this.fullpath());
          return this.#realpath = this.resolve(rp);
        } catch (_22) {
          this.#markENOREALPATH();
        }
      }
      /**
       * Internal method to mark this Path object as the scurry cwd,
       * called by {@link PathScurry#chdir}
       *
       * @internal
       */
      [setAsCwd](oldCwd) {
        if (oldCwd === this)
          return;
        oldCwd.isCWD = false;
        this.isCWD = true;
        const changed = /* @__PURE__ */ new Set([]);
        let rp = [];
        let p20 = this;
        while (p20 && p20.parent) {
          changed.add(p20);
          p20.#relative = rp.join(this.sep);
          p20.#relativePosix = rp.join("/");
          p20 = p20.parent;
          rp.push("..");
        }
        p20 = oldCwd;
        while (p20 && p20.parent && !changed.has(p20)) {
          p20.#relative = void 0;
          p20.#relativePosix = void 0;
          p20 = p20.parent;
        }
      }
    };
    PathWin32 = class _PathWin32 extends PathBase {
      /**
       * Separator for generating path strings.
       */
      sep = "\\";
      /**
       * Separator for parsing path strings.
       */
      splitSep = eitherSep;
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name2, type = UNKNOWN, root3, roots, nocase, children, opts) {
        super(name2, type, root3, roots, nocase, children, opts);
      }
      /**
       * @internal
       */
      newChild(name2, type = UNKNOWN, opts = {}) {
        return new _PathWin32(name2, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
      /**
       * @internal
       */
      getRootString(path7) {
        return win32$1.parse(path7).root;
      }
      /**
       * @internal
       */
      getRoot(rootPath) {
        rootPath = uncToDrive(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
          return this.root;
        }
        for (const [compare2, root3] of Object.entries(this.roots)) {
          if (this.sameRoot(rootPath, compare2)) {
            return this.roots[rootPath] = root3;
          }
        }
        return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
      }
      /**
       * @internal
       */
      sameRoot(rootPath, compare2 = this.root.name) {
        rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
        return rootPath === compare2;
      }
    };
    PathPosix = class _PathPosix extends PathBase {
      /**
       * separator for parsing path strings
       */
      splitSep = "/";
      /**
       * separator for generating path strings
       */
      sep = "/";
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name2, type = UNKNOWN, root3, roots, nocase, children, opts) {
        super(name2, type, root3, roots, nocase, children, opts);
      }
      /**
       * @internal
       */
      getRootString(path7) {
        return path7.startsWith("/") ? "/" : "";
      }
      /**
       * @internal
       */
      getRoot(_rootPath) {
        return this.root;
      }
      /**
       * @internal
       */
      newChild(name2, type = UNKNOWN, opts = {}) {
        return new _PathPosix(name2, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
    };
    PathScurryBase = class {
      /**
       * The root Path entry for the current working directory of this Scurry
       */
      root;
      /**
       * The string path for the root of this Scurry's current working directory
       */
      rootPath;
      /**
       * A collection of all roots encountered, referenced by rootPath
       */
      roots;
      /**
       * The Path entry corresponding to this PathScurry's current working directory.
       */
      cwd;
      #resolveCache;
      #resolvePosixCache;
      #children;
      /**
       * Perform path comparisons case-insensitively.
       *
       * Defaults true on Darwin and Windows systems, false elsewhere.
       */
      nocase;
      #fs;
      /**
       * This class should not be instantiated directly.
       *
       * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
       *
       * @internal
       */
      constructor(cwd = process.cwd(), pathImpl, sep2, { nocase, childrenCacheSize = 16 * 1024, fs: fs5 = defaultFS } = {}) {
        this.#fs = fsFromOption(fs5);
        if (cwd instanceof URL || cwd.startsWith("file://")) {
          cwd = fileURLToPath2(cwd);
        }
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = /* @__PURE__ */ Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache();
        this.#resolvePosixCache = new ResolveCache();
        this.#children = new ChildrenCache(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep2);
        if (split.length === 1 && !split[0]) {
          split.pop();
        }
        if (nocase === void 0) {
          throw new TypeError("must provide nocase setting to PathScurryBase ctor");
        }
        this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
          const l10 = len--;
          prev = prev.child(part, {
            relative: new Array(l10).fill("..").join(joinSep),
            relativePosix: new Array(l10).fill("..").join("/"),
            fullpath: abs += (sawFirst ? "" : joinSep) + part
          });
          sawFirst = true;
        }
        this.cwd = prev;
      }
      /**
       * Get the depth of a provided path, string, or the cwd
       */
      depth(path7 = this.cwd) {
        if (typeof path7 === "string") {
          path7 = this.cwd.resolve(path7);
        }
        return path7.depth();
      }
      /**
       * Return the cache of child entries.  Exposed so subclasses can create
       * child Path objects in a platform-specific way.
       *
       * @internal
       */
      childrenCache() {
        return this.#children;
      }
      /**
       * Resolve one or more path strings to a resolved string
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolve(...paths) {
        let r9 = "";
        for (let i14 = paths.length - 1; i14 >= 0; i14--) {
          const p20 = paths[i14];
          if (!p20 || p20 === ".")
            continue;
          r9 = r9 ? `${p20}/${r9}` : p20;
          if (this.isAbsolute(p20)) {
            break;
          }
        }
        const cached = this.#resolveCache.get(r9);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r9).fullpath();
        this.#resolveCache.set(r9, result);
        return result;
      }
      /**
       * Resolve one or more path strings to a resolved string, returning
       * the posix path.  Identical to .resolve() on posix systems, but on
       * windows will return a forward-slash separated UNC path.
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolvePosix(...paths) {
        let r9 = "";
        for (let i14 = paths.length - 1; i14 >= 0; i14--) {
          const p20 = paths[i14];
          if (!p20 || p20 === ".")
            continue;
          r9 = r9 ? `${p20}/${r9}` : p20;
          if (this.isAbsolute(p20)) {
            break;
          }
        }
        const cached = this.#resolvePosixCache.get(r9);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r9).fullpathPosix();
        this.#resolvePosixCache.set(r9, result);
        return result;
      }
      /**
       * find the relative path from the cwd to the supplied path string or entry
       */
      relative(entry2 = this.cwd) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        }
        return entry2.relative();
      }
      /**
       * find the relative path from the cwd to the supplied path string or
       * entry, using / as the path delimiter, even on Windows.
       */
      relativePosix(entry2 = this.cwd) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        }
        return entry2.relativePosix();
      }
      /**
       * Return the basename for the provided string or Path object
       */
      basename(entry2 = this.cwd) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        }
        return entry2.name;
      }
      /**
       * Return the dirname for the provided string or Path object
       */
      dirname(entry2 = this.cwd) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        }
        return (entry2.parent || entry2).fullpath();
      }
      async readdir(entry2 = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          opts = entry2;
          entry2 = this.cwd;
        }
        const { withFileTypes } = opts;
        if (!entry2.canReaddir()) {
          return [];
        } else {
          const p20 = await entry2.readdir();
          return withFileTypes ? p20 : p20.map((e2) => e2.name);
        }
      }
      readdirSync(entry2 = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          opts = entry2;
          entry2 = this.cwd;
        }
        const { withFileTypes = true } = opts;
        if (!entry2.canReaddir()) {
          return [];
        } else if (withFileTypes) {
          return entry2.readdirSync();
        } else {
          return entry2.readdirSync().map((e2) => e2.name);
        }
      }
      /**
       * Call lstat() on the string or Path object, and update all known
       * information that can be determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat(entry2 = this.cwd) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        }
        return entry2.lstat();
      }
      /**
       * synchronous {@link PathScurryBase.lstat}
       */
      lstatSync(entry2 = this.cwd) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        }
        return entry2.lstatSync();
      }
      async readlink(entry2 = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          withFileTypes = entry2.withFileTypes;
          entry2 = this.cwd;
        }
        const e2 = await entry2.readlink();
        return withFileTypes ? e2 : e2?.fullpath();
      }
      readlinkSync(entry2 = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          withFileTypes = entry2.withFileTypes;
          entry2 = this.cwd;
        }
        const e2 = entry2.readlinkSync();
        return withFileTypes ? e2 : e2?.fullpath();
      }
      async realpath(entry2 = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          withFileTypes = entry2.withFileTypes;
          entry2 = this.cwd;
        }
        const e2 = await entry2.realpath();
        return withFileTypes ? e2 : e2?.fullpath();
      }
      realpathSync(entry2 = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          withFileTypes = entry2.withFileTypes;
          entry2 = this.cwd;
        }
        const e2 = entry2.realpathSync();
        return withFileTypes ? e2 : e2?.fullpath();
      }
      async walk(entry2 = this.cwd, opts = {}) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          opts = entry2;
          entry2 = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
        const results = [];
        if (!filter2 || filter2(entry2)) {
          results.push(withFileTypes ? entry2 : entry2.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const walk3 = (dir, cb) => {
          dirs.add(dir);
          dir.readdirCB((er, entries) => {
            if (er) {
              return cb(er);
            }
            let len = entries.length;
            if (!len)
              return cb();
            const next = () => {
              if (--len === 0) {
                cb();
              }
            };
            for (const e2 of entries) {
              if (!filter2 || filter2(e2)) {
                results.push(withFileTypes ? e2 : e2.fullpath());
              }
              if (follow && e2.isSymbolicLink()) {
                e2.realpath().then((r9) => r9?.isUnknown() ? r9.lstat() : r9).then((r9) => r9?.shouldWalk(dirs, walkFilter) ? walk3(r9, next) : next());
              } else {
                if (e2.shouldWalk(dirs, walkFilter)) {
                  walk3(e2, next);
                } else {
                  next();
                }
              }
            }
          }, true);
        };
        const start2 = entry2;
        return new Promise((res, rej) => {
          walk3(start2, (er) => {
            if (er)
              return rej(er);
            res(results);
          });
        });
      }
      walkSync(entry2 = this.cwd, opts = {}) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          opts = entry2;
          entry2 = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
        const results = [];
        if (!filter2 || filter2(entry2)) {
          results.push(withFileTypes ? entry2 : entry2.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set([entry2]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e2 of entries) {
            if (!filter2 || filter2(e2)) {
              results.push(withFileTypes ? e2 : e2.fullpath());
            }
            let r9 = e2;
            if (e2.isSymbolicLink()) {
              if (!(follow && (r9 = e2.realpathSync())))
                continue;
              if (r9.isUnknown())
                r9.lstatSync();
            }
            if (r9.shouldWalk(dirs, walkFilter)) {
              dirs.add(r9);
            }
          }
        }
        return results;
      }
      /**
       * Support for `for await`
       *
       * Alias for {@link PathScurryBase.iterate}
       *
       * Note: As of Node 19, this is very slow, compared to other methods of
       * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
       * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
       */
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
      iterate(entry2 = this.cwd, options2 = {}) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          options2 = entry2;
          entry2 = this.cwd;
        }
        return this.stream(entry2, options2)[Symbol.asyncIterator]();
      }
      /**
       * Iterating over a PathScurry performs a synchronous walk.
       *
       * Alias for {@link PathScurryBase.iterateSync}
       */
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      *iterateSync(entry2 = this.cwd, opts = {}) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          opts = entry2;
          entry2 = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
        if (!filter2 || filter2(entry2)) {
          yield withFileTypes ? entry2 : entry2.fullpath();
        }
        const dirs = /* @__PURE__ */ new Set([entry2]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e2 of entries) {
            if (!filter2 || filter2(e2)) {
              yield withFileTypes ? e2 : e2.fullpath();
            }
            let r9 = e2;
            if (e2.isSymbolicLink()) {
              if (!(follow && (r9 = e2.realpathSync())))
                continue;
              if (r9.isUnknown())
                r9.lstatSync();
            }
            if (r9.shouldWalk(dirs, walkFilter)) {
              dirs.add(r9);
            }
          }
        }
      }
      stream(entry2 = this.cwd, opts = {}) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          opts = entry2;
          entry2 = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
        const results = new Minipass({ objectMode: true });
        if (!filter2 || filter2(entry2)) {
          results.write(withFileTypes ? entry2 : entry2.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const queue2 = [entry2];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue2.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const onReaddir = (er, entries, didRealpaths = false) => {
              if (er)
                return results.emit("error", er);
              if (follow && !didRealpaths) {
                const promises2 = [];
                for (const e2 of entries) {
                  if (e2.isSymbolicLink()) {
                    promises2.push(e2.realpath().then((r9) => r9?.isUnknown() ? r9.lstat() : r9));
                  }
                }
                if (promises2.length) {
                  Promise.all(promises2).then(() => onReaddir(null, entries, true));
                  return;
                }
              }
              for (const e2 of entries) {
                if (e2 && (!filter2 || filter2(e2))) {
                  if (!results.write(withFileTypes ? e2 : e2.fullpath())) {
                    paused = true;
                  }
                }
              }
              processing--;
              for (const e2 of entries) {
                const r9 = e2.realpathCached() || e2;
                if (r9.shouldWalk(dirs, walkFilter)) {
                  queue2.push(r9);
                }
              }
              if (paused && !results.flowing) {
                results.once("drain", process2);
              } else if (!sync2) {
                process2();
              }
            };
            let sync2 = true;
            dir.readdirCB(onReaddir, true);
            sync2 = false;
          }
        };
        process2();
        return results;
      }
      streamSync(entry2 = this.cwd, opts = {}) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          opts = entry2;
          entry2 = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
        const results = new Minipass({ objectMode: true });
        const dirs = /* @__PURE__ */ new Set();
        if (!filter2 || filter2(entry2)) {
          results.write(withFileTypes ? entry2 : entry2.fullpath());
        }
        const queue2 = [entry2];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue2.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const entries = dir.readdirSync();
            for (const e2 of entries) {
              if (!filter2 || filter2(e2)) {
                if (!results.write(withFileTypes ? e2 : e2.fullpath())) {
                  paused = true;
                }
              }
            }
            processing--;
            for (const e2 of entries) {
              let r9 = e2;
              if (e2.isSymbolicLink()) {
                if (!(follow && (r9 = e2.realpathSync())))
                  continue;
                if (r9.isUnknown())
                  r9.lstatSync();
              }
              if (r9.shouldWalk(dirs, walkFilter)) {
                queue2.push(r9);
              }
            }
          }
          if (paused && !results.flowing)
            results.once("drain", process2);
        };
        process2();
        return results;
      }
      chdir(path7 = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path7 === "string" ? this.cwd.resolve(path7) : path7;
        this.cwd[setAsCwd](oldCwd);
      }
    };
    PathScurryWin32 = class extends PathScurryBase {
      /**
       * separator for generating path strings
       */
      sep = "\\";
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, win32$1, "\\", { ...opts, nocase });
        this.nocase = nocase;
        for (let p20 = this.cwd; p20; p20 = p20.parent) {
          p20.nocase = this.nocase;
        }
      }
      /**
       * @internal
       */
      parseRootPath(dir) {
        return win32$1.parse(dir).root.toUpperCase();
      }
      /**
       * @internal
       */
      newRoot(fs5) {
        return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs5 });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p20) {
        return p20.startsWith("/") || p20.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p20);
      }
    };
    PathScurryPosix = class extends PathScurryBase {
      /**
       * separator for generating path strings
       */
      sep = "/";
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd, posix$1, "/", { ...opts, nocase });
        this.nocase = nocase;
      }
      /**
       * @internal
       */
      parseRootPath(_dir) {
        return "/";
      }
      /**
       * @internal
       */
      newRoot(fs5) {
        return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs5 });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p20) {
        return p20.startsWith("/");
      }
    };
    PathScurryDarwin = class extends PathScurryPosix {
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, { ...opts, nocase });
      }
    };
    process.platform === "win32" ? PathWin32 : PathPosix;
    PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;
    isPatternList = (pl) => pl.length >= 1;
    isGlobList = (gl) => gl.length >= 1;
    Pattern = class _Pattern {
      #patternList;
      #globList;
      #index;
      length;
      #platform;
      #rest;
      #globString;
      #isDrive;
      #isUNC;
      #isAbsolute;
      #followGlobstar = true;
      constructor(patternList, globList, index3, platform2) {
        if (!isPatternList(patternList)) {
          throw new TypeError("empty pattern list");
        }
        if (!isGlobList(globList)) {
          throw new TypeError("empty glob list");
        }
        if (globList.length !== patternList.length) {
          throw new TypeError("mismatched pattern list and glob list lengths");
        }
        this.length = patternList.length;
        if (index3 < 0 || index3 >= this.length) {
          throw new TypeError("index out of range");
        }
        this.#patternList = patternList;
        this.#globList = globList;
        this.#index = index3;
        this.#platform = platform2;
        if (this.#index === 0) {
          if (this.isUNC()) {
            const [p0, p1, p22, p32, ...prest] = this.#patternList;
            const [g0, g1, g22, g32, ...grest] = this.#globList;
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p20 = [p0, p1, p22, p32, ""].join("/");
            const g16 = [g0, g1, g22, g32, ""].join("/");
            this.#patternList = [p20, ...prest];
            this.#globList = [g16, ...grest];
            this.length = this.#patternList.length;
          } else if (this.isDrive() || this.isAbsolute()) {
            const [p1, ...prest] = this.#patternList;
            const [g1, ...grest] = this.#globList;
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p20 = p1 + "/";
            const g16 = g1 + "/";
            this.#patternList = [p20, ...prest];
            this.#globList = [g16, ...grest];
            this.length = this.#patternList.length;
          }
        }
      }
      /**
       * The first entry in the parsed list of patterns
       */
      pattern() {
        return this.#patternList[this.#index];
      }
      /**
       * true of if pattern() returns a string
       */
      isString() {
        return typeof this.#patternList[this.#index] === "string";
      }
      /**
       * true of if pattern() returns GLOBSTAR
       */
      isGlobstar() {
        return this.#patternList[this.#index] === GLOBSTAR$2;
      }
      /**
       * true if pattern() returns a regexp
       */
      isRegExp() {
        return this.#patternList[this.#index] instanceof RegExp;
      }
      /**
       * The /-joined set of glob parts that make up this pattern
       */
      globString() {
        return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
      }
      /**
       * true if there are more pattern parts after this one
       */
      hasMore() {
        return this.length > this.#index + 1;
      }
      /**
       * The rest of the pattern after this part, or null if this is the end
       */
      rest() {
        if (this.#rest !== void 0)
          return this.#rest;
        if (!this.hasMore())
          return this.#rest = null;
        this.#rest = new _Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
        this.#rest.#isAbsolute = this.#isAbsolute;
        this.#rest.#isUNC = this.#isUNC;
        this.#rest.#isDrive = this.#isDrive;
        return this.#rest;
      }
      /**
       * true if the pattern represents a //unc/path/ on windows
       */
      isUNC() {
        const pl = this.#patternList;
        return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
      }
      // pattern like C:/...
      // split = ['C:', ...]
      // XXX: would be nice to handle patterns like `c:*` to test the cwd
      // in c: for *, but I don't know of a way to even figure out what that
      // cwd is without actually chdir'ing into it?
      /**
       * True if the pattern starts with a drive letter on Windows
       */
      isDrive() {
        const pl = this.#patternList;
        return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
      }
      // pattern = '/' or '/...' or '/x/...'
      // split = ['', ''] or ['', ...] or ['', 'x', ...]
      // Drive and UNC both considered absolute on windows
      /**
       * True if the pattern is rooted on an absolute path
       */
      isAbsolute() {
        const pl = this.#patternList;
        return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
      }
      /**
       * consume the root of the pattern, and return it
       */
      root() {
        const p20 = this.#patternList[0];
        return typeof p20 === "string" && this.isAbsolute() && this.#index === 0 ? p20 : "";
      }
      /**
       * Check to see if the current globstar pattern is allowed to follow
       * a symbolic link.
       */
      checkFollowGlobstar() {
        return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
      }
      /**
       * Mark that the current globstar pattern is following a symbolic link
       */
      markFollowGlobstar() {
        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
          return false;
        this.#followGlobstar = false;
        return true;
      }
    };
    defaultPlatform$1 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    Ignore = class {
      relative;
      relativeChildren;
      absolute;
      absoluteChildren;
      platform;
      mmopts;
      constructor(ignored, { nobrace, nocase, noext, noglobstar, platform: platform2 = defaultPlatform$1 }) {
        this.relative = [];
        this.absolute = [];
        this.relativeChildren = [];
        this.absoluteChildren = [];
        this.platform = platform2;
        this.mmopts = {
          dot: true,
          nobrace,
          nocase,
          noext,
          noglobstar,
          optimizationLevel: 2,
          platform: platform2,
          nocomment: true,
          nonegate: true
        };
        for (const ign of ignored)
          this.add(ign);
      }
      add(ign) {
        const mm = new Minimatch(ign, this.mmopts);
        for (let i14 = 0; i14 < mm.set.length; i14++) {
          const parsed = mm.set[i14];
          const globParts = mm.globParts[i14];
          if (!parsed || !globParts) {
            throw new Error("invalid pattern object");
          }
          while (parsed[0] === "." && globParts[0] === ".") {
            parsed.shift();
            globParts.shift();
          }
          const p20 = new Pattern(parsed, globParts, 0, this.platform);
          const m23 = new Minimatch(p20.globString(), this.mmopts);
          const children = globParts[globParts.length - 1] === "**";
          const absolute = p20.isAbsolute();
          if (absolute)
            this.absolute.push(m23);
          else
            this.relative.push(m23);
          if (children) {
            if (absolute)
              this.absoluteChildren.push(m23);
            else
              this.relativeChildren.push(m23);
          }
        }
      }
      ignored(p20) {
        const fullpath = p20.fullpath();
        const fullpaths = `${fullpath}/`;
        const relative3 = p20.relative() || ".";
        const relatives = `${relative3}/`;
        for (const m23 of this.relative) {
          if (m23.match(relative3) || m23.match(relatives))
            return true;
        }
        for (const m23 of this.absolute) {
          if (m23.match(fullpath) || m23.match(fullpaths))
            return true;
        }
        return false;
      }
      childrenIgnored(p20) {
        const fullpath = p20.fullpath() + "/";
        const relative3 = (p20.relative() || ".") + "/";
        for (const m23 of this.relativeChildren) {
          if (m23.match(relative3))
            return true;
        }
        for (const m23 of this.absoluteChildren) {
          if (m23.match(fullpath))
            return true;
        }
        return false;
      }
    };
    HasWalkedCache = class _HasWalkedCache {
      store;
      constructor(store = /* @__PURE__ */ new Map()) {
        this.store = store;
      }
      copy() {
        return new _HasWalkedCache(new Map(this.store));
      }
      hasWalked(target, pattern2) {
        return this.store.get(target.fullpath())?.has(pattern2.globString());
      }
      storeWalked(target, pattern2) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
          cached.add(pattern2.globString());
        else
          this.store.set(fullpath, /* @__PURE__ */ new Set([pattern2.globString()]));
      }
    };
    MatchRecord = class {
      store = /* @__PURE__ */ new Map();
      add(target, absolute, ifDir) {
        const n14 = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === void 0 ? n14 : n14 & current);
      }
      // match, absolute, ifdir
      entries() {
        return [...this.store.entries()].map(([path7, n14]) => [
          path7,
          !!(n14 & 2),
          !!(n14 & 1)
        ]);
      }
    };
    SubWalks = class {
      store = /* @__PURE__ */ new Map();
      add(target, pattern2) {
        if (!target.canReaddir()) {
          return;
        }
        const subs = this.store.get(target);
        if (subs) {
          if (!subs.find((p20) => p20.globString() === pattern2.globString())) {
            subs.push(pattern2);
          }
        } else
          this.store.set(target, [pattern2]);
      }
      get(target) {
        const subs = this.store.get(target);
        if (!subs) {
          throw new Error("attempting to walk unknown path");
        }
        return subs;
      }
      entries() {
        return this.keys().map((k13) => [k13, this.store.get(k13)]);
      }
      keys() {
        return [...this.store.keys()].filter((t) => t.canReaddir());
      }
    };
    Processor = class _Processor {
      hasWalkedCache;
      matches = new MatchRecord();
      subwalks = new SubWalks();
      patterns;
      follow;
      dot;
      opts;
      constructor(opts, hasWalkedCache) {
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
      }
      processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map((p20) => [target, p20]);
        for (let [t, pattern2] of processingSet) {
          this.hasWalkedCache.storeWalked(t, pattern2);
          const root3 = pattern2.root();
          const absolute = pattern2.isAbsolute() && this.opts.absolute !== false;
          if (root3) {
            t = t.resolve(root3 === "/" && this.opts.root !== void 0 ? this.opts.root : root3);
            const rest2 = pattern2.rest();
            if (!rest2) {
              this.matches.add(t, true, false);
              continue;
            } else {
              pattern2 = rest2;
            }
          }
          if (t.isENOENT())
            continue;
          let p20;
          let rest;
          let changed = false;
          while (typeof (p20 = pattern2.pattern()) === "string" && (rest = pattern2.rest())) {
            const c16 = t.resolve(p20);
            t = c16;
            pattern2 = rest;
            changed = true;
          }
          p20 = pattern2.pattern();
          rest = pattern2.rest();
          if (changed) {
            if (this.hasWalkedCache.hasWalked(t, pattern2))
              continue;
            this.hasWalkedCache.storeWalked(t, pattern2);
          }
          if (typeof p20 === "string") {
            const ifDir = p20 === ".." || p20 === "" || p20 === ".";
            this.matches.add(t.resolve(p20), absolute, ifDir);
            continue;
          } else if (p20 === GLOBSTAR$2) {
            if (!t.isSymbolicLink() || this.follow || pattern2.checkFollowGlobstar()) {
              this.subwalks.add(t, pattern2);
            }
            const rp = rest?.pattern();
            const rrest = rest?.rest();
            if (!rest || (rp === "" || rp === ".") && !rrest) {
              this.matches.add(t, absolute, rp === "" || rp === ".");
            } else {
              if (rp === "..") {
                const tp = t.parent || t;
                if (!rrest)
                  this.matches.add(tp, absolute, true);
                else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                  this.subwalks.add(tp, rrest);
                }
              }
            }
          } else if (p20 instanceof RegExp) {
            this.subwalks.add(t, pattern2);
          }
        }
        return this;
      }
      subwalkTargets() {
        return this.subwalks.keys();
      }
      child() {
        return new _Processor(this.opts, this.hasWalkedCache);
      }
      // return a new Processor containing the subwalks for each
      // child entry, and a set of matches, and
      // a hasWalkedCache that's a copy of this one
      // then we're going to call
      filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        const results = this.child();
        for (const e2 of entries) {
          for (const pattern2 of patterns) {
            const absolute = pattern2.isAbsolute();
            const p20 = pattern2.pattern();
            const rest = pattern2.rest();
            if (p20 === GLOBSTAR$2) {
              results.testGlobstar(e2, pattern2, rest, absolute);
            } else if (p20 instanceof RegExp) {
              results.testRegExp(e2, p20, rest, absolute);
            } else {
              results.testString(e2, p20, rest, absolute);
            }
          }
        }
        return results;
      }
      testGlobstar(e2, pattern2, rest, absolute) {
        if (this.dot || !e2.name.startsWith(".")) {
          if (!pattern2.hasMore()) {
            this.matches.add(e2, absolute, false);
          }
          if (e2.canReaddir()) {
            if (this.follow || !e2.isSymbolicLink()) {
              this.subwalks.add(e2, pattern2);
            } else if (e2.isSymbolicLink()) {
              if (rest && pattern2.checkFollowGlobstar()) {
                this.subwalks.add(e2, rest);
              } else if (pattern2.markFollowGlobstar()) {
                this.subwalks.add(e2, pattern2);
              }
            }
          }
        }
        if (rest) {
          const rp = rest.pattern();
          if (typeof rp === "string" && // dots and empty were handled already
          rp !== ".." && rp !== "" && rp !== ".") {
            this.testString(e2, rp, rest.rest(), absolute);
          } else if (rp === "..") {
            const ep = e2.parent || e2;
            this.subwalks.add(ep, rest);
          } else if (rp instanceof RegExp) {
            this.testRegExp(e2, rp, rest.rest(), absolute);
          }
        }
      }
      testRegExp(e2, p20, rest, absolute) {
        if (!p20.test(e2.name))
          return;
        if (!rest) {
          this.matches.add(e2, absolute, false);
        } else {
          this.subwalks.add(e2, rest);
        }
      }
      testString(e2, p20, rest, absolute) {
        if (!e2.isNamed(p20))
          return;
        if (!rest) {
          this.matches.add(e2, absolute, false);
        } else {
          this.subwalks.add(e2, rest);
        }
      }
    };
    makeIgnore = (ignore, opts) => typeof ignore === "string" ? new Ignore([ignore], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore;
    GlobUtil = class {
      path;
      patterns;
      opts;
      seen = /* @__PURE__ */ new Set();
      paused = false;
      aborted = false;
      #onResume = [];
      #ignore;
      #sep;
      signal;
      maxDepth;
      includeChildMatches;
      constructor(patterns, path7, opts) {
        this.patterns = patterns;
        this.path = path7;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
        this.includeChildMatches = opts.includeChildMatches !== false;
        if (opts.ignore || !this.includeChildMatches) {
          this.#ignore = makeIgnore(opts.ignore ?? [], opts);
          if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
            const m23 = "cannot ignore child matches, ignore lacks add() method.";
            throw new Error(m23);
          }
        }
        this.maxDepth = opts.maxDepth || Infinity;
        if (opts.signal) {
          this.signal = opts.signal;
          this.signal.addEventListener("abort", () => {
            this.#onResume.length = 0;
          });
        }
      }
      #ignored(path7) {
        return this.seen.has(path7) || !!this.#ignore?.ignored?.(path7);
      }
      #childrenIgnored(path7) {
        return !!this.#ignore?.childrenIgnored?.(path7);
      }
      // backpressure mechanism
      pause() {
        this.paused = true;
      }
      resume() {
        if (this.signal?.aborted)
          return;
        this.paused = false;
        let fn = void 0;
        while (!this.paused && (fn = this.#onResume.shift())) {
          fn();
        }
      }
      onResume(fn) {
        if (this.signal?.aborted)
          return;
        if (!this.paused) {
          fn();
        } else {
          this.#onResume.push(fn);
        }
      }
      // do the requisite realpath/stat checking, and return the path
      // to add or undefined to filter it out.
      async matchCheck(e2, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e2.realpathCached() || await e2.realpath();
          if (!rpc)
            return void 0;
          e2 = rpc;
        }
        const needStat = e2.isUnknown() || this.opts.stat;
        const s12 = needStat ? await e2.lstat() : e2;
        if (this.opts.follow && this.opts.nodir && s12?.isSymbolicLink()) {
          const target = await s12.realpath();
          if (target && (target.isUnknown() || this.opts.stat)) {
            await target.lstat();
          }
        }
        return this.matchCheckTest(s12, ifDir);
      }
      matchCheckTest(e2, ifDir) {
        return e2 && (this.maxDepth === Infinity || e2.depth() <= this.maxDepth) && (!ifDir || e2.canReaddir()) && (!this.opts.nodir || !e2.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e2.isSymbolicLink() || !e2.realpathCached()?.isDirectory()) && !this.#ignored(e2) ? e2 : void 0;
      }
      matchCheckSync(e2, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e2.realpathCached() || e2.realpathSync();
          if (!rpc)
            return void 0;
          e2 = rpc;
        }
        const needStat = e2.isUnknown() || this.opts.stat;
        const s12 = needStat ? e2.lstatSync() : e2;
        if (this.opts.follow && this.opts.nodir && s12?.isSymbolicLink()) {
          const target = s12.realpathSync();
          if (target && (target?.isUnknown() || this.opts.stat)) {
            target.lstatSync();
          }
        }
        return this.matchCheckTest(s12, ifDir);
      }
      matchFinish(e2, absolute) {
        if (this.#ignored(e2))
          return;
        if (!this.includeChildMatches && this.#ignore?.add) {
          const ign = `${e2.relativePosix()}/**`;
          this.#ignore.add(ign);
        }
        const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
        this.seen.add(e2);
        const mark = this.opts.mark && e2.isDirectory() ? this.#sep : "";
        if (this.opts.withFileTypes) {
          this.matchEmit(e2);
        } else if (abs) {
          const abs2 = this.opts.posix ? e2.fullpathPosix() : e2.fullpath();
          this.matchEmit(abs2 + mark);
        } else {
          const rel = this.opts.posix ? e2.relativePosix() : e2.relative();
          const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
          this.matchEmit(!rel ? "." + mark : pre + rel + mark);
        }
      }
      async match(e2, absolute, ifDir) {
        const p20 = await this.matchCheck(e2, ifDir);
        if (p20)
          this.matchFinish(p20, absolute);
      }
      matchSync(e2, absolute, ifDir) {
        const p20 = this.matchCheckSync(e2, ifDir);
        if (p20)
          this.matchFinish(p20, absolute);
      }
      walkCB(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2(target, patterns, new Processor(this.opts), cb);
      }
      walkCB2(target, patterns, processor2, cb) {
        if (this.#childrenIgnored(target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2(target, patterns, processor2, cb));
          return;
        }
        processor2.processPatterns(target, patterns);
        let tasks2 = 1;
        const next = () => {
          if (--tasks2 === 0)
            cb();
        };
        for (const [m23, absolute, ifDir] of processor2.matches.entries()) {
          if (this.#ignored(m23))
            continue;
          tasks2++;
          this.match(m23, absolute, ifDir).then(() => next());
        }
        for (const t of processor2.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks2++;
          const childrenCached = t.readdirCached();
          if (t.calledReaddir())
            this.walkCB3(t, childrenCached, processor2, next);
          else {
            t.readdirCB((_22, entries) => this.walkCB3(t, entries, processor2, next), true);
          }
        }
        next();
      }
      walkCB3(target, entries, processor2, cb) {
        processor2 = processor2.filterEntries(target, entries);
        let tasks2 = 1;
        const next = () => {
          if (--tasks2 === 0)
            cb();
        };
        for (const [m23, absolute, ifDir] of processor2.matches.entries()) {
          if (this.#ignored(m23))
            continue;
          tasks2++;
          this.match(m23, absolute, ifDir).then(() => next());
        }
        for (const [target2, patterns] of processor2.subwalks.entries()) {
          tasks2++;
          this.walkCB2(target2, patterns, processor2.child(), next);
        }
        next();
      }
      walkCBSync(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
      }
      walkCB2Sync(target, patterns, processor2, cb) {
        if (this.#childrenIgnored(target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2Sync(target, patterns, processor2, cb));
          return;
        }
        processor2.processPatterns(target, patterns);
        let tasks2 = 1;
        const next = () => {
          if (--tasks2 === 0)
            cb();
        };
        for (const [m23, absolute, ifDir] of processor2.matches.entries()) {
          if (this.#ignored(m23))
            continue;
          this.matchSync(m23, absolute, ifDir);
        }
        for (const t of processor2.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks2++;
          const children = t.readdirSync();
          this.walkCB3Sync(t, children, processor2, next);
        }
        next();
      }
      walkCB3Sync(target, entries, processor2, cb) {
        processor2 = processor2.filterEntries(target, entries);
        let tasks2 = 1;
        const next = () => {
          if (--tasks2 === 0)
            cb();
        };
        for (const [m23, absolute, ifDir] of processor2.matches.entries()) {
          if (this.#ignored(m23))
            continue;
          this.matchSync(m23, absolute, ifDir);
        }
        for (const [target2, patterns] of processor2.subwalks.entries()) {
          tasks2++;
          this.walkCB2Sync(target2, patterns, processor2.child(), next);
        }
        next();
      }
    };
    GlobWalker = class extends GlobUtil {
      matches = /* @__PURE__ */ new Set();
      constructor(patterns, path7, opts) {
        super(patterns, path7, opts);
      }
      matchEmit(e2) {
        this.matches.add(e2);
      }
      async walk() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          await this.path.lstat();
        }
        await new Promise((res, rej) => {
          this.walkCB(this.path, this.patterns, () => {
            if (this.signal?.aborted) {
              rej(this.signal.reason);
            } else {
              res(this.matches);
            }
          });
        });
        return this.matches;
      }
      walkSync() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => {
          if (this.signal?.aborted)
            throw this.signal.reason;
        });
        return this.matches;
      }
    };
    GlobStream = class extends GlobUtil {
      results;
      constructor(patterns, path7, opts) {
        super(patterns, path7, opts);
        this.results = new Minipass({
          signal: this.signal,
          objectMode: true
        });
        this.results.on("drain", () => this.resume());
        this.results.on("resume", () => this.resume());
      }
      matchEmit(e2) {
        this.results.write(e2);
        if (!this.results.flowing)
          this.pause();
      }
      stream() {
        const target = this.path;
        if (target.isUnknown()) {
          target.lstat().then(() => {
            this.walkCB(target, this.patterns, () => this.results.end());
          });
        } else {
          this.walkCB(target, this.patterns, () => this.results.end());
        }
        return this.results;
      }
      streamSync() {
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => this.results.end());
        return this.results;
      }
    };
    defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    Glob = class {
      absolute;
      cwd;
      root;
      dot;
      dotRelative;
      follow;
      ignore;
      magicalBraces;
      mark;
      matchBase;
      maxDepth;
      nobrace;
      nocase;
      nodir;
      noext;
      noglobstar;
      pattern;
      platform;
      realpath;
      scurry;
      stat;
      signal;
      windowsPathsNoEscape;
      withFileTypes;
      includeChildMatches;
      /**
       * The options provided to the constructor.
       */
      opts;
      /**
       * An array of parsed immutable {@link Pattern} objects.
       */
      patterns;
      /**
       * All options are stored as properties on the `Glob` object.
       *
       * See {@link GlobOptions} for full options descriptions.
       *
       * Note that a previous `Glob` object can be passed as the
       * `GlobOptions` to another `Glob` instantiation to re-use settings
       * and caches with a new pattern.
       *
       * Traversal functions can be called multiple times to run the walk
       * again.
       */
      constructor(pattern2, opts) {
        if (!opts)
          throw new TypeError("glob options required");
        this.withFileTypes = !!opts.withFileTypes;
        this.signal = opts.signal;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.dotRelative = !!opts.dotRelative;
        this.nodir = !!opts.nodir;
        this.mark = !!opts.mark;
        if (!opts.cwd) {
          this.cwd = "";
        } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
          opts.cwd = fileURLToPath2(opts.cwd);
        }
        this.cwd = opts.cwd || "";
        this.root = opts.root;
        this.magicalBraces = !!opts.magicalBraces;
        this.nobrace = !!opts.nobrace;
        this.noext = !!opts.noext;
        this.realpath = !!opts.realpath;
        this.absolute = opts.absolute;
        this.includeChildMatches = opts.includeChildMatches !== false;
        this.noglobstar = !!opts.noglobstar;
        this.matchBase = !!opts.matchBase;
        this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
        this.stat = !!opts.stat;
        this.ignore = opts.ignore;
        if (this.withFileTypes && this.absolute !== void 0) {
          throw new Error("cannot set absolute and withFileTypes:true");
        }
        if (typeof pattern2 === "string") {
          pattern2 = [pattern2];
        }
        this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          pattern2 = pattern2.map((p20) => p20.replace(/\\/g, "/"));
        }
        if (this.matchBase) {
          if (opts.noglobstar) {
            throw new TypeError("base matching requires globstar");
          }
          pattern2 = pattern2.map((p20) => p20.includes("/") ? p20 : `./**/${p20}`);
        }
        this.pattern = pattern2;
        this.platform = opts.platform || defaultPlatform;
        this.opts = { ...opts, platform: this.platform };
        if (opts.scurry) {
          this.scurry = opts.scurry;
          if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
            throw new Error("nocase option contradicts provided scurry option");
          }
        } else {
          const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
          this.scurry = new Scurry(this.cwd, {
            nocase: opts.nocase,
            fs: opts.fs
          });
        }
        this.nocase = this.scurry.nocase;
        const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
        const mmo = {
          // default nocase based on platform
          ...opts,
          dot: this.dot,
          matchBase: this.matchBase,
          nobrace: this.nobrace,
          nocase: this.nocase,
          nocaseMagicOnly,
          nocomment: true,
          noext: this.noext,
          nonegate: true,
          optimizationLevel: 2,
          platform: this.platform,
          windowsPathsNoEscape: this.windowsPathsNoEscape,
          debug: !!this.opts.debug
        };
        const mms = this.pattern.map((p20) => new Minimatch(p20, mmo));
        const [matchSet, globParts] = mms.reduce((set2, m23) => {
          set2[0].push(...m23.set);
          set2[1].push(...m23.globParts);
          return set2;
        }, [[], []]);
        this.patterns = matchSet.map((set2, i14) => {
          const g16 = globParts[i14];
          if (!g16)
            throw new Error("invalid pattern object");
          return new Pattern(set2, g16, 0, this.platform);
        });
      }
      async walk() {
        return [
          ...await new GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches
          }).walk()
        ];
      }
      walkSync() {
        return [
          ...new GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches
          }).walkSync()
        ];
      }
      stream() {
        return new GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).stream();
      }
      streamSync() {
        return new GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).streamSync();
      }
      /**
       * Default sync iteration function. Returns a Generator that
       * iterates over the results.
       */
      iterateSync() {
        return this.streamSync()[Symbol.iterator]();
      }
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      /**
       * Default async iteration function. Returns an AsyncGenerator that
       * iterates over the results.
       */
      iterate() {
        return this.stream()[Symbol.asyncIterator]();
      }
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
    };
    hasMagic = (pattern2, options2 = {}) => {
      if (!Array.isArray(pattern2)) {
        pattern2 = [pattern2];
      }
      for (const p20 of pattern2) {
        if (new Minimatch(p20, options2).hasMagic())
          return true;
      }
      return false;
    };
    streamSync = globStreamSync;
    stream$5 = Object.assign(globStream, { sync: globStreamSync });
    iterateSync = globIterateSync;
    iterate = Object.assign(globIterate, {
      sync: globIterateSync
    });
    sync$9 = Object.assign(globSync, {
      stream: globStreamSync,
      iterate: globIterateSync
    });
    glob$1 = Object.assign(glob_, {
      glob: glob_,
      globSync,
      sync: sync$9,
      globStream,
      stream: stream$5,
      globStreamSync,
      streamSync,
      globIterate,
      iterate,
      globIterateSync,
      iterateSync,
      Glob,
      hasMagic,
      escape: escape$2,
      unescape: unescape$1
    });
    glob$1.glob = glob$1;
    comma3 = ",".charCodeAt(0);
    semicolon2 = ";".charCodeAt(0);
    chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    intToChar = new Uint8Array(64);
    charToInt = new Uint8Array(128);
    for (let i14 = 0; i14 < chars$1.length; i14++) {
      const c16 = chars$1.charCodeAt(i14);
      intToChar[i14] = c16;
      charToInt[c16] = i14;
    }
    bufLength = 1024 * 16;
    src$32 = { exports: {} };
    browser$3 = { exports: {} };
    node$12 = { exports: {} };
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      src$32.exports = requireBrowser$1();
    } else {
      src$32.exports = requireNode$1();
    }
    srcExports$12 = src$32.exports;
    debug$i = /* @__PURE__ */ getDefaultExportFromCjs(srcExports$12);
    if (process.versions.pnp) {
      try {
        pnp = createRequire$1(import.meta.url)("pnpapi");
      } catch {
      }
    }
    nodeBuiltins = builtinModules.filter((id3) => !id3.includes(":"));
    _require$1 = createRequire$1(import.meta.url);
    rollupVersion = resolveDependencyVersion("rollup");
    filter = process.env.VITE_DEBUG_FILTER;
    DEBUG = process.env.DEBUG;
    urlCanParse = // eslint-disable-next-line n/no-unsupported-features/node-builtins
    URL$3.canParse ?? // URL.canParse is supported from Node.js 18.17.0+, 20.0.0+
    ((path22, base) => {
      try {
        new URL$3(path22, base);
        return true;
      } catch {
        return false;
      }
    });
    isCaseInsensitiveFS = testCaseInsensitiveFS();
    externalRE = /^(https?:)?\/\//;
    isExternalUrl = (url2) => externalRE.test(url2);
    dataUrlRE = /^\s*data:/i;
    isDataUrl = (url2) => dataUrlRE.test(url2);
    internalPrefixes = [
      FS_PREFIX,
      VALID_ID_PREFIX,
      CLIENT_PUBLIC_PATH,
      ENV_PUBLIC_PATH
    ];
    InternalPrefixRE = new RegExp(`^(?:${internalPrefixes.join("|")})`);
    safeRealpathSync = isWindows$3 ? windowsSafeRealPathSync : fs__default.realpathSync.native;
    windowsNetworkMap = /* @__PURE__ */ new Map();
    parseNetUseRE = /^\w* +(\w:) +([^ ]+)\s/;
    firstSafeRealPathSyncRun = false;
    escapedSpaceCharacters = /(?: |\\t|\\n|\\f|\\r)+/g;
    imageSetUrlRE = /^(?:[\w\-]+\(.*?\)|'.*?'|".*?"|\S*)/;
    cleanSrcSetRE = /(?:url|image|gradient|cross-fade)\([^)]*\)|"([^"]|(?<=\\)")*"|'([^']|(?<=\\)')*'|data:\w+\/[\w.+\-]+;base64,[\w+/=]+|\?\S+,/g;
    blankReplacer = (match2) => " ".repeat(match2.length);
    _dirname = path$n.dirname(fileURLToPath2(import.meta.url));
    groups = [
      { name: "Assets", color: colors$1.green },
      { name: "CSS", color: colors$1.magenta },
      { name: "JS", color: colors$1.cyan }
    ];
    POSIX_SEP_RE = new RegExp("\\" + path$n.posix.sep, "g");
    NATIVE_SEP_RE = new RegExp("\\" + path$n.sep, "g");
    TS_EXTENSIONS = [".ts", ".tsx", ".mts", ".cts"];
    JS_EXTENSIONS = [".js", ".jsx", ".mjs", ".cjs"];
    TSJS_EXTENSIONS = TS_EXTENSIONS.concat(JS_EXTENSIONS);
    TS_EXTENSIONS_RE_GROUP = `\\.(?:${TS_EXTENSIONS.map((ext2) => ext2.substring(1)).join("|")})`;
    TSJS_EXTENSIONS_RE_GROUP = `\\.(?:${TSJS_EXTENSIONS.map((ext2) => ext2.substring(1)).join(
      "|"
    )})`;
    IS_POSIX = path$n.posix.sep === path$n.sep;
    singleComment = Symbol("singleComment");
    multiComment = Symbol("multiComment");
    debug$h = createDebugger("vite:esbuild");
    GIT_LFS_PREFIX = Buffer$1.from("version https://git-lfs.github.com");
    !function(A15) {
      A15[A15.Static = 1] = "Static", A15[A15.Dynamic = 2] = "Dynamic", A15[A15.ImportMeta = 3] = "ImportMeta", A15[A15.StaticSourcePhase = 4] = "StaticSourcePhase", A15[A15.DynamicSourcePhase = 5] = "DynamicSourcePhase";
    }(ImportType || (ImportType = {}));
    A14 = 1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
    init = WebAssembly.compile((E10 = "AGFzbQEAAAABKwhgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gA39/fwADMTAAAQECAgICAgICAgICAgICAgICAgIAAwMDBAQAAAUAAAAAAAMDAwAGAAAABwAGAgUEBQFwAQEBBQMBAAEGDwJ/AUHA8gALfwBBwPIACwd6FQZtZW1vcnkCAAJzYQAAAWUAAwJpcwAEAmllAAUCc3MABgJzZQAHAml0AAgCYWkACQJpZAAKAmlwAAsCZXMADAJlZQANA2VscwAOA2VsZQAPAnJpABACcmUAEQFmABICbXMAEwVwYXJzZQAUC19faGVhcF9iYXNlAwEKm0EwaAEBf0EAIAA2AoAKQQAoAtwJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgKECkEAIAA2AogKQQBBADYC4AlBAEEANgLwCUEAQQA2AugJQQBBADYC5AlBAEEANgL4CUEAQQA2AuwJIAEL0wEBA39BACgC8AkhBEEAQQAoAogKIgU2AvAJQQAgBDYC9AlBACAFQSRqNgKICiAEQSBqQeAJIAQbIAU2AgBBACgC1AkhBEEAKALQCSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGIgAbIAQgA0YiBBs2AgwgBSADNgIUIAVBADYCECAFIAI2AgQgBUEANgIgIAVBA0EBQQIgABsgBBs2AhwgBUEAKALQCSADRiICOgAYAkACQCACDQBBACgC1AkgA0cNAQtBAEEBOgCMCgsLXgEBf0EAKAL4CSIEQRBqQeQJIAQbQQAoAogKIgQ2AgBBACAENgL4CUEAIARBFGo2AogKQQBBAToAjAogBEEANgIQIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAAsIAEEAKAKQCgsVAEEAKALoCSgCAEEAKALcCWtBAXULHgEBf0EAKALoCSgCBCIAQQAoAtwJa0EBdUF/IAAbCxUAQQAoAugJKAIIQQAoAtwJa0EBdQseAQF/QQAoAugJKAIMIgBBACgC3AlrQQF1QX8gABsLCwBBACgC6AkoAhwLHgEBf0EAKALoCSgCECIAQQAoAtwJa0EBdUF/IAAbCzsBAX8CQEEAKALoCSgCFCIAQQAoAtAJRw0AQX8PCwJAIABBACgC1AlHDQBBfg8LIABBACgC3AlrQQF1CwsAQQAoAugJLQAYCxUAQQAoAuwJKAIAQQAoAtwJa0EBdQsVAEEAKALsCSgCBEEAKALcCWtBAXULHgEBf0EAKALsCSgCCCIAQQAoAtwJa0EBdUF/IAAbCx4BAX9BACgC7AkoAgwiAEEAKALcCWtBAXVBfyAAGwslAQF/QQBBACgC6AkiAEEgakHgCSAAGygCACIANgLoCSAAQQBHCyUBAX9BAEEAKALsCSIAQRBqQeQJIAAbKAIAIgA2AuwJIABBAEcLCABBAC0AlAoLCABBAC0AjAoL3Q0BBX8jAEGA0ABrIgAkAEEAQQE6AJQKQQBBACgC2Ak2ApwKQQBBACgC3AlBfmoiATYCsApBACABQQAoAoAKQQF0aiICNgK0CkEAQQA6AIwKQQBBADsBlgpBAEEAOwGYCkEAQQA6AKAKQQBBADYCkApBAEEAOgD8CUEAIABBgBBqNgKkCkEAIAA2AqgKQQBBADoArAoCQAJAAkACQANAQQAgAUECaiIDNgKwCiABIAJPDQECQCADLwEAIgJBd2pBBUkNAAJAAkACQAJAAkAgAkGbf2oOBQEICAgCAAsgAkEgRg0EIAJBL0YNAyACQTtGDQIMBwtBAC8BmAoNASADEBVFDQEgAUEEakGCCEEKEC8NARAWQQAtAJQKDQFBAEEAKAKwCiIBNgKcCgwHCyADEBVFDQAgAUEEakGMCEEKEC8NABAXC0EAQQAoArAKNgKcCgwBCwJAIAEvAQQiA0EqRg0AIANBL0cNBBAYDAELQQEQGQtBACgCtAohAkEAKAKwCiEBDAALC0EAIQIgAyEBQQAtAPwJDQIMAQtBACABNgKwCkEAQQA6AJQKCwNAQQAgAUECaiIDNgKwCgJAAkACQAJAAkACQAJAIAFBACgCtApPDQAgAy8BACICQXdqQQVJDQYCQAJAAkACQAJAAkACQAJAAkACQCACQWBqDgoQDwYPDw8PBQECAAsCQAJAAkACQCACQaB/ag4KCxISAxIBEhISAgALIAJBhX9qDgMFEQYJC0EALwGYCg0QIAMQFUUNECABQQRqQYIIQQoQLw0QEBYMEAsgAxAVRQ0PIAFBBGpBjAhBChAvDQ8QFwwPCyADEBVFDQ4gASkABELsgISDsI7AOVINDiABLwEMIgNBd2oiAUEXSw0MQQEgAXRBn4CABHFFDQwMDQtBAEEALwGYCiIBQQFqOwGYCkEAKAKkCiABQQN0aiIBQQE2AgAgAUEAKAKcCjYCBAwNC0EALwGYCiIDRQ0JQQAgA0F/aiIDOwGYCkEALwGWCiICRQ0MQQAoAqQKIANB//8DcUEDdGooAgBBBUcNDAJAIAJBAnRBACgCqApqQXxqKAIAIgMoAgQNACADQQAoApwKQQJqNgIEC0EAIAJBf2o7AZYKIAMgAUEEajYCDAwMCwJAQQAoApwKIgEvAQBBKUcNAEEAKALwCSIDRQ0AIAMoAgQgAUcNAEEAQQAoAvQJIgM2AvAJAkAgA0UNACADQQA2AiAMAQtBAEEANgLgCQtBAEEALwGYCiIDQQFqOwGYCkEAKAKkCiADQQN0aiIDQQZBAkEALQCsChs2AgAgAyABNgIEQQBBADoArAoMCwtBAC8BmAoiAUUNB0EAIAFBf2oiATsBmApBACgCpAogAUH//wNxQQN0aigCAEEERg0EDAoLQScQGgwJC0EiEBoMCAsgAkEvRw0HAkACQCABLwEEIgFBKkYNACABQS9HDQEQGAwKC0EBEBkMCQsCQAJAAkACQEEAKAKcCiIBLwEAIgMQG0UNAAJAAkAgA0FVag4EAAkBAwkLIAFBfmovAQBBK0YNAwwICyABQX5qLwEAQS1GDQIMBwsgA0EpRw0BQQAoAqQKQQAvAZgKIgJBA3RqKAIEEBxFDQIMBgsgAUF+ai8BAEFQakH//wNxQQpPDQULQQAvAZgKIQILAkACQCACQf//A3EiAkUNACADQeYARw0AQQAoAqQKIAJBf2pBA3RqIgQoAgBBAUcNACABQX5qLwEAQe8ARw0BIAQoAgRBlghBAxAdRQ0BDAULIANB/QBHDQBBACgCpAogAkEDdGoiAigCBBAeDQQgAigCAEEGRg0ECyABEB8NAyADRQ0DIANBL0ZBAC0AoApBAEdxDQMCQEEAKAL4CSICRQ0AIAEgAigCAEkNACABIAIoAgRNDQQLIAFBfmohAUEAKALcCSECAkADQCABQQJqIgQgAk0NAUEAIAE2ApwKIAEvAQAhAyABQX5qIgQhASADECBFDQALIARBAmohBAsCQCADQf//A3EQIUUNACAEQX5qIQECQANAIAFBAmoiAyACTQ0BQQAgATYCnAogAS8BACEDIAFBfmoiBCEBIAMQIQ0ACyAEQQJqIQMLIAMQIg0EC0EAQQE6AKAKDAcLQQAoAqQKQQAvAZgKIgFBA3QiA2pBACgCnAo2AgRBACABQQFqOwGYCkEAKAKkCiADakEDNgIACxAjDAULQQAtAPwJQQAvAZYKQQAvAZgKcnJFIQIMBwsQJEEAQQA6AKAKDAMLECVBACECDAULIANBoAFHDQELQQBBAToArAoLQQBBACgCsAo2ApwKC0EAKAKwCiEBDAALCyAAQYDQAGokACACCxoAAkBBACgC3AkgAEcNAEEBDwsgAEF+ahAmC/4KAQZ/QQBBACgCsAoiAEEMaiIBNgKwCkEAKAL4CSECQQEQKSEDAkACQAJAAkACQAJAAkACQAJAQQAoArAKIgQgAUcNACADEChFDQELAkACQAJAAkACQAJAAkAgA0EqRg0AIANB+wBHDQFBACAEQQJqNgKwCkEBECkhA0EAKAKwCiEEA0ACQAJAIANB//8DcSIDQSJGDQAgA0EnRg0AIAMQLBpBACgCsAohAwwBCyADEBpBAEEAKAKwCkECaiIDNgKwCgtBARApGgJAIAQgAxAtIgNBLEcNAEEAQQAoArAKQQJqNgKwCkEBECkhAwsgA0H9AEYNA0EAKAKwCiIFIARGDQ8gBSEEIAVBACgCtApNDQAMDwsLQQAgBEECajYCsApBARApGkEAKAKwCiIDIAMQLRoMAgtBAEEAOgCUCgJAAkACQAJAAkACQCADQZ9/ag4MAgsEAQsDCwsLCwsFAAsgA0H2AEYNBAwKC0EAIARBDmoiAzYCsAoCQAJAAkBBARApQZ9/ag4GABICEhIBEgtBACgCsAoiBSkAAkLzgOSD4I3AMVINESAFLwEKECFFDRFBACAFQQpqNgKwCkEAECkaC0EAKAKwCiIFQQJqQbIIQQ4QLw0QIAUvARAiAkF3aiIBQRdLDQ1BASABdEGfgIAEcUUNDQwOC0EAKAKwCiIFKQACQuyAhIOwjsA5Ug0PIAUvAQoiAkF3aiIBQRdNDQYMCgtBACAEQQpqNgKwCkEAECkaQQAoArAKIQQLQQAgBEEQajYCsAoCQEEBECkiBEEqRw0AQQBBACgCsApBAmo2ArAKQQEQKSEEC0EAKAKwCiEDIAQQLBogA0EAKAKwCiIEIAMgBBACQQBBACgCsApBfmo2ArAKDwsCQCAEKQACQuyAhIOwjsA5Ug0AIAQvAQoQIEUNAEEAIARBCmo2ArAKQQEQKSEEQQAoArAKIQMgBBAsGiADQQAoArAKIgQgAyAEEAJBAEEAKAKwCkF+ajYCsAoPC0EAIARBBGoiBDYCsAoLQQAgBEEGajYCsApBAEEAOgCUCkEBECkhBEEAKAKwCiEDIAQQLCEEQQAoArAKIQIgBEHf/wNxIgFB2wBHDQNBACACQQJqNgKwCkEBECkhBUEAKAKwCiEDQQAhBAwEC0EAQQE6AIwKQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0AQQAgA0EIajYCsAogAEEBEClBABArIAJBEGpB5AkgAhshAwNAIAMoAgAiA0UNBSADQgA3AgggA0EQaiEDDAALC0EAIANBfmo2ArAKDAMLQQEgAXRBn4CABHFFDQMMBAtBASEECwNAAkACQCAEDgIAAQELIAVB//8DcRAsGkEBIQQMAQsCQAJAQQAoArAKIgQgA0YNACADIAQgAyAEEAJBARApIQQCQCABQdsARw0AIARBIHJB/QBGDQQLQQAoArAKIQMCQCAEQSxHDQBBACADQQJqNgKwCkEBECkhBUEAKAKwCiEDIAVBIHJB+wBHDQILQQAgA0F+ajYCsAoLIAFB2wBHDQJBACACQX5qNgKwCg8LQQAhBAwACwsPCyACQaABRg0AIAJB+wBHDQQLQQAgBUEKajYCsApBARApIgVB+wBGDQMMAgsCQCACQVhqDgMBAwEACyACQaABRw0CC0EAIAVBEGo2ArAKAkBBARApIgVBKkcNAEEAQQAoArAKQQJqNgKwCkEBECkhBQsgBUEoRg0BC0EAKAKwCiEBIAUQLBpBACgCsAoiBSABTQ0AIAQgAyABIAUQAkEAQQAoArAKQX5qNgKwCg8LIAQgA0EAQQAQAkEAIARBDGo2ArAKDwsQJQvcCAEGf0EAIQBBAEEAKAKwCiIBQQxqIgI2ArAKQQEQKSEDQQAoArAKIQQCQAJAAkACQAJAAkACQAJAIANBLkcNAEEAIARBAmo2ArAKAkBBARApIgNB8wBGDQAgA0HtAEcNB0EAKAKwCiIDQQJqQZwIQQYQLw0HAkBBACgCnAoiBBAqDQAgBC8BAEEuRg0ICyABIAEgA0EIakEAKALUCRABDwtBACgCsAoiA0ECakGiCEEKEC8NBgJAQQAoApwKIgQQKg0AIAQvAQBBLkYNBwsgA0EMaiEDDAELIANB8wBHDQEgBCACTQ0BQQYhAEEAIQIgBEECakGiCEEKEC8NAiAEQQxqIQMCQCAELwEMIgVBd2oiBEEXSw0AQQEgBHRBn4CABHENAQsgBUGgAUcNAgtBACADNgKwCkEBIQBBARApIQMLAkACQAJAAkAgA0H7AEYNACADQShHDQFBACgCpApBAC8BmAoiA0EDdGoiBEEAKAKwCjYCBEEAIANBAWo7AZgKIARBBTYCAEEAKAKcCi8BAEEuRg0HQQBBACgCsAoiBEECajYCsApBARApIQMgAUEAKAKwCkEAIAQQAQJAAkAgAA0AQQAoAvAJIQQMAQtBACgC8AkiBEEFNgIcC0EAQQAvAZYKIgBBAWo7AZYKQQAoAqgKIABBAnRqIAQ2AgACQCADQSJGDQAgA0EnRg0AQQBBACgCsApBfmo2ArAKDwsgAxAaQQBBACgCsApBAmoiAzYCsAoCQAJAAkBBARApQVdqDgQBAgIAAgtBAEEAKAKwCkECajYCsApBARApGkEAKALwCSIEIAM2AgQgBEEBOgAYIARBACgCsAoiAzYCEEEAIANBfmo2ArAKDwtBACgC8AkiBCADNgIEIARBAToAGEEAQQAvAZgKQX9qOwGYCiAEQQAoArAKQQJqNgIMQQBBAC8BlgpBf2o7AZYKDwtBAEEAKAKwCkF+ajYCsAoPCyAADQJBACgCsAohA0EALwGYCg0BA0ACQAJAAkAgA0EAKAK0Ck8NAEEBECkiA0EiRg0BIANBJ0YNASADQf0ARw0CQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0JC0EAIANBCGo2ArAKAkBBARApIgNBIkYNACADQSdHDQkLIAEgA0EAECsPCyADEBoLQQBBACgCsApBAmoiAzYCsAoMAAsLIAANAUEGIQBBACECAkAgA0FZag4EBAMDBAALIANBIkYNAwwCC0EAIANBfmo2ArAKDwtBDCEAQQEhAgtBACgCsAoiAyABIABBAXRqRw0AQQAgA0F+ajYCsAoPC0EALwGYCg0CQQAoArAKIQNBACgCtAohAANAIAMgAE8NAQJAAkAgAy8BACIEQSdGDQAgBEEiRw0BCyABIAQgAhArDwtBACADQQJqIgM2ArAKDAALCxAlCw8LQQBBACgCsApBfmo2ArAKC0cBA39BACgCsApBAmohAEEAKAK0CiEBAkADQCAAIgJBfmogAU8NASACQQJqIQAgAi8BAEF2ag4EAQAAAQALC0EAIAI2ArAKC5gBAQN/QQBBACgCsAoiAUECajYCsAogAUEGaiEBQQAoArQKIQIDQAJAAkACQCABQXxqIAJPDQAgAUF+ai8BACEDAkACQCAADQAgA0EqRg0BIANBdmoOBAIEBAIECyADQSpHDQMLIAEvAQBBL0cNAkEAIAFBfmo2ArAKDAELIAFBfmohAQtBACABNgKwCg8LIAFBAmohAQwACwuIAQEEf0EAKAKwCiEBQQAoArQKIQICQAJAA0AgASIDQQJqIQEgAyACTw0BIAEvAQAiBCAARg0CAkAgBEHcAEYNACAEQXZqDgQCAQECAQsgA0EEaiEBIAMvAQRBDUcNACADQQZqIAEgAy8BBkEKRhshAQwACwtBACABNgKwChAlDwtBACABNgKwCgtsAQF/AkACQCAAQV9qIgFBBUsNAEEBIAF0QTFxDQELIABBRmpB//8DcUEGSQ0AIABBKUcgAEFYakH//wNxQQdJcQ0AAkAgAEGlf2oOBAEAAAEACyAAQf0ARyAAQYV/akH//wNxQQRJcQ8LQQELLgEBf0EBIQECQCAAQaYJQQUQHQ0AIABBlghBAxAdDQAgAEGwCUECEB0hAQsgAQtGAQN/QQAhAwJAIAAgAkEBdCICayIEQQJqIgBBACgC3AkiBUkNACAAIAEgAhAvDQACQCAAIAVHDQBBAQ8LIAQQJiEDCyADC4MBAQJ/QQEhAQJAAkACQAJAAkACQCAALwEAIgJBRWoOBAUEBAEACwJAIAJBm39qDgQDBAQCAAsgAkEpRg0EIAJB+QBHDQMgAEF+akG8CUEGEB0PCyAAQX5qLwEAQT1GDwsgAEF+akG0CUEEEB0PCyAAQX5qQcgJQQMQHQ8LQQAhAQsgAQu0AwECf0EAIQECQAJAAkACQAJAAkACQAJAAkACQCAALwEAQZx/ag4UAAECCQkJCQMJCQQFCQkGCQcJCQgJCwJAAkAgAEF+ai8BAEGXf2oOBAAKCgEKCyAAQXxqQcoIQQIQHQ8LIABBfGpBzghBAxAdDwsCQAJAAkAgAEF+ai8BAEGNf2oOAwABAgoLAkAgAEF8ai8BACICQeEARg0AIAJB7ABHDQogAEF6akHlABAnDwsgAEF6akHjABAnDwsgAEF8akHUCEEEEB0PCyAAQXxqQdwIQQYQHQ8LIABBfmovAQBB7wBHDQYgAEF8ai8BAEHlAEcNBgJAIABBemovAQAiAkHwAEYNACACQeMARw0HIABBeGpB6AhBBhAdDwsgAEF4akH0CEECEB0PCyAAQX5qQfgIQQQQHQ8LQQEhASAAQX5qIgBB6QAQJw0EIABBgAlBBRAdDwsgAEF+akHkABAnDwsgAEF+akGKCUEHEB0PCyAAQX5qQZgJQQQQHQ8LAkAgAEF+ai8BACICQe8ARg0AIAJB5QBHDQEgAEF8akHuABAnDwsgAEF8akGgCUEDEB0hAQsgAQs0AQF/QQEhAQJAIABBd2pB//8DcUEFSQ0AIABBgAFyQaABRg0AIABBLkcgABAocSEBCyABCzABAX8CQAJAIABBd2oiAUEXSw0AQQEgAXRBjYCABHENAQsgAEGgAUYNAEEADwtBAQtOAQJ/QQAhAQJAAkAgAC8BACICQeUARg0AIAJB6wBHDQEgAEF+akH4CEEEEB0PCyAAQX5qLwEAQfUARw0AIABBfGpB3AhBBhAdIQELIAEL3gEBBH9BACgCsAohAEEAKAK0CiEBAkACQAJAA0AgACICQQJqIQAgAiABTw0BAkACQAJAIAAvAQAiA0Gkf2oOBQIDAwMBAAsgA0EkRw0CIAIvAQRB+wBHDQJBACACQQRqIgA2ArAKQQBBAC8BmAoiAkEBajsBmApBACgCpAogAkEDdGoiAkEENgIAIAIgADYCBA8LQQAgADYCsApBAEEALwGYCkF/aiIAOwGYCkEAKAKkCiAAQf//A3FBA3RqKAIAQQNHDQMMBAsgAkEEaiEADAALC0EAIAA2ArAKCxAlCwtwAQJ/AkACQANAQQBBACgCsAoiAEECaiIBNgKwCiAAQQAoArQKTw0BAkACQAJAIAEvAQAiAUGlf2oOAgECAAsCQCABQXZqDgQEAwMEAAsgAUEvRw0CDAQLEC4aDAELQQAgAEEEajYCsAoMAAsLECULCzUBAX9BAEEBOgD8CUEAKAKwCiEAQQBBACgCtApBAmo2ArAKQQAgAEEAKALcCWtBAXU2ApAKC0MBAn9BASEBAkAgAC8BACICQXdqQf//A3FBBUkNACACQYABckGgAUYNAEEAIQEgAhAoRQ0AIAJBLkcgABAqcg8LIAELPQECf0EAIQICQEEAKALcCSIDIABLDQAgAC8BACABRw0AAkAgAyAARw0AQQEPCyAAQX5qLwEAECAhAgsgAgtoAQJ/QQEhAQJAAkAgAEFfaiICQQVLDQBBASACdEExcQ0BCyAAQfj/A3FBKEYNACAAQUZqQf//A3FBBkkNAAJAIABBpX9qIgJBA0sNACACQQFHDQELIABBhX9qQf//A3FBBEkhAQsgAQucAQEDf0EAKAKwCiEBAkADQAJAAkAgAS8BACICQS9HDQACQCABLwECIgFBKkYNACABQS9HDQQQGAwCCyAAEBkMAQsCQAJAIABFDQAgAkF3aiIBQRdLDQFBASABdEGfgIAEcUUNAQwCCyACECFFDQMMAQsgAkGgAUcNAgtBAEEAKAKwCiIDQQJqIgE2ArAKIANBACgCtApJDQALCyACCzEBAX9BACEBAkAgAC8BAEEuRw0AIABBfmovAQBBLkcNACAAQXxqLwEAQS5GIQELIAELnAQBAX8CQCABQSJGDQAgAUEnRg0AECUPC0EAKAKwCiEDIAEQGiAAIANBAmpBACgCsApBACgC0AkQAQJAIAJFDQBBACgC8AlBBDYCHAtBAEEAKAKwCkECajYCsAoCQAJAAkACQEEAECkiAUHhAEYNACABQfcARg0BQQAoArAKIQEMAgtBACgCsAoiAUECakHACEEKEC8NAUEGIQAMAgtBACgCsAoiAS8BAkHpAEcNACABLwEEQfQARw0AQQQhACABLwEGQegARg0BC0EAIAFBfmo2ArAKDwtBACABIABBAXRqNgKwCgJAQQEQKUH7AEYNAEEAIAE2ArAKDwtBACgCsAoiAiEAA0BBACAAQQJqNgKwCgJAAkACQEEBECkiAEEiRg0AIABBJ0cNAUEnEBpBAEEAKAKwCkECajYCsApBARApIQAMAgtBIhAaQQBBACgCsApBAmo2ArAKQQEQKSEADAELIAAQLCEACwJAIABBOkYNAEEAIAE2ArAKDwtBAEEAKAKwCkECajYCsAoCQEEBECkiAEEiRg0AIABBJ0YNAEEAIAE2ArAKDwsgABAaQQBBACgCsApBAmo2ArAKAkACQEEBECkiAEEsRg0AIABB/QBGDQFBACABNgKwCg8LQQBBACgCsApBAmo2ArAKQQEQKUH9AEYNAEEAKAKwCiEADAELC0EAKALwCSIBIAI2AhAgAUEAKAKwCkECajYCDAttAQJ/AkACQANAAkAgAEH//wNxIgFBd2oiAkEXSw0AQQEgAnRBn4CABHENAgsgAUGgAUYNASAAIQIgARAoDQJBACECQQBBACgCsAoiAEECajYCsAogAC8BAiIADQAMAgsLIAAhAgsgAkH//wNxC6sBAQR/AkACQEEAKAKwCiICLwEAIgNB4QBGDQAgASEEIAAhBQwBC0EAIAJBBGo2ArAKQQEQKSECQQAoArAKIQUCQAJAIAJBIkYNACACQSdGDQAgAhAsGkEAKAKwCiEEDAELIAIQGkEAQQAoArAKQQJqIgQ2ArAKC0EBECkhA0EAKAKwCiECCwJAIAIgBUYNACAFIARBACAAIAAgAUYiAhtBACABIAIbEAILIAMLcgEEf0EAKAKwCiEAQQAoArQKIQECQAJAA0AgAEECaiECIAAgAU8NAQJAAkAgAi8BACIDQaR/ag4CAQQACyACIQAgA0F2ag4EAgEBAgELIABBBGohAAwACwtBACACNgKwChAlQQAPC0EAIAI2ArAKQd0AC0kBA39BACEDAkAgAkUNAAJAA0AgAC0AACIEIAEtAAAiBUcNASABQQFqIQEgAEEBaiEAIAJBf2oiAg0ADAILCyAEIAVrIQMLIAMLC+wBAgBBgAgLzgEAAHgAcABvAHIAdABtAHAAbwByAHQAZgBvAHIAZQB0AGEAbwB1AHIAYwBlAHIAbwBtAHUAbgBjAHQAaQBvAG4AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGMAbwBuAHQAaQBuAGkAbgBzAHQAYQBuAHQAeQBiAHIAZQBhAHIAZQB0AHUAcgBkAGUAYgB1AGcAZwBlAGEAdwBhAGkAdABoAHIAdwBoAGkAbABlAGkAZgBjAGEAdABjAGYAaQBuAGEAbABsAGUAbABzAABB0AkLEAEAAAACAAAAAAQAAEA5AAA=", "undefined" != typeof Buffer ? Buffer.from(E10, "base64") : Uint8Array.from(atob(E10), (A15) => A15.charCodeAt(0)))).then(WebAssembly.instantiate).then(({ exports: A15 }) => {
      C18 = A15;
    });
    convertSourceMap$1 = {};
    (function(exports4) {
      Object.defineProperty(exports4, "commentRegex", {
        get: function getCommentRegex() {
          return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
        }
      });
      Object.defineProperty(exports4, "mapFileCommentRegex", {
        get: function getMapFileCommentRegex() {
          return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
        }
      });
      var decodeBase64;
      if (typeof Buffer !== "undefined") {
        if (typeof Buffer.from === "function") {
          decodeBase64 = decodeBase64WithBufferFrom;
        } else {
          decodeBase64 = decodeBase64WithNewBuffer;
        }
      } else {
        decodeBase64 = decodeBase64WithAtob;
      }
      function decodeBase64WithBufferFrom(base64) {
        return Buffer.from(base64, "base64").toString();
      }
      function decodeBase64WithNewBuffer(base64) {
        if (typeof value === "number") {
          throw new TypeError("The value to decode must not be of type number.");
        }
        return new Buffer(base64, "base64").toString();
      }
      function decodeBase64WithAtob(base64) {
        return decodeURIComponent(escape(atob(base64)));
      }
      function stripComment(sm) {
        return sm.split(",").pop();
      }
      function readFromFileMap(sm, read2) {
        var r9 = exports4.mapFileCommentRegex.exec(sm);
        var filename = r9[1] || r9[2];
        try {
          var sm = read2(filename);
          if (sm != null && typeof sm.catch === "function") {
            return sm.catch(throwError);
          } else {
            return sm;
          }
        } catch (e2) {
          throwError(e2);
        }
        function throwError(e2) {
          throw new Error("An error occurred while trying to read the map file at " + filename + "\n" + e2.stack);
        }
      }
      function Converter(sm, opts) {
        opts = opts || {};
        if (opts.hasComment) {
          sm = stripComment(sm);
        }
        if (opts.encoding === "base64") {
          sm = decodeBase64(sm);
        } else if (opts.encoding === "uri") {
          sm = decodeURIComponent(sm);
        }
        if (opts.isJSON || opts.encoding) {
          sm = JSON.parse(sm);
        }
        this.sourcemap = sm;
      }
      Converter.prototype.toJSON = function(space2) {
        return JSON.stringify(this.sourcemap, null, space2);
      };
      if (typeof Buffer !== "undefined") {
        if (typeof Buffer.from === "function") {
          Converter.prototype.toBase64 = encodeBase64WithBufferFrom;
        } else {
          Converter.prototype.toBase64 = encodeBase64WithNewBuffer;
        }
      } else {
        Converter.prototype.toBase64 = encodeBase64WithBtoa;
      }
      function encodeBase64WithBufferFrom() {
        var json = this.toJSON();
        return Buffer.from(json, "utf8").toString("base64");
      }
      function encodeBase64WithNewBuffer() {
        var json = this.toJSON();
        if (typeof json === "number") {
          throw new TypeError("The json to encode must not be of type number.");
        }
        return new Buffer(json, "utf8").toString("base64");
      }
      function encodeBase64WithBtoa() {
        var json = this.toJSON();
        return btoa(unescape(encodeURIComponent(json)));
      }
      Converter.prototype.toURI = function() {
        var json = this.toJSON();
        return encodeURIComponent(json);
      };
      Converter.prototype.toComment = function(options2) {
        var encoding, content, data;
        if (options2 != null && options2.encoding === "uri") {
          encoding = "";
          content = this.toURI();
        } else {
          encoding = ";base64";
          content = this.toBase64();
        }
        data = "sourceMappingURL=data:application/json;charset=utf-8" + encoding + "," + content;
        return options2 != null && options2.multiline ? "/*# " + data + " */" : "//# " + data;
      };
      Converter.prototype.toObject = function() {
        return JSON.parse(this.toJSON());
      };
      Converter.prototype.addProperty = function(key, value2) {
        if (this.sourcemap.hasOwnProperty(key)) throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
        return this.setProperty(key, value2);
      };
      Converter.prototype.setProperty = function(key, value2) {
        this.sourcemap[key] = value2;
        return this;
      };
      Converter.prototype.getProperty = function(key) {
        return this.sourcemap[key];
      };
      exports4.fromObject = function(obj) {
        return new Converter(obj);
      };
      exports4.fromJSON = function(json) {
        return new Converter(json, { isJSON: true });
      };
      exports4.fromURI = function(uri) {
        return new Converter(uri, { encoding: "uri" });
      };
      exports4.fromBase64 = function(base64) {
        return new Converter(base64, { encoding: "base64" });
      };
      exports4.fromComment = function(comment3) {
        var m23, encoding;
        comment3 = comment3.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
        m23 = exports4.commentRegex.exec(comment3);
        encoding = m23 && m23[4] || "uri";
        return new Converter(comment3, { encoding, hasComment: true });
      };
      function makeConverter(sm) {
        return new Converter(sm, { isJSON: true });
      }
      exports4.fromMapFileComment = function(comment3, read2) {
        if (typeof read2 === "string") {
          throw new Error(
            "String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
          );
        }
        var sm = readFromFileMap(comment3, read2);
        if (sm != null && typeof sm.then === "function") {
          return sm.then(makeConverter);
        } else {
          return makeConverter(sm);
        }
      };
      exports4.fromSource = function(content) {
        var m23 = content.match(exports4.commentRegex);
        return m23 ? exports4.fromComment(m23.pop()) : null;
      };
      exports4.fromMapFileSource = function(content, read2) {
        if (typeof read2 === "string") {
          throw new Error(
            "String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
          );
        }
        var m23 = content.match(exports4.mapFileCommentRegex);
        return m23 ? exports4.fromMapFileComment(m23.pop(), read2) : null;
      };
      exports4.removeComments = function(src3) {
        return src3.replace(exports4.commentRegex, "");
      };
      exports4.removeMapFileComments = function(src3) {
        return src3.replace(exports4.mapFileCommentRegex, "");
      };
      exports4.generateMapFileComment = function(file, options2) {
        var data = "sourceMappingURL=" + file;
        return options2 && options2.multiline ? "/*# " + data + " */" : "//# " + data;
      };
    })(convertSourceMap$1);
    debug$g = createDebugger("vite:sourcemap", {
      onlyWhenFocused: true
    });
    tasks = {};
    utils$g = {};
    array$1 = {};
    Object.defineProperty(array$1, "__esModule", { value: true });
    array$1.splitWhen = array$1.flatten = void 0;
    array$1.flatten = flatten$1;
    array$1.splitWhen = splitWhen;
    errno$1 = {};
    Object.defineProperty(errno$1, "__esModule", { value: true });
    errno$1.isEnoentCodeError = void 0;
    errno$1.isEnoentCodeError = isEnoentCodeError;
    fs$i = {};
    Object.defineProperty(fs$i, "__esModule", { value: true });
    fs$i.createDirentFromStats = void 0;
    DirentFromStats$1 = class DirentFromStats {
      constructor(name2, stats) {
        this.name = name2;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    fs$i.createDirentFromStats = createDirentFromStats$1;
    path$i = {};
    Object.defineProperty(path$i, "__esModule", { value: true });
    path$i.convertPosixPathToPattern = path$i.convertWindowsPathToPattern = path$i.convertPathToPattern = path$i.escapePosixPath = path$i.escapeWindowsPath = path$i.escape = path$i.removeLeadingDotSegment = path$i.makeAbsolute = path$i.unixify = void 0;
    os$4 = require$$2;
    path$h = require$$0$4;
    IS_WINDOWS_PLATFORM = os$4.platform() === "win32";
    LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g;
    WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g;
    DOS_DEVICE_PATH_RE = /^\\\\([.?])/;
    WINDOWS_BACKSLASHES_RE = /\\(?![!()+@[\]{}])/g;
    path$i.unixify = unixify;
    path$i.makeAbsolute = makeAbsolute;
    path$i.removeLeadingDotSegment = removeLeadingDotSegment;
    path$i.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
    path$i.escapeWindowsPath = escapeWindowsPath;
    path$i.escapePosixPath = escapePosixPath;
    path$i.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
    path$i.convertWindowsPathToPattern = convertWindowsPathToPattern;
    path$i.convertPosixPathToPattern = convertPosixPathToPattern;
    pattern$1 = {};
    isExtglob$1 = function isExtglob(str2) {
      if (typeof str2 !== "string" || str2 === "") {
        return false;
      }
      var match2;
      while (match2 = /(\\).|([@?!+*]\(.*\))/g.exec(str2)) {
        if (match2[2]) return true;
        str2 = str2.slice(match2.index + match2[0].length);
      }
      return false;
    };
    isExtglob2 = isExtglob$1;
    chars = { "{": "}", "(": ")", "[": "]" };
    strictCheck = function(str2) {
      if (str2[0] === "!") {
        return true;
      }
      var index3 = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index3 < str2.length) {
        if (str2[index3] === "*") {
          return true;
        }
        if (str2[index3 + 1] === "?" && /[\].+)]/.test(str2[index3])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str2[index3] === "[" && str2[index3 + 1] !== "]") {
          if (closeSquareIndex < index3) {
            closeSquareIndex = str2.indexOf("]", index3);
          }
          if (closeSquareIndex > index3) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str2.indexOf("\\", index3);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str2[index3] === "{" && str2[index3 + 1] !== "}") {
          closeCurlyIndex = str2.indexOf("}", index3);
          if (closeCurlyIndex > index3) {
            backSlashIndex = str2.indexOf("\\", index3);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str2[index3] === "(" && str2[index3 + 1] === "?" && /[:!=]/.test(str2[index3 + 2]) && str2[index3 + 3] !== ")") {
          closeParenIndex = str2.indexOf(")", index3);
          if (closeParenIndex > index3) {
            backSlashIndex = str2.indexOf("\\", index3);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str2[index3] === "(" && str2[index3 + 1] !== "|") {
          if (pipeIndex < index3) {
            pipeIndex = str2.indexOf("|", index3);
          }
          if (pipeIndex !== -1 && str2[pipeIndex + 1] !== ")") {
            closeParenIndex = str2.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str2.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str2[index3] === "\\") {
          var open2 = str2[index3 + 1];
          index3 += 2;
          var close2 = chars[open2];
          if (close2) {
            var n14 = str2.indexOf(close2, index3);
            if (n14 !== -1) {
              index3 = n14 + 1;
            }
          }
          if (str2[index3] === "!") {
            return true;
          }
        } else {
          index3++;
        }
      }
      return false;
    };
    relaxedCheck = function(str2) {
      if (str2[0] === "!") {
        return true;
      }
      var index3 = 0;
      while (index3 < str2.length) {
        if (/[*?{}()[\]]/.test(str2[index3])) {
          return true;
        }
        if (str2[index3] === "\\") {
          var open2 = str2[index3 + 1];
          index3 += 2;
          var close2 = chars[open2];
          if (close2) {
            var n14 = str2.indexOf(close2, index3);
            if (n14 !== -1) {
              index3 = n14 + 1;
            }
          }
          if (str2[index3] === "!") {
            return true;
          }
        } else {
          index3++;
        }
      }
      return false;
    };
    isGlob$2 = function isGlob(str2, options2) {
      if (typeof str2 !== "string" || str2 === "") {
        return false;
      }
      if (isExtglob2(str2)) {
        return true;
      }
      var check = strictCheck;
      if (options2 && options2.strict === false) {
        check = relaxedCheck;
      }
      return check(str2);
    };
    isGlob$1 = isGlob$2;
    pathPosixDirname = require$$0$4.posix.dirname;
    isWin32 = require$$2.platform() === "win32";
    slash3 = "/";
    backslash3 = /\\/g;
    enclosure = /[\{\[].*[\}\]]$/;
    globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    globParent$2 = function globParent(str2, opts) {
      var options2 = Object.assign({ flipBackslashes: true }, opts);
      if (options2.flipBackslashes && isWin32 && str2.indexOf(slash3) < 0) {
        str2 = str2.replace(backslash3, slash3);
      }
      if (enclosure.test(str2)) {
        str2 += slash3;
      }
      str2 += "a";
      do {
        str2 = pathPosixDirname(str2);
      } while (isGlob$1(str2) || globby.test(str2));
      return str2.replace(escaped, "$1");
    };
    utils$f = {};
    (function(exports4) {
      exports4.isInteger = (num) => {
        if (typeof num === "number") {
          return Number.isInteger(num);
        }
        if (typeof num === "string" && num.trim() !== "") {
          return Number.isInteger(Number(num));
        }
        return false;
      };
      exports4.find = (node3, type) => node3.nodes.find((node4) => node4.type === type);
      exports4.exceedsLimit = (min2, max, step = 1, limit) => {
        if (limit === false) return false;
        if (!exports4.isInteger(min2) || !exports4.isInteger(max)) return false;
        return (Number(max) - Number(min2)) / Number(step) >= limit;
      };
      exports4.escapeNode = (block, n14 = 0, type) => {
        const node3 = block.nodes[n14];
        if (!node3) return;
        if (type && node3.type === type || node3.type === "open" || node3.type === "close") {
          if (node3.escaped !== true) {
            node3.value = "\\" + node3.value;
            node3.escaped = true;
          }
        }
      };
      exports4.encloseBrace = (node3) => {
        if (node3.type !== "brace") return false;
        if (node3.commas >> 0 + node3.ranges >> 0 === 0) {
          node3.invalid = true;
          return true;
        }
        return false;
      };
      exports4.isInvalidBrace = (block) => {
        if (block.type !== "brace") return false;
        if (block.invalid === true || block.dollar) return true;
        if (block.commas >> 0 + block.ranges >> 0 === 0) {
          block.invalid = true;
          return true;
        }
        if (block.open !== true || block.close !== true) {
          block.invalid = true;
          return true;
        }
        return false;
      };
      exports4.isOpenOrClose = (node3) => {
        if (node3.type === "open" || node3.type === "close") {
          return true;
        }
        return node3.open === true || node3.close === true;
      };
      exports4.reduce = (nodes) => nodes.reduce((acc, node3) => {
        if (node3.type === "text") acc.push(node3.value);
        if (node3.type === "range") node3.type = "text";
        return acc;
      }, []);
      exports4.flatten = (...args) => {
        const result = [];
        const flat = (arr) => {
          for (let i14 = 0; i14 < arr.length; i14++) {
            const ele = arr[i14];
            if (Array.isArray(ele)) {
              flat(ele);
              continue;
            }
            if (ele !== void 0) {
              result.push(ele);
            }
          }
          return result;
        };
        flat(args);
        return result;
      };
    })(utils$f);
    utils$e = utils$f;
    stringify$7 = (ast, options2 = {}) => {
      const stringify4 = (node3, parent = {}) => {
        const invalidBlock = options2.escapeInvalid && utils$e.isInvalidBrace(parent);
        const invalidNode = node3.invalid === true && options2.escapeInvalid === true;
        let output = "";
        if (node3.value) {
          if ((invalidBlock || invalidNode) && utils$e.isOpenOrClose(node3)) {
            return "\\" + node3.value;
          }
          return node3.value;
        }
        if (node3.value) {
          return node3.value;
        }
        if (node3.nodes) {
          for (const child of node3.nodes) {
            output += stringify4(child);
          }
        }
        return output;
      };
      return stringify4(ast);
    };
    isNumber$2 = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
    isNumber$1 = isNumber$2;
    toRegexRange$1 = (min2, max, options2) => {
      if (isNumber$1(min2) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min2 === max) {
        return String(min2);
      }
      if (isNumber$1(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options2 };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap2 = String(opts.wrap);
      let cacheKey = min2 + ":" + max + "=" + relax + shorthand + capture + wrap2;
      if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange$1.cache[cacheKey].result;
      }
      let a20 = Math.min(min2, max);
      let b18 = Math.max(min2, max);
      if (Math.abs(a20 - b18) === 1) {
        let result = min2 + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded2 = hasPadding(min2) || hasPadding(max);
      let state = { min: min2, max, a: a20, b: b18 };
      let positives = [];
      let negatives = [];
      if (isPadded2) {
        state.isPadded = isPadded2;
        state.maxLen = String(state.max).length;
      }
      if (a20 < 0) {
        let newMin = b18 < 0 ? Math.abs(b18) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a20), state, opts);
        a20 = state.a = 0;
      }
      if (b18 >= 0) {
        positives = splitToPatterns(a20, b18, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange$1.cache[cacheKey] = state;
      return state.result;
    };
    toRegexRange$1.cache = {};
    toRegexRange$1.clearCache = () => toRegexRange$1.cache = {};
    toRegexRange_1 = toRegexRange$1;
    util$1 = require$$0$5;
    toRegexRange = toRegexRange_1;
    isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    transform = (toNumber) => {
      return (value2) => toNumber === true ? Number(value2) : String(value2);
    };
    isValidValue = (value2) => {
      return typeof value2 === "number" || typeof value2 === "string" && value2 !== "";
    };
    isNumber = (num) => Number.isInteger(+num);
    zeros = (input) => {
      let value2 = `${input}`;
      let index3 = -1;
      if (value2[0] === "-") value2 = value2.slice(1);
      if (value2 === "0") return false;
      while (value2[++index3] === "0") ;
      return index3 > 0;
    };
    stringify$6 = (start2, end, options2) => {
      if (typeof start2 === "string" || typeof end === "string") {
        return true;
      }
      return options2.stringify === true;
    };
    pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash) input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength) input = "0" + input;
      return negative ? "-" + input : input;
    };
    toSequence = (parts, options2, maxLen) => {
      parts.negatives.sort((a20, b18) => a20 < b18 ? -1 : a20 > b18 ? 1 : 0);
      parts.positives.sort((a20, b18) => a20 < b18 ? -1 : a20 > b18 ? 1 : 0);
      let prefix = options2.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.map((v15) => toMaxLen(String(v15), maxLen)).join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.map((v15) => toMaxLen(String(v15), maxLen)).join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options2.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    toRange = (a20, b18, isNumbers, options2) => {
      if (isNumbers) {
        return toRegexRange(a20, b18, { wrap: false, ...options2 });
      }
      let start2 = String.fromCharCode(a20);
      if (a20 === b18) return start2;
      let stop = String.fromCharCode(b18);
      return `[${start2}-${stop}]`;
    };
    toRegex = (start2, end, options2) => {
      if (Array.isArray(start2)) {
        let wrap2 = options2.wrap === true;
        let prefix = options2.capture ? "" : "?:";
        return wrap2 ? `(${prefix}${start2.join("|")})` : start2.join("|");
      }
      return toRegexRange(start2, end, options2);
    };
    rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util$1.inspect(...args));
    };
    invalidRange = (start2, end, options2) => {
      if (options2.strictRanges === true) throw rangeError([start2, end]);
      return [];
    };
    invalidStep = (step, options2) => {
      if (options2.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    fillNumbers = (start2, end, step = 1, options2 = {}) => {
      let a20 = Number(start2);
      let b18 = Number(end);
      if (!Number.isInteger(a20) || !Number.isInteger(b18)) {
        if (options2.strictRanges === true) throw rangeError([start2, end]);
        return [];
      }
      if (a20 === 0) a20 = 0;
      if (b18 === 0) b18 = 0;
      let descending = a20 > b18;
      let startString = String(start2);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify$6(start2, end, options2) === false;
      let format2 = options2.transform || transform(toNumber);
      if (options2.toRegex && step === 1) {
        return toRange(toMaxLen(start2, maxLen), toMaxLen(end, maxLen), true, options2);
      }
      let parts = { negatives: [], positives: [] };
      let push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index3 = 0;
      while (descending ? a20 >= b18 : a20 <= b18) {
        if (options2.toRegex === true && step > 1) {
          push2(a20);
        } else {
          range.push(pad(format2(a20, index3), maxLen, toNumber));
        }
        a20 = descending ? a20 - step : a20 + step;
        index3++;
      }
      if (options2.toRegex === true) {
        return step > 1 ? toSequence(parts, options2, maxLen) : toRegex(range, null, { wrap: false, ...options2 });
      }
      return range;
    };
    fillLetters = (start2, end, step = 1, options2 = {}) => {
      if (!isNumber(start2) && start2.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start2, end, options2);
      }
      let format2 = options2.transform || ((val) => String.fromCharCode(val));
      let a20 = `${start2}`.charCodeAt(0);
      let b18 = `${end}`.charCodeAt(0);
      let descending = a20 > b18;
      let min2 = Math.min(a20, b18);
      let max = Math.max(a20, b18);
      if (options2.toRegex && step === 1) {
        return toRange(min2, max, false, options2);
      }
      let range = [];
      let index3 = 0;
      while (descending ? a20 >= b18 : a20 <= b18) {
        range.push(format2(a20, index3));
        a20 = descending ? a20 - step : a20 + step;
        index3++;
      }
      if (options2.toRegex === true) {
        return toRegex(range, null, { wrap: false, options: options2 });
      }
      return range;
    };
    fill$2 = (start2, end, step, options2 = {}) => {
      if (end == null && isValidValue(start2)) {
        return [start2];
      }
      if (!isValidValue(start2) || !isValidValue(end)) {
        return invalidRange(start2, end, options2);
      }
      if (typeof step === "function") {
        return fill$2(start2, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill$2(start2, end, 0, step);
      }
      let opts = { ...options2 };
      if (opts.capture === true) opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step)) return invalidStep(step, opts);
        return fill$2(start2, end, 1, step);
      }
      if (isNumber(start2) && isNumber(end)) {
        return fillNumbers(start2, end, step, opts);
      }
      return fillLetters(start2, end, Math.max(Math.abs(step), 1), opts);
    };
    fillRange = fill$2;
    fill$1 = fillRange;
    utils$d = utils$f;
    compile$1 = (ast, options2 = {}) => {
      const walk3 = (node3, parent = {}) => {
        const invalidBlock = utils$d.isInvalidBrace(parent);
        const invalidNode = node3.invalid === true && options2.escapeInvalid === true;
        const invalid = invalidBlock === true || invalidNode === true;
        const prefix = options2.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node3.isOpen === true) {
          return prefix + node3.value;
        }
        if (node3.isClose === true) {
          console.log("node.isClose", prefix, node3.value);
          return prefix + node3.value;
        }
        if (node3.type === "open") {
          return invalid ? prefix + node3.value : "(";
        }
        if (node3.type === "close") {
          return invalid ? prefix + node3.value : ")";
        }
        if (node3.type === "comma") {
          return node3.prev.type === "comma" ? "" : invalid ? node3.value : "|";
        }
        if (node3.value) {
          return node3.value;
        }
        if (node3.nodes && node3.ranges > 0) {
          const args = utils$d.reduce(node3.nodes);
          const range = fill$1(...args, { ...options2, wrap: false, toRegex: true, strictZeros: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node3.nodes) {
          for (const child of node3.nodes) {
            output += walk3(child, node3);
          }
        }
        return output;
      };
      return walk3(ast);
    };
    compile_1 = compile$1;
    fill = fillRange;
    stringify$5 = stringify$7;
    utils$c = utils$f;
    append$1 = (queue2 = "", stash = "", enclose = false) => {
      const result = [];
      queue2 = [].concat(queue2);
      stash = [].concat(stash);
      if (!stash.length) return queue2;
      if (!queue2.length) {
        return enclose ? utils$c.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (const item of queue2) {
        if (Array.isArray(item)) {
          for (const value2 of item) {
            result.push(append$1(value2, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string") ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append$1(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils$c.flatten(result);
    };
    expand$2 = (ast, options2 = {}) => {
      const rangeLimit = options2.rangeLimit === void 0 ? 1e3 : options2.rangeLimit;
      const walk3 = (node3, parent = {}) => {
        node3.queue = [];
        let p20 = parent;
        let q16 = parent.queue;
        while (p20.type !== "brace" && p20.type !== "root" && p20.parent) {
          p20 = p20.parent;
          q16 = p20.queue;
        }
        if (node3.invalid || node3.dollar) {
          q16.push(append$1(q16.pop(), stringify$5(node3, options2)));
          return;
        }
        if (node3.type === "brace" && node3.invalid !== true && node3.nodes.length === 2) {
          q16.push(append$1(q16.pop(), ["{}"]));
          return;
        }
        if (node3.nodes && node3.ranges > 0) {
          const args = utils$c.reduce(node3.nodes);
          if (utils$c.exceedsLimit(...args, options2.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options2);
          if (range.length === 0) {
            range = stringify$5(node3, options2);
          }
          q16.push(append$1(q16.pop(), range));
          node3.nodes = [];
          return;
        }
        const enclose = utils$c.encloseBrace(node3);
        let queue2 = node3.queue;
        let block = node3;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue2 = block.queue;
        }
        for (let i14 = 0; i14 < node3.nodes.length; i14++) {
          const child = node3.nodes[i14];
          if (child.type === "comma" && node3.type === "brace") {
            if (i14 === 1) queue2.push("");
            queue2.push("");
            continue;
          }
          if (child.type === "close") {
            q16.push(append$1(q16.pop(), queue2, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue2.push(append$1(queue2.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk3(child, node3);
          }
        }
        return queue2;
      };
      return utils$c.flatten(walk3(ast));
    };
    expand_1$1 = expand$2;
    constants$3 = {
      MAX_LENGTH: 1e4,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: " ",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
    stringify$4 = stringify$7;
    ({
      MAX_LENGTH,
      CHAR_BACKSLASH,
      CHAR_BACKTICK: (
        /* \ */
        CHAR_BACKTICK
      ),
      CHAR_COMMA: (
        /* ` */
        CHAR_COMMA
      ),
      CHAR_DOT: (
        /* , */
        CHAR_DOT
      ),
      CHAR_LEFT_PARENTHESES: (
        /* . */
        CHAR_LEFT_PARENTHESES
      ),
      CHAR_RIGHT_PARENTHESES: (
        /* ( */
        CHAR_RIGHT_PARENTHESES
      ),
      CHAR_LEFT_CURLY_BRACE: (
        /* ) */
        CHAR_LEFT_CURLY_BRACE
      ),
      CHAR_RIGHT_CURLY_BRACE: (
        /* { */
        CHAR_RIGHT_CURLY_BRACE
      ),
      CHAR_LEFT_SQUARE_BRACKET: (
        /* } */
        CHAR_LEFT_SQUARE_BRACKET
      ),
      CHAR_RIGHT_SQUARE_BRACKET: (
        /* [ */
        CHAR_RIGHT_SQUARE_BRACKET
      ),
      CHAR_DOUBLE_QUOTE: (
        /* ] */
        CHAR_DOUBLE_QUOTE
      ),
      CHAR_SINGLE_QUOTE: (
        /* " */
        CHAR_SINGLE_QUOTE
      ),
      CHAR_NO_BREAK_SPACE: (
        /* ' */
        CHAR_NO_BREAK_SPACE
      ),
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = constants$3);
    parse$c = (input, options2 = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      const opts = options2 || {};
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      const ast = { type: "root", input, nodes: [] };
      const stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      const length = input.length;
      let index3 = 0;
      let depth2 = 0;
      let value2;
      const advance = () => input[index3++];
      const push2 = (node3) => {
        if (node3.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node3.type === "text") {
          prev.value += node3.value;
          return;
        }
        block.nodes.push(node3);
        node3.parent = block;
        node3.prev = prev;
        prev = node3;
        return node3;
      };
      push2({ type: "bos" });
      while (index3 < length) {
        block = stack[stack.length - 1];
        value2 = advance();
        if (value2 === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value2 === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value2 === CHAR_BACKSLASH) {
          push2({ type: "text", value: (options2.keepEscaping ? value2 : "") + advance() });
          continue;
        }
        if (value2 === CHAR_RIGHT_SQUARE_BRACKET) {
          push2({ type: "text", value: "\\" + value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let next;
          while (index3 < length && (next = advance())) {
            value2 += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value2 += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_PARENTHESES) {
          block = push2({ type: "paren", nodes: [] });
          stack.push(block);
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push2({ type: "text", value: value2 });
            continue;
          }
          block = stack.pop();
          push2({ type: "text", value: value2 });
          block = stack[stack.length - 1];
          continue;
        }
        if (value2 === CHAR_DOUBLE_QUOTE || value2 === CHAR_SINGLE_QUOTE || value2 === CHAR_BACKTICK) {
          const open2 = value2;
          let next;
          if (options2.keepQuotes !== true) {
            value2 = "";
          }
          while (index3 < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value2 += next + advance();
              continue;
            }
            if (next === open2) {
              if (options2.keepQuotes === true) value2 += next;
              break;
            }
            value2 += next;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_CURLY_BRACE) {
          depth2++;
          const dollar2 = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          const brace = {
            type: "brace",
            open: true,
            close: false,
            dollar: dollar2,
            depth: depth2,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push2(brace);
          stack.push(block);
          push2({ type: "open", value: value2 });
          continue;
        }
        if (value2 === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push2({ type: "text", value: value2 });
            continue;
          }
          const type = "close";
          block = stack.pop();
          block.close = true;
          push2({ type, value: value2 });
          depth2--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value2 === CHAR_COMMA && depth2 > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            const open2 = block.nodes.shift();
            block.nodes = [open2, { type: "text", value: stringify$4(block) }];
          }
          push2({ type: "comma", value: value2 });
          block.commas++;
          continue;
        }
        if (value2 === CHAR_DOT && depth2 > 0 && block.commas === 0) {
          const siblings = block.nodes;
          if (depth2 === 0 || siblings.length === 0) {
            push2({ type: "text", value: value2 });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value2;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            const before = siblings[siblings.length - 1];
            before.value += prev.value + value2;
            prev = before;
            block.ranges--;
            continue;
          }
          push2({ type: "dot", value: value2 });
          continue;
        }
        push2({ type: "text", value: value2 });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node3) => {
            if (!node3.nodes) {
              if (node3.type === "open") node3.isOpen = true;
              if (node3.type === "close") node3.isClose = true;
              if (!node3.nodes) node3.type = "text";
              node3.invalid = true;
            }
          });
          const parent = stack[stack.length - 1];
          const index4 = parent.nodes.indexOf(block);
          parent.nodes.splice(index4, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push2({ type: "eos" });
      return ast;
    };
    parse_1$2 = parse$c;
    stringify$3 = stringify$7;
    compile = compile_1;
    expand$1 = expand_1$1;
    parse$b = parse_1$2;
    braces$2 = (input, options2 = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (const pattern2 of input) {
          const result = braces$2.create(pattern2, options2);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces$2.create(input, options2));
      }
      if (options2 && options2.expand === true && options2.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces$2.parse = (input, options2 = {}) => parse$b(input, options2);
    braces$2.stringify = (input, options2 = {}) => {
      if (typeof input === "string") {
        return stringify$3(braces$2.parse(input, options2), options2);
      }
      return stringify$3(input, options2);
    };
    braces$2.compile = (input, options2 = {}) => {
      if (typeof input === "string") {
        input = braces$2.parse(input, options2);
      }
      return compile(input, options2);
    };
    braces$2.expand = (input, options2 = {}) => {
      if (typeof input === "string") {
        input = braces$2.parse(input, options2);
      }
      let result = expand$1(input, options2);
      if (options2.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options2.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces$2.create = (input, options2 = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options2.expand !== true ? braces$2.compile(input, options2) : braces$2.expand(input, options2);
    };
    braces_1 = braces$2;
    util2 = require$$0$5;
    braces$1 = braces_1;
    picomatch$2 = picomatch$3;
    utils$b = utils$k;
    isEmptyString = (v15) => v15 === "" || v15 === "./";
    hasBraces = (v15) => {
      const index3 = v15.indexOf("{");
      return index3 > -1 && v15.indexOf("}", index3) > -1;
    };
    micromatch$1 = (list, patterns, options2) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options2 && options2.onResult) {
          options2.onResult(state);
        }
      };
      for (let i14 = 0; i14 < patterns.length; i14++) {
        let isMatch = picomatch$2(String(patterns[i14]), { ...options2, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated) negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match2 = negated ? !matched.isMatch : matched.isMatch;
          if (!match2) continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options2 && matches.length === 0) {
        if (options2.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options2.nonull === true || options2.nullglob === true) {
          return options2.unescape ? patterns.map((p20) => p20.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch$1.match = micromatch$1;
    micromatch$1.matcher = (pattern2, options2) => picomatch$2(pattern2, options2);
    micromatch$1.isMatch = (str2, patterns, options2) => picomatch$2(patterns, options2)(str2);
    micromatch$1.any = micromatch$1.isMatch;
    micromatch$1.not = (list, patterns, options2 = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options2.onResult) options2.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch$1(list, patterns, { ...options2, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch$1.contains = (str2, pattern2, options2) => {
      if (typeof str2 !== "string") {
        throw new TypeError(`Expected a string: "${util2.inspect(str2)}"`);
      }
      if (Array.isArray(pattern2)) {
        return pattern2.some((p20) => micromatch$1.contains(str2, p20, options2));
      }
      if (typeof pattern2 === "string") {
        if (isEmptyString(str2) || isEmptyString(pattern2)) {
          return false;
        }
        if (str2.includes(pattern2) || str2.startsWith("./") && str2.slice(2).includes(pattern2)) {
          return true;
        }
      }
      return micromatch$1.isMatch(str2, pattern2, { ...options2, contains: true });
    };
    micromatch$1.matchKeys = (obj, patterns, options2) => {
      if (!utils$b.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch$1(Object.keys(obj), patterns, options2);
      let res = {};
      for (let key of keys) res[key] = obj[key];
      return res;
    };
    micromatch$1.some = (list, patterns, options2) => {
      let items = [].concat(list);
      for (let pattern2 of [].concat(patterns)) {
        let isMatch = picomatch$2(String(pattern2), options2);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch$1.every = (list, patterns, options2) => {
      let items = [].concat(list);
      for (let pattern2 of [].concat(patterns)) {
        let isMatch = picomatch$2(String(pattern2), options2);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch$1.all = (str2, patterns, options2) => {
      if (typeof str2 !== "string") {
        throw new TypeError(`Expected a string: "${util2.inspect(str2)}"`);
      }
      return [].concat(patterns).every((p20) => picomatch$2(p20, options2)(str2));
    };
    micromatch$1.capture = (glob, input, options2) => {
      let posix2 = utils$b.isWindows(options2);
      let regex2 = picomatch$2.makeRe(String(glob), { ...options2, capture: true });
      let match2 = regex2.exec(posix2 ? utils$b.toPosixSlashes(input) : input);
      if (match2) {
        return match2.slice(1).map((v15) => v15 === void 0 ? "" : v15);
      }
    };
    micromatch$1.makeRe = (...args) => picomatch$2.makeRe(...args);
    micromatch$1.scan = (...args) => picomatch$2.scan(...args);
    micromatch$1.parse = (patterns, options2) => {
      let res = [];
      for (let pattern2 of [].concat(patterns || [])) {
        for (let str2 of braces$1(String(pattern2), options2)) {
          res.push(picomatch$2.parse(str2, options2));
        }
      }
      return res;
    };
    micromatch$1.braces = (pattern2, options2) => {
      if (typeof pattern2 !== "string") throw new TypeError("Expected a string");
      if (options2 && options2.nobrace === true || !hasBraces(pattern2)) {
        return [pattern2];
      }
      return braces$1(pattern2, options2);
    };
    micromatch$1.braceExpand = (pattern2, options2) => {
      if (typeof pattern2 !== "string") throw new TypeError("Expected a string");
      return micromatch$1.braces(pattern2, { ...options2, expand: true });
    };
    micromatch$1.hasBraces = hasBraces;
    micromatch_1 = micromatch$1;
    micromatch$2 = /* @__PURE__ */ getDefaultExportFromCjs(micromatch_1);
    Object.defineProperty(pattern$1, "__esModule", { value: true });
    pattern$1.removeDuplicateSlashes = pattern$1.matchAny = pattern$1.convertPatternsToRe = pattern$1.makeRe = pattern$1.getPatternParts = pattern$1.expandBraceExpansion = pattern$1.expandPatternsWithBraceExpansion = pattern$1.isAffectDepthOfReadingPattern = pattern$1.endsWithSlashGlobStar = pattern$1.hasGlobStar = pattern$1.getBaseDirectory = pattern$1.isPatternRelatedToParentDirectory = pattern$1.getPatternsOutsideCurrentDirectory = pattern$1.getPatternsInsideCurrentDirectory = pattern$1.getPositivePatterns = pattern$1.getNegativePatterns = pattern$1.isPositivePattern = pattern$1.isNegativePattern = pattern$1.convertToNegativePattern = pattern$1.convertToPositivePattern = pattern$1.isDynamicPattern = pattern$1.isStaticPattern = void 0;
    path$g = require$$0$4;
    globParent$1 = globParent$2;
    micromatch = micromatch_1;
    GLOBSTAR$1 = "**";
    ESCAPE_SYMBOL = "\\";
    COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    DOUBLE_SLASH_RE$1 = /(?!^)\/{2,}/g;
    pattern$1.isStaticPattern = isStaticPattern;
    pattern$1.isDynamicPattern = isDynamicPattern;
    pattern$1.convertToPositivePattern = convertToPositivePattern;
    pattern$1.convertToNegativePattern = convertToNegativePattern;
    pattern$1.isNegativePattern = isNegativePattern;
    pattern$1.isPositivePattern = isPositivePattern;
    pattern$1.getNegativePatterns = getNegativePatterns;
    pattern$1.getPositivePatterns = getPositivePatterns$1;
    pattern$1.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    pattern$1.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    pattern$1.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    pattern$1.getBaseDirectory = getBaseDirectory;
    pattern$1.hasGlobStar = hasGlobStar;
    pattern$1.endsWithSlashGlobStar = endsWithSlashGlobStar;
    pattern$1.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    pattern$1.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    pattern$1.expandBraceExpansion = expandBraceExpansion;
    pattern$1.getPatternParts = getPatternParts;
    pattern$1.makeRe = makeRe;
    pattern$1.convertPatternsToRe = convertPatternsToRe;
    pattern$1.matchAny = matchAny;
    pattern$1.removeDuplicateSlashes = removeDuplicateSlashes;
    stream$4 = {};
    Stream = require$$0$6;
    PassThrough = Stream.PassThrough;
    slice = Array.prototype.slice;
    merge2_1 = merge2$1;
    Object.defineProperty(stream$4, "__esModule", { value: true });
    stream$4.merge = void 0;
    merge22 = merge2_1;
    stream$4.merge = merge$1;
    string$2 = {};
    Object.defineProperty(string$2, "__esModule", { value: true });
    string$2.isEmpty = string$2.isString = void 0;
    string$2.isString = isString$1;
    string$2.isEmpty = isEmpty$1;
    Object.defineProperty(utils$g, "__esModule", { value: true });
    utils$g.string = utils$g.stream = utils$g.pattern = utils$g.path = utils$g.fs = utils$g.errno = utils$g.array = void 0;
    array = array$1;
    utils$g.array = array;
    errno = errno$1;
    utils$g.errno = errno;
    fs$h = fs$i;
    utils$g.fs = fs$h;
    path$f = path$i;
    utils$g.path = path$f;
    pattern = pattern$1;
    utils$g.pattern = pattern;
    stream$3 = stream$4;
    utils$g.stream = stream$3;
    string$12 = string$2;
    utils$g.string = string$12;
    Object.defineProperty(tasks, "__esModule", { value: true });
    tasks.convertPatternGroupToTask = tasks.convertPatternGroupsToTasks = tasks.groupPatternsByBaseDirectory = tasks.getNegativePatternsAsPositive = tasks.getPositivePatterns = tasks.convertPatternsToTasks = tasks.generate = void 0;
    utils$a = utils$g;
    tasks.generate = generate;
    tasks.convertPatternsToTasks = convertPatternsToTasks;
    tasks.getPositivePatterns = getPositivePatterns;
    tasks.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    tasks.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    tasks.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    tasks.convertPatternGroupToTask = convertPatternGroupToTask;
    async$7 = {};
    async$6 = {};
    out$3 = {};
    async$5 = {};
    async$4 = {};
    out$2 = {};
    async$3 = {};
    out$1 = {};
    async$2 = {};
    Object.defineProperty(async$2, "__esModule", { value: true });
    async$2.read = void 0;
    async$2.read = read$3;
    sync$8 = {};
    Object.defineProperty(sync$8, "__esModule", { value: true });
    sync$8.read = void 0;
    sync$8.read = read$2;
    settings$3 = {};
    fs$g = {};
    (function(exports4) {
      Object.defineProperty(exports4, "__esModule", { value: true });
      exports4.createFileSystemAdapter = exports4.FILE_SYSTEM_ADAPTER = void 0;
      const fs5 = require$$0__default3;
      exports4.FILE_SYSTEM_ADAPTER = {
        lstat: fs5.lstat,
        stat: fs5.stat,
        lstatSync: fs5.lstatSync,
        statSync: fs5.statSync
      };
      function createFileSystemAdapter(fsMethods) {
        if (fsMethods === void 0) {
          return exports4.FILE_SYSTEM_ADAPTER;
        }
        return Object.assign(Object.assign({}, exports4.FILE_SYSTEM_ADAPTER), fsMethods);
      }
      exports4.createFileSystemAdapter = createFileSystemAdapter;
    })(fs$g);
    Object.defineProperty(settings$3, "__esModule", { value: true });
    fs$f = fs$g;
    Settings$2 = class Settings {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs$f.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    settings$3.default = Settings$2;
    Object.defineProperty(out$1, "__esModule", { value: true });
    out$1.statSync = out$1.stat = out$1.Settings = void 0;
    async$1 = async$2;
    sync$7 = sync$8;
    settings_1$3 = settings$3;
    out$1.Settings = settings_1$3.default;
    out$1.stat = stat$4;
    out$1.statSync = statSync2;
    queueMicrotask_1 = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : commonjsGlobal) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
    runParallel_1 = runParallel;
    queueMicrotask$1 = queueMicrotask_1;
    constants$2 = {};
    Object.defineProperty(constants$2, "__esModule", { value: true });
    constants$2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    SUPPORTED_MAJOR_VERSION = 10;
    SUPPORTED_MINOR_VERSION = 10;
    IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    constants$2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
    utils$9 = {};
    fs$e = {};
    Object.defineProperty(fs$e, "__esModule", { value: true });
    fs$e.createDirentFromStats = void 0;
    DirentFromStats2 = class {
      constructor(name2, stats) {
        this.name = name2;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    fs$e.createDirentFromStats = createDirentFromStats;
    Object.defineProperty(utils$9, "__esModule", { value: true });
    utils$9.fs = void 0;
    fs$d = fs$e;
    utils$9.fs = fs$d;
    common$a = {};
    Object.defineProperty(common$a, "__esModule", { value: true });
    common$a.joinPathSegments = void 0;
    common$a.joinPathSegments = joinPathSegments$1;
    Object.defineProperty(async$3, "__esModule", { value: true });
    async$3.readdir = async$3.readdirWithFileTypes = async$3.read = void 0;
    fsStat$5 = out$1;
    rpl = runParallel_1;
    constants_1$1 = constants$2;
    utils$8 = utils$9;
    common$9 = common$a;
    async$3.read = read$1;
    async$3.readdirWithFileTypes = readdirWithFileTypes$1;
    async$3.readdir = readdir$3;
    sync$6 = {};
    Object.defineProperty(sync$6, "__esModule", { value: true });
    sync$6.readdir = sync$6.readdirWithFileTypes = sync$6.read = void 0;
    fsStat$4 = out$1;
    constants_1 = constants$2;
    utils$7 = utils$9;
    common$8 = common$a;
    sync$6.read = read;
    sync$6.readdirWithFileTypes = readdirWithFileTypes;
    sync$6.readdir = readdir$2;
    settings$2 = {};
    fs$c = {};
    (function(exports4) {
      Object.defineProperty(exports4, "__esModule", { value: true });
      exports4.createFileSystemAdapter = exports4.FILE_SYSTEM_ADAPTER = void 0;
      const fs5 = require$$0__default3;
      exports4.FILE_SYSTEM_ADAPTER = {
        lstat: fs5.lstat,
        stat: fs5.stat,
        lstatSync: fs5.lstatSync,
        statSync: fs5.statSync,
        readdir: fs5.readdir,
        readdirSync: fs5.readdirSync
      };
      function createFileSystemAdapter(fsMethods) {
        if (fsMethods === void 0) {
          return exports4.FILE_SYSTEM_ADAPTER;
        }
        return Object.assign(Object.assign({}, exports4.FILE_SYSTEM_ADAPTER), fsMethods);
      }
      exports4.createFileSystemAdapter = createFileSystemAdapter;
    })(fs$c);
    Object.defineProperty(settings$2, "__esModule", { value: true });
    path$e = require$$0$4;
    fsStat$3 = out$1;
    fs$b = fs$c;
    Settings$1 = class Settings2 {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs$b.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$e.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat$3.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    settings$2.default = Settings$1;
    Object.defineProperty(out$2, "__esModule", { value: true });
    out$2.Settings = out$2.scandirSync = out$2.scandir = void 0;
    async = async$3;
    sync$5 = sync$6;
    settings_1$2 = settings$2;
    out$2.Settings = settings_1$2.default;
    out$2.scandir = scandir;
    out$2.scandirSync = scandirSync;
    queue = { exports: {} };
    reusify_1 = reusify$1;
    reusify = reusify_1;
    queue.exports = fastqueue;
    queue.exports.promise = queueAsPromised;
    queueExports = queue.exports;
    common$7 = {};
    Object.defineProperty(common$7, "__esModule", { value: true });
    common$7.joinPathSegments = common$7.replacePathSegmentSeparator = common$7.isAppliedFilter = common$7.isFatalError = void 0;
    common$7.isFatalError = isFatalError;
    common$7.isAppliedFilter = isAppliedFilter;
    common$7.replacePathSegmentSeparator = replacePathSegmentSeparator;
    common$7.joinPathSegments = joinPathSegments;
    reader$1 = {};
    Object.defineProperty(reader$1, "__esModule", { value: true });
    common$6 = common$7;
    Reader$1 = class Reader {
      constructor(_root2, _settings) {
        this._root = _root2;
        this._settings = _settings;
        this._root = common$6.replacePathSegmentSeparator(_root2, _settings.pathSegmentSeparator);
      }
    };
    reader$1.default = Reader$1;
    Object.defineProperty(async$4, "__esModule", { value: true });
    events_1 = require$$0$7;
    fsScandir$2 = out$2;
    fastq = queueExports;
    common$5 = common$7;
    reader_1$4 = reader$1;
    AsyncReader = class extends reader_1$4.default {
      constructor(_root2, _settings) {
        super(_root2, _settings);
        this._settings = _settings;
        this._scandir = fsScandir$2.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error2) => {
          if (error2 !== null) {
            this._handleError(error2);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error2, entries) => {
          if (error2 !== null) {
            done(error2, void 0);
            return;
          }
          for (const entry2 of entries) {
            this._handleEntry(entry2, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error2) {
        if (this._isDestroyed || !common$5.isFatalError(this._settings, error2)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error2);
      }
      _handleEntry(entry2, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry2.path;
        if (base !== void 0) {
          entry2.path = common$5.joinPathSegments(base, entry2.name, this._settings.pathSegmentSeparator);
        }
        if (common$5.isAppliedFilter(this._settings.entryFilter, entry2)) {
          this._emitEntry(entry2);
        }
        if (entry2.dirent.isDirectory() && common$5.isAppliedFilter(this._settings.deepFilter, entry2)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry2.path);
        }
      }
      _emitEntry(entry2) {
        this._emitter.emit("entry", entry2);
      }
    };
    async$4.default = AsyncReader;
    Object.defineProperty(async$5, "__esModule", { value: true });
    async_1$4 = async$4;
    AsyncProvider = class {
      constructor(_root2, _settings) {
        this._root = _root2;
        this._settings = _settings;
        this._reader = new async_1$4.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error2) => {
          callFailureCallback(callback, error2);
        });
        this._reader.onEntry((entry2) => {
          this._storage.push(entry2);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    async$5.default = AsyncProvider;
    stream$2 = {};
    Object.defineProperty(stream$2, "__esModule", { value: true });
    stream_1$5 = require$$0$6;
    async_1$3 = async$4;
    StreamProvider = class {
      constructor(_root2, _settings) {
        this._root = _root2;
        this._settings = _settings;
        this._reader = new async_1$3.default(this._root, this._settings);
        this._stream = new stream_1$5.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error2) => {
          this._stream.emit("error", error2);
        });
        this._reader.onEntry((entry2) => {
          this._stream.push(entry2);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    stream$2.default = StreamProvider;
    sync$4 = {};
    sync$3 = {};
    Object.defineProperty(sync$3, "__esModule", { value: true });
    fsScandir$1 = out$2;
    common$4 = common$7;
    reader_1$3 = reader$1;
    SyncReader = class extends reader_1$3.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir$1.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry2 of entries) {
            this._handleEntry(entry2, base);
          }
        } catch (error2) {
          this._handleError(error2);
        }
      }
      _handleError(error2) {
        if (!common$4.isFatalError(this._settings, error2)) {
          return;
        }
        throw error2;
      }
      _handleEntry(entry2, base) {
        const fullpath = entry2.path;
        if (base !== void 0) {
          entry2.path = common$4.joinPathSegments(base, entry2.name, this._settings.pathSegmentSeparator);
        }
        if (common$4.isAppliedFilter(this._settings.entryFilter, entry2)) {
          this._pushToStorage(entry2);
        }
        if (entry2.dirent.isDirectory() && common$4.isAppliedFilter(this._settings.deepFilter, entry2)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry2.path);
        }
      }
      _pushToStorage(entry2) {
        this._storage.push(entry2);
      }
    };
    sync$3.default = SyncReader;
    Object.defineProperty(sync$4, "__esModule", { value: true });
    sync_1$3 = sync$3;
    SyncProvider = class {
      constructor(_root2, _settings) {
        this._root = _root2;
        this._settings = _settings;
        this._reader = new sync_1$3.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    sync$4.default = SyncProvider;
    settings$1 = {};
    Object.defineProperty(settings$1, "__esModule", { value: true });
    path$d = require$$0$4;
    fsScandir = out$2;
    Settings3 = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$d.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    settings$1.default = Settings3;
    Object.defineProperty(out$3, "__esModule", { value: true });
    out$3.Settings = out$3.walkStream = out$3.walkSync = out$3.walk = void 0;
    async_1$2 = async$5;
    stream_1$4 = stream$2;
    sync_1$2 = sync$4;
    settings_1$1 = settings$1;
    out$3.Settings = settings_1$1.default;
    out$3.walk = walk$2;
    out$3.walkSync = walkSync;
    out$3.walkStream = walkStream;
    reader = {};
    Object.defineProperty(reader, "__esModule", { value: true });
    path$c = require$$0$4;
    fsStat$2 = out$1;
    utils$6 = utils$g;
    Reader2 = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat$2.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path$c.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern2) {
        const entry2 = {
          name: pattern2,
          path: pattern2,
          dirent: utils$6.fs.createDirentFromStats(pattern2, stats)
        };
        if (this._settings.stats) {
          entry2.stats = stats;
        }
        return entry2;
      }
      _isFatalError(error2) {
        return !utils$6.errno.isEnoentCodeError(error2) && !this._settings.suppressErrors;
      }
    };
    reader.default = Reader2;
    stream$1 = {};
    Object.defineProperty(stream$1, "__esModule", { value: true });
    stream_1$3 = require$$0$6;
    fsStat$1 = out$1;
    fsWalk$2 = out$3;
    reader_1$2 = reader;
    ReaderStream = class extends reader_1$2.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk$2.walkStream;
        this._stat = fsStat$1.stat;
      }
      dynamic(root3, options2) {
        return this._walkStream(root3, options2);
      }
      static(patterns, options2) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream4 = new stream_1$3.PassThrough({ objectMode: true });
        stream4._write = (index3, _enc, done) => {
          return this._getEntry(filepaths[index3], patterns[index3], options2).then((entry2) => {
            if (entry2 !== null && options2.entryFilter(entry2)) {
              stream4.push(entry2);
            }
            if (index3 === filepaths.length - 1) {
              stream4.end();
            }
            done();
          }).catch(done);
        };
        for (let i14 = 0; i14 < filepaths.length; i14++) {
          stream4.write(i14);
        }
        return stream4;
      }
      _getEntry(filepath, pattern2, options2) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern2)).catch((error2) => {
          if (options2.errorFilter(error2)) {
            return null;
          }
          throw error2;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve5, reject) => {
          this._stat(filepath, this._fsStatSettings, (error2, stats) => {
            return error2 === null ? resolve5(stats) : reject(error2);
          });
        });
      }
    };
    stream$1.default = ReaderStream;
    Object.defineProperty(async$6, "__esModule", { value: true });
    fsWalk$1 = out$3;
    reader_1$1 = reader;
    stream_1$2 = stream$1;
    ReaderAsync = class extends reader_1$1.default {
      constructor() {
        super(...arguments);
        this._walkAsync = fsWalk$1.walk;
        this._readerStream = new stream_1$2.default(this._settings);
      }
      dynamic(root3, options2) {
        return new Promise((resolve5, reject) => {
          this._walkAsync(root3, options2, (error2, entries) => {
            if (error2 === null) {
              resolve5(entries);
            } else {
              reject(error2);
            }
          });
        });
      }
      async static(patterns, options2) {
        const entries = [];
        const stream4 = this._readerStream.static(patterns, options2);
        return new Promise((resolve5, reject) => {
          stream4.once("error", reject);
          stream4.on("data", (entry2) => entries.push(entry2));
          stream4.once("end", () => resolve5(entries));
        });
      }
    };
    async$6.default = ReaderAsync;
    provider = {};
    deep = {};
    partial = {};
    matcher = {};
    Object.defineProperty(matcher, "__esModule", { value: true });
    utils$5 = utils$g;
    Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        for (const pattern2 of this._patterns) {
          const segments = this._getPatternSegments(pattern2);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern: pattern2,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern2) {
        const parts = utils$5.pattern.getPatternParts(pattern2, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils$5.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils$5.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils$5.array.splitWhen(segments, (segment) => segment.dynamic && utils$5.pattern.hasGlobStar(segment.pattern));
      }
    };
    matcher.default = Matcher;
    Object.defineProperty(partial, "__esModule", { value: true });
    matcher_1 = matcher;
    PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern2 of patterns) {
          const section = pattern2.sections[0];
          if (!pattern2.complete && levels > section.length) {
            return true;
          }
          const match2 = parts.every((part, index3) => {
            const segment = pattern2.segments[index3];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match2) {
            return true;
          }
        }
        return false;
      }
    };
    partial.default = PartialMatcher;
    Object.defineProperty(deep, "__esModule", { value: true });
    utils$4 = utils$g;
    partial_1 = partial;
    DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher2 = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry2) => this._filter(basePath, entry2, matcher2, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils$4.pattern.isAffectDepthOfReadingPattern);
        return utils$4.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry2, matcher2, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry2.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry2)) {
          return false;
        }
        const filepath = utils$4.path.removeLeadingDotSegment(entry2.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher2)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry2) {
        return !this._settings.followSymbolicLinks && entry2.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher2) {
        return !this._settings.baseNameMatch && !matcher2.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils$4.pattern.matchAny(entryPath, patternsRe);
      }
    };
    deep.default = DeepFilter;
    entry$1 = {};
    Object.defineProperty(entry$1, "__esModule", { value: true });
    utils$3 = utils$g;
    EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils$3.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils$3.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true }));
        return (entry2) => this._filter(entry2, positiveRe, negativeRe);
      }
      _filter(entry2, positiveRe, negativeRe) {
        const filepath = utils$3.path.removeLeadingDotSegment(entry2.path);
        if (this._settings.unique && this._isDuplicateEntry(filepath)) {
          return false;
        }
        if (this._onlyFileFilter(entry2) || this._onlyDirectoryFilter(entry2)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe)) {
          return false;
        }
        const isDirectory2 = entry2.dirent.isDirectory();
        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory2) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory2);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(filepath);
        }
        return isMatched;
      }
      _isDuplicateEntry(filepath) {
        return this.index.has(filepath);
      }
      _createIndexRecord(filepath) {
        this.index.set(filepath, void 0);
      }
      _onlyFileFilter(entry2) {
        return this._settings.onlyFiles && !entry2.dirent.isFile();
      }
      _onlyDirectoryFilter(entry2) {
        return this._settings.onlyDirectories && !entry2.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils$3.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils$3.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(filepath, patternsRe, isDirectory2) {
        const isMatched = utils$3.pattern.matchAny(filepath, patternsRe);
        if (!isMatched && isDirectory2) {
          return utils$3.pattern.matchAny(filepath + "/", patternsRe);
        }
        return isMatched;
      }
    };
    entry$1.default = EntryFilter;
    error$1 = {};
    Object.defineProperty(error$1, "__esModule", { value: true });
    utils$2 = utils$g;
    ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error2) => this._isNonFatalError(error2);
      }
      _isNonFatalError(error2) {
        return utils$2.errno.isEnoentCodeError(error2) || this._settings.suppressErrors;
      }
    };
    error$1.default = ErrorFilter;
    entry = {};
    Object.defineProperty(entry, "__esModule", { value: true });
    utils$1 = utils$g;
    EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry2) => this._transform(entry2);
      }
      _transform(entry2) {
        let filepath = entry2.path;
        if (this._settings.absolute) {
          filepath = utils$1.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils$1.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry2.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry2), { path: filepath });
      }
    };
    entry.default = EntryTransformer;
    Object.defineProperty(provider, "__esModule", { value: true });
    path$b = require$$0$4;
    deep_1 = deep;
    entry_1 = entry$1;
    error_1 = error$1;
    entry_2 = entry;
    Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path$b.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    provider.default = Provider;
    Object.defineProperty(async$7, "__esModule", { value: true });
    async_1$1 = async$6;
    provider_1$2 = provider;
    ProviderAsync = class extends provider_1$2.default {
      constructor() {
        super(...arguments);
        this._reader = new async_1$1.default(this._settings);
      }
      async read(task) {
        const root3 = this._getRootDirectory(task);
        const options2 = this._getReaderOptions(task);
        const entries = await this.api(root3, task, options2);
        return entries.map((entry2) => options2.transform(entry2));
      }
      api(root3, task, options2) {
        if (task.dynamic) {
          return this._reader.dynamic(root3, options2);
        }
        return this._reader.static(task.patterns, options2);
      }
    };
    async$7.default = ProviderAsync;
    stream = {};
    Object.defineProperty(stream, "__esModule", { value: true });
    stream_1$1 = require$$0$6;
    stream_2 = stream$1;
    provider_1$1 = provider;
    ProviderStream = class extends provider_1$1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root3 = this._getRootDirectory(task);
        const options2 = this._getReaderOptions(task);
        const source = this.api(root3, task, options2);
        const destination = new stream_1$1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error2) => destination.emit("error", error2)).on("data", (entry2) => destination.emit("data", options2.transform(entry2))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root3, task, options2) {
        if (task.dynamic) {
          return this._reader.dynamic(root3, options2);
        }
        return this._reader.static(task.patterns, options2);
      }
    };
    stream.default = ProviderStream;
    sync$2 = {};
    sync$1 = {};
    Object.defineProperty(sync$1, "__esModule", { value: true });
    fsStat = out$1;
    fsWalk = out$3;
    reader_1 = reader;
    ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root3, options2) {
        return this._walkSync(root3, options2);
      }
      static(patterns, options2) {
        const entries = [];
        for (const pattern2 of patterns) {
          const filepath = this._getFullEntryPath(pattern2);
          const entry2 = this._getEntry(filepath, pattern2, options2);
          if (entry2 === null || !options2.entryFilter(entry2)) {
            continue;
          }
          entries.push(entry2);
        }
        return entries;
      }
      _getEntry(filepath, pattern2, options2) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern2);
        } catch (error2) {
          if (options2.errorFilter(error2)) {
            return null;
          }
          throw error2;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    sync$1.default = ReaderSync;
    Object.defineProperty(sync$2, "__esModule", { value: true });
    sync_1$1 = sync$1;
    provider_1 = provider;
    ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1$1.default(this._settings);
      }
      read(task) {
        const root3 = this._getRootDirectory(task);
        const options2 = this._getReaderOptions(task);
        const entries = this.api(root3, task, options2);
        return entries.map(options2.transform);
      }
      api(root3, task, options2) {
        if (task.dynamic) {
          return this._reader.dynamic(root3, options2);
        }
        return this._reader.static(task.patterns, options2);
      }
    };
    sync$2.default = ProviderSync;
    settings = {};
    (function(exports4) {
      Object.defineProperty(exports4, "__esModule", { value: true });
      exports4.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
      const fs5 = require$$0__default3;
      const os2 = require$$2;
      const CPU_COUNT = Math.max(os2.cpus().length, 1);
      exports4.DEFAULT_FILE_SYSTEM_ADAPTER = {
        lstat: fs5.lstat,
        lstatSync: fs5.lstatSync,
        stat: fs5.stat,
        statSync: fs5.statSync,
        readdir: fs5.readdir,
        readdirSync: fs5.readdirSync
      };
      class Settings4 {
        constructor(_options = {}) {
          this._options = _options;
          this.absolute = this._getValue(this._options.absolute, false);
          this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
          this.braceExpansion = this._getValue(this._options.braceExpansion, true);
          this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
          this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
          this.cwd = this._getValue(this._options.cwd, process.cwd());
          this.deep = this._getValue(this._options.deep, Infinity);
          this.dot = this._getValue(this._options.dot, false);
          this.extglob = this._getValue(this._options.extglob, true);
          this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
          this.fs = this._getFileSystemMethods(this._options.fs);
          this.globstar = this._getValue(this._options.globstar, true);
          this.ignore = this._getValue(this._options.ignore, []);
          this.markDirectories = this._getValue(this._options.markDirectories, false);
          this.objectMode = this._getValue(this._options.objectMode, false);
          this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
          this.onlyFiles = this._getValue(this._options.onlyFiles, true);
          this.stats = this._getValue(this._options.stats, false);
          this.suppressErrors = this._getValue(this._options.suppressErrors, false);
          this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
          this.unique = this._getValue(this._options.unique, true);
          if (this.onlyDirectories) {
            this.onlyFiles = false;
          }
          if (this.stats) {
            this.objectMode = true;
          }
          this.ignore = [].concat(this.ignore);
        }
        _getValue(option, value2) {
          return option === void 0 ? value2 : option;
        }
        _getFileSystemMethods(methods = {}) {
          return Object.assign(Object.assign({}, exports4.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
        }
      }
      exports4.default = Settings4;
    })(settings);
    taskManager = tasks;
    async_1 = async$7;
    stream_1 = stream;
    sync_1 = sync$2;
    settings_1 = settings;
    utils = utils$g;
    (function(FastGlob2) {
      FastGlob2.glob = FastGlob2;
      FastGlob2.globSync = sync2;
      FastGlob2.globStream = stream4;
      FastGlob2.async = FastGlob2;
      function sync2(source, options2) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options2);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync2;
      function stream4(source, options2) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options2);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream4;
      function generateTasks(source, options2) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings2 = new settings_1.default(options2);
        return taskManager.generate(patterns, settings2);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern2(source, options2) {
        assertPatternsInput(source);
        const settings2 = new settings_1.default(options2);
        return utils.pattern.isDynamicPattern(source, settings2);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern2;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
      function convertPathToPattern(source) {
        assertPatternsInput(source);
        return utils.path.convertPathToPattern(source);
      }
      FastGlob2.convertPathToPattern = convertPathToPattern;
      (function(posix2) {
        function escapePath2(source) {
          assertPatternsInput(source);
          return utils.path.escapePosixPath(source);
        }
        posix2.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput(source);
          return utils.path.convertPosixPathToPattern(source);
        }
        posix2.convertPathToPattern = convertPathToPattern2;
      })(FastGlob2.posix || (FastGlob2.posix = {}));
      (function(win322) {
        function escapePath2(source) {
          assertPatternsInput(source);
          return utils.path.escapeWindowsPath(source);
        }
        win322.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput(source);
          return utils.path.convertWindowsPathToPattern(source);
        }
        win322.convertPathToPattern = convertPathToPattern2;
      })(FastGlob2.win32 || (FastGlob2.win32 = {}));
    })(FastGlob || (FastGlob = {}));
    src$22 = {};
    path$a = require$$0$4;
    fs$a = require$$0__default3;
    os$3 = require$$2;
    fsReadFileAsync = fs$a.promises.readFile;
    jsonLoader = (_22, content) => JSON.parse(content);
    requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require2;
    defaultLoadersSync = Object.freeze({
      ".js": requireFunc,
      ".json": requireFunc,
      ".cjs": requireFunc,
      noExt: jsonLoader
    });
    src$22.defaultLoadersSync = defaultLoadersSync;
    dynamicImport = async (id3) => {
      try {
        const mod = await import(
          /* webpackIgnore: true */
          id3
        );
        return mod.default;
      } catch (e2) {
        try {
          return requireFunc(id3);
        } catch (requireE) {
          if (requireE.code === "ERR_REQUIRE_ESM" || requireE instanceof SyntaxError && requireE.toString().includes("Cannot use import statement outside a module")) {
            throw e2;
          }
          throw requireE;
        }
      }
    };
    defaultLoaders = Object.freeze({
      ".js": dynamicImport,
      ".mjs": dynamicImport,
      ".cjs": dynamicImport,
      ".json": jsonLoader,
      noExt: jsonLoader
    });
    src$22.defaultLoaders = defaultLoaders;
    makeEmplace = (enableCache) => (c16, filepath, res) => {
      if (enableCache) c16.set(filepath, res);
      return res;
    };
    src$22.lilconfig = function lilconfig(name2, options2) {
      const {
        ignoreEmptySearchPlaces,
        loaders,
        packageProp,
        searchPlaces,
        stopDir,
        transform: transform2,
        cache: cache2
      } = getOptions(name2, options2 ?? {}, false);
      const searchCache = /* @__PURE__ */ new Map();
      const loadCache = /* @__PURE__ */ new Map();
      const emplace = makeEmplace(cache2);
      return {
        async search(searchFrom = process.cwd()) {
          const result = {
            config: null,
            filepath: ""
          };
          const visited = /* @__PURE__ */ new Set();
          let dir = searchFrom;
          dirLoop: while (true) {
            if (cache2) {
              const r9 = searchCache.get(dir);
              if (r9 !== void 0) {
                for (const p20 of visited) searchCache.set(p20, r9);
                return r9;
              }
              visited.add(dir);
            }
            for (const searchPlace of searchPlaces) {
              const filepath = path$a.join(dir, searchPlace);
              try {
                await fs$a.promises.access(filepath);
              } catch {
                continue;
              }
              const content = String(await fsReadFileAsync(filepath));
              const loaderKey = path$a.extname(searchPlace) || "noExt";
              const loader = loaders[loaderKey];
              if (searchPlace === "package.json") {
                const pkg = await loader(filepath, content);
                const maybeConfig = getPackageProp(packageProp, pkg);
                if (maybeConfig != null) {
                  result.config = maybeConfig;
                  result.filepath = filepath;
                  break dirLoop;
                }
                continue;
              }
              const isEmpty2 = content.trim() === "";
              if (isEmpty2 && ignoreEmptySearchPlaces) continue;
              if (isEmpty2) {
                result.isEmpty = true;
                result.config = void 0;
              } else {
                validateLoader(loader, loaderKey);
                result.config = await loader(filepath, content);
              }
              result.filepath = filepath;
              break dirLoop;
            }
            if (dir === stopDir || dir === parentDir(dir)) break dirLoop;
            dir = parentDir(dir);
          }
          const transformed = (
            // not found
            result.filepath === "" && result.config === null ? transform2(null) : transform2(result)
          );
          if (cache2) {
            for (const p20 of visited) searchCache.set(p20, transformed);
          }
          return transformed;
        },
        async load(filepath) {
          validateFilePath(filepath);
          const absPath = path$a.resolve(process.cwd(), filepath);
          if (cache2 && loadCache.has(absPath)) {
            return loadCache.get(absPath);
          }
          const { base, ext: ext2 } = path$a.parse(absPath);
          const loaderKey = ext2 || "noExt";
          const loader = loaders[loaderKey];
          validateLoader(loader, loaderKey);
          const content = String(await fsReadFileAsync(absPath));
          if (base === "package.json") {
            const pkg = await loader(absPath, content);
            return emplace(
              loadCache,
              absPath,
              transform2({
                config: getPackageProp(packageProp, pkg),
                filepath: absPath
              })
            );
          }
          const result = {
            config: null,
            filepath: absPath
          };
          const isEmpty2 = content.trim() === "";
          if (isEmpty2 && ignoreEmptySearchPlaces)
            return emplace(
              loadCache,
              absPath,
              transform2({
                config: void 0,
                filepath: absPath,
                isEmpty: true
              })
            );
          result.config = isEmpty2 ? void 0 : await loader(absPath, content);
          return emplace(
            loadCache,
            absPath,
            transform2(isEmpty2 ? { ...result, isEmpty: isEmpty2, config: void 0 } : result)
          );
        },
        clearLoadCache() {
          if (cache2) loadCache.clear();
        },
        clearSearchCache() {
          if (cache2) searchCache.clear();
        },
        clearCaches() {
          if (cache2) {
            loadCache.clear();
            searchCache.clear();
          }
        }
      };
    };
    src$22.lilconfigSync = function lilconfigSync(name2, options2) {
      const {
        ignoreEmptySearchPlaces,
        loaders,
        packageProp,
        searchPlaces,
        stopDir,
        transform: transform2,
        cache: cache2
      } = getOptions(name2, options2 ?? {}, true);
      const searchCache = /* @__PURE__ */ new Map();
      const loadCache = /* @__PURE__ */ new Map();
      const emplace = makeEmplace(cache2);
      return {
        search(searchFrom = process.cwd()) {
          const result = {
            config: null,
            filepath: ""
          };
          const visited = /* @__PURE__ */ new Set();
          let dir = searchFrom;
          dirLoop: while (true) {
            if (cache2) {
              const r9 = searchCache.get(dir);
              if (r9 !== void 0) {
                for (const p20 of visited) searchCache.set(p20, r9);
                return r9;
              }
              visited.add(dir);
            }
            for (const searchPlace of searchPlaces) {
              const filepath = path$a.join(dir, searchPlace);
              try {
                fs$a.accessSync(filepath);
              } catch {
                continue;
              }
              const loaderKey = path$a.extname(searchPlace) || "noExt";
              const loader = loaders[loaderKey];
              const content = String(fs$a.readFileSync(filepath));
              if (searchPlace === "package.json") {
                const pkg = loader(filepath, content);
                const maybeConfig = getPackageProp(packageProp, pkg);
                if (maybeConfig != null) {
                  result.config = maybeConfig;
                  result.filepath = filepath;
                  break dirLoop;
                }
                continue;
              }
              const isEmpty2 = content.trim() === "";
              if (isEmpty2 && ignoreEmptySearchPlaces) continue;
              if (isEmpty2) {
                result.isEmpty = true;
                result.config = void 0;
              } else {
                validateLoader(loader, loaderKey);
                result.config = loader(filepath, content);
              }
              result.filepath = filepath;
              break dirLoop;
            }
            if (dir === stopDir || dir === parentDir(dir)) break dirLoop;
            dir = parentDir(dir);
          }
          const transformed = (
            // not found
            result.filepath === "" && result.config === null ? transform2(null) : transform2(result)
          );
          if (cache2) {
            for (const p20 of visited) searchCache.set(p20, transformed);
          }
          return transformed;
        },
        load(filepath) {
          validateFilePath(filepath);
          const absPath = path$a.resolve(process.cwd(), filepath);
          if (cache2 && loadCache.has(absPath)) {
            return loadCache.get(absPath);
          }
          const { base, ext: ext2 } = path$a.parse(absPath);
          const loaderKey = ext2 || "noExt";
          const loader = loaders[loaderKey];
          validateLoader(loader, loaderKey);
          const content = String(fs$a.readFileSync(absPath));
          if (base === "package.json") {
            const pkg = loader(absPath, content);
            return transform2({
              config: getPackageProp(packageProp, pkg),
              filepath: absPath
            });
          }
          const result = {
            config: null,
            filepath: absPath
          };
          const isEmpty2 = content.trim() === "";
          if (isEmpty2 && ignoreEmptySearchPlaces)
            return emplace(
              loadCache,
              absPath,
              transform2({
                filepath: absPath,
                config: void 0,
                isEmpty: true
              })
            );
          result.config = isEmpty2 ? void 0 : loader(absPath, content);
          return emplace(
            loadCache,
            absPath,
            transform2(isEmpty2 ? { ...result, isEmpty: isEmpty2, config: void 0 } : result)
          );
        },
        clearLoadCache() {
          if (cache2) loadCache.clear();
        },
        clearSearchCache() {
          if (cache2) searchCache.clear();
        },
        clearCaches() {
          if (cache2) {
            loadCache.clear();
            searchCache.clear();
          }
        }
      };
    };
    ALIAS = Symbol.for("yaml.alias");
    DOC = Symbol.for("yaml.document");
    MAP = Symbol.for("yaml.map");
    PAIR = Symbol.for("yaml.pair");
    SCALAR$1 = Symbol.for("yaml.scalar");
    SEQ = Symbol.for("yaml.seq");
    NODE_TYPE = Symbol.for("yaml.node.type");
    isAlias = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === ALIAS;
    isDocument = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === DOC;
    isMap = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === MAP;
    isPair = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === PAIR;
    isScalar$1 = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === SCALAR$1;
    isSeq = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === SEQ;
    hasAnchor = (node3) => (isScalar$1(node3) || isCollection$1(node3)) && !!node3.anchor;
    BREAK$1 = Symbol("break visit");
    SKIP$1 = Symbol("skip children");
    REMOVE$1 = Symbol("remove node");
    visit$1.BREAK = BREAK$1;
    visit$1.SKIP = SKIP$1;
    visit$1.REMOVE = REMOVE$1;
    visitAsync.BREAK = BREAK$1;
    visitAsync.SKIP = SKIP$1;
    visitAsync.REMOVE = REMOVE$1;
    escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    Directives = class _Directives {
      constructor(yaml2, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml2);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError2) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name2 = parts.shift();
        switch (name2) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError2(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle2, prefix] = parts;
            this.tags[handle2] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError2(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version3] = parts;
            if (version3 === "1.1" || version3 === "1.2") {
              this.yaml.version = version3;
              return true;
            } else {
              const isValid2 = /^\d+\.\d+$/.test(version3);
              onError2(6, `Unsupported YAML version ${version3}`, isValid2);
              return false;
            }
          }
          default:
            onError2(0, `Unknown directive ${name2}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError2) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError2(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError2(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError2("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle2, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError2(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle2];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error2) {
            onError2(String(error2));
            return null;
          }
        }
        if (handle2 === "!")
          return source;
        onError2(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag3) {
        for (const [handle2, prefix] of Object.entries(this.tags)) {
          if (tag3.startsWith(prefix))
            return handle2 + escapeTagName(tag3.substring(prefix.length));
        }
        return tag3[0] === "!" ? tag3 : `!<${tag3}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && isNode$1(doc.contents)) {
          const tags = {};
          visit$1(doc.contents, (_key, node3) => {
            if (isNode$1(node3) && node3.tag)
              tags[node3.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle2, prefix] of tagEntries) {
          if (handle2 === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle2} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    Alias = class extends NodeBase {
      constructor(source) {
        super(ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found = void 0;
        visit$1(doc, {
          Node: (_key, node3) => {
            if (node3 === this)
              return visit$1.BREAK;
            if (node3.anchor === this.source)
              found = node3;
          }
        });
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
          toJS(source, null, ctx);
          data = anchors.get(source);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src3 = `*${this.source}`;
        if (ctx) {
          anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src3} `;
        }
        return src3;
      }
    };
    isScalarValue = (value2) => !value2 || typeof value2 !== "function" && typeof value2 !== "object";
    Scalar = class extends NodeBase {
      constructor(value2) {
        super(SCALAR$1);
        this.value = value2;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    defaultTagPrefix = "tag:yaml.org,2002:";
    isEmptyPath = (path7) => path7 == null || typeof path7 === "object" && !!path7[Symbol.iterator]().next().done;
    Collection = class extends NodeBase {
      constructor(type, schema2) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema2,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema2) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema2)
          copy.schema = schema2;
        copy.items = copy.items.map((it) => isNode$1(it) || isPair(it) ? it.clone(schema2) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path7, value2) {
        if (isEmptyPath(path7))
          this.add(value2);
        else {
          const [key, ...rest] = path7;
          const node3 = this.get(key, true);
          if (isCollection$1(node3))
            node3.addIn(rest, value2);
          else if (node3 === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value2));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path7) {
        const [key, ...rest] = path7;
        if (rest.length === 0)
          return this.delete(key);
        const node3 = this.get(key, true);
        if (isCollection$1(node3))
          return node3.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path7, keepScalar) {
        const [key, ...rest] = path7;
        const node3 = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && isScalar$1(node3) ? node3.value : node3;
        else
          return isCollection$1(node3) ? node3.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node3) => {
          if (!isPair(node3))
            return false;
          const n14 = node3.value;
          return n14 == null || allowScalar && isScalar$1(n14) && n14.value == null && !n14.commentBefore && !n14.comment && !n14.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path7) {
        const [key, ...rest] = path7;
        if (rest.length === 0)
          return this.has(key);
        const node3 = this.get(key, true);
        return isCollection$1(node3) ? node3.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path7, value2) {
        const [key, ...rest] = path7;
        if (rest.length === 0) {
          this.set(key, value2);
        } else {
          const node3 = this.get(key, true);
          if (isCollection$1(node3))
            node3.setIn(rest, value2);
          else if (node3 === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value2));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    stringifyComment = (str2) => str2.replace(/^(?!$)(?: $)?/gm, "#");
    lineComment = (str2, indent, comment3) => str2.endsWith("\n") ? indentComment(comment3, indent) : comment3.includes("\n") ? "\n" + indentComment(comment3, indent) : (str2.endsWith(" ") ? "" : " ") + comment3;
    FOLD_FLOW = "flow";
    FOLD_BLOCK = "block";
    FOLD_QUOTED = "quoted";
    getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    containsDocumentMarker = (str2) => /^(%|---|\.\.\.)/m.test(str2);
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    MERGE_KEY = "<<";
    isMergeKey = (key) => key === MERGE_KEY || isScalar$1(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
    Pair = class _Pair {
      constructor(key, value2 = null) {
        Object.defineProperty(this, NODE_TYPE, { value: PAIR });
        this.key = key;
        this.value = value2;
      }
      clone(schema2) {
        let { key, value: value2 } = this;
        if (isNode$1(key))
          key = key.clone(schema2);
        if (isNode$1(value2))
          value2 = value2.clone(schema2);
        return new _Pair(key, value2);
      }
      toJSON(_22, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    YAMLMap = class extends Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema2) {
        super(MAP, schema2);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema2, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema2);
        const add = (key, value2) => {
          if (typeof replacer === "function")
            value2 = replacer.call(obj, key, value2);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value2 !== void 0 || keepUndefined)
            map.items.push(createPair(key, value2, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value2] of obj)
            add(key, value2);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add(key, obj[key]);
        }
        if (typeof schema2.sortMapEntries === "function") {
          map.items.sort(schema2.sortMapEntries);
        }
        return map;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair(pair, pair?.value);
        } else
          _pair = new Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (isScalar$1(prev.value) && isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i14 = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i14 === -1)
            this.items.push(_pair);
          else
            this.items.splice(i14, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node3 = it?.value;
        return (!keepScalar && isScalar$1(node3) ? node3.value : node3) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value2) {
        this.add(new Pair(key, value2), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_22, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map);
        for (const item of this.items)
          addPairToJSMap(ctx, map, item);
        return map;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    map$1 = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map, onError2) {
        if (!isMap(map))
          onError2("Expected a mapping for this tag");
        return map;
      },
      createNode: (schema2, obj, ctx) => YAMLMap.from(schema2, obj, ctx)
    };
    YAMLSeq = class extends Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema2) {
        super(SEQ, schema2);
        this.items = [];
      }
      add(value2) {
        this.items.push(value2);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && isScalar$1(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value2) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (isScalar$1(prev) && isScalarValue(value2))
          prev.value = value2;
        else
          this.items[idx] = value2;
      }
      toJSON(_22, ctx) {
        const seq2 = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq2);
        let i14 = 0;
        for (const item of this.items)
          seq2.push(toJS(item, String(i14++), ctx));
        return seq2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema2, obj, ctx) {
        const { replacer } = ctx;
        const seq2 = new this(schema2);
        if (obj && Symbol.iterator in Object(obj)) {
          let i14 = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i14++);
              it = replacer.call(obj, key, it);
            }
            seq2.items.push(createNode(it, void 0, ctx));
          }
        }
        return seq2;
      }
    };
    seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError2) {
        if (!isSeq(seq2))
          onError2("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema2, obj, ctx) => YAMLSeq.from(schema2, obj, ctx)
    };
    string3 = {
      identify: (value2) => typeof value2 === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str2) => str2,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    nullTag = {
      identify: (value2) => value2 == null,
      createNode: () => new Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    boolTag = {
      identify: (value2) => typeof value2 === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str2) => new Scalar(str2[0] === "t" || str2[0] === "T"),
      stringify({ source, value: value2 }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value2 === sv)
            return source;
        }
        return value2 ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    floatNaN$1 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber
    };
    floatExp$1 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2),
      stringify(node3) {
        const num = Number(node3.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node3);
      }
    };
    float$1 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str2) {
        const node3 = new Scalar(parseFloat(str2));
        const dot = str2.indexOf(".");
        if (dot !== -1 && str2[str2.length - 1] === "0")
          node3.minFractionDigits = str2.length - dot - 1;
        return node3;
      },
      stringify: stringifyNumber
    };
    intIdentify$2 = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
    intResolve$1 = (str2, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2.substring(offset), radix);
    intOct$1 = {
      identify: (value2) => intIdentify$2(value2) && value2 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str2, _onError, opt) => intResolve$1(str2, 2, 8, opt),
      stringify: (node3) => intStringify$1(node3, 8, "0o")
    };
    int$1 = {
      identify: intIdentify$2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str2, _onError, opt) => intResolve$1(str2, 0, 10, opt),
      stringify: stringifyNumber
    };
    intHex$1 = {
      identify: (value2) => intIdentify$2(value2) && value2 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str2, _onError, opt) => intResolve$1(str2, 2, 16, opt),
      stringify: (node3) => intStringify$1(node3, 16, "0x")
    };
    schema$2 = [
      map$1,
      seq,
      string3,
      nullTag,
      boolTag,
      intOct$1,
      int$1,
      intHex$1,
      floatNaN$1,
      floatExp$1,
      float$1
    ];
    stringifyJSON = ({ value: value2 }) => JSON.stringify(value2);
    jsonScalars = [
      {
        identify: (value2) => typeof value2 === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str2) => str2,
        stringify: stringifyJSON
      },
      {
        identify: (value2) => value2 == null,
        createNode: () => new Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value2) => typeof value2 === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str2) => str2 === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify$1,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str2, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2, 10),
        stringify: ({ value: value2 }) => intIdentify$1(value2) ? value2.toString() : JSON.stringify(value2)
      },
      {
        identify: (value2) => typeof value2 === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str2) => parseFloat(str2),
        stringify: stringifyJSON
      }
    ];
    jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str2, onError2) {
        onError2(`Unresolved plain scalar ${JSON.stringify(str2)}`);
        return str2;
      }
    };
    schema$1 = [map$1, seq].concat(jsonScalars, jsonError);
    binary = {
      identify: (value2) => value2 instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src3, onError2) {
        if (typeof Buffer === "function") {
          return Buffer.from(src3, "base64");
        } else if (typeof atob === "function") {
          const str2 = atob(src3.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str2.length);
          for (let i14 = 0; i14 < str2.length; ++i14)
            buffer[i14] = str2.charCodeAt(i14);
          return buffer;
        } else {
          onError2("This environment does not support reading binary tags; either Buffer or atob is required");
          return src3;
        }
      },
      stringify({ comment: comment3, type, value: value2 }, ctx, onComment, onChompKeep) {
        const buf = value2;
        let str2;
        if (typeof Buffer === "function") {
          str2 = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s12 = "";
          for (let i14 = 0; i14 < buf.length; ++i14)
            s12 += String.fromCharCode(buf[i14]);
          str2 = btoa(s12);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar.BLOCK_LITERAL;
        if (type !== Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n14 = Math.ceil(str2.length / lineWidth);
          const lines = new Array(n14);
          for (let i14 = 0, o10 = 0; i14 < n14; ++i14, o10 += lineWidth) {
            lines[i14] = str2.substr(o10, lineWidth);
          }
          str2 = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString({ comment: comment3, type, value: str2 }, ctx, onComment, onChompKeep);
      }
    };
    pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    YAMLOMap = class _YAMLOMap extends YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_22, ctx) {
        if (!ctx)
          return super.toJSON(_22);
        const map = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map);
        for (const pair of this.items) {
          let key, value2;
          if (isPair(pair)) {
            key = toJS(pair.key, "", ctx);
            value2 = toJS(pair.value, key, ctx);
          } else {
            key = toJS(pair, "", ctx);
          }
          if (map.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map.set(key, value2);
        }
        return map;
      }
      static from(schema2, iterable, ctx) {
        const pairs2 = createPairs(schema2, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs2.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    omap = {
      collection: "seq",
      identify: (value2) => value2 instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq2, onError2) {
        const pairs2 = resolvePairs(seq2, onError2);
        const seenKeys = [];
        for (const { key } of pairs2.items) {
          if (isScalar$1(key)) {
            if (seenKeys.includes(key.value)) {
              onError2(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs2);
      },
      createNode: (schema2, iterable, ctx) => YAMLOMap.from(schema2, iterable, ctx)
    };
    trueTag = {
      identify: (value2) => value2 === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar(true),
      stringify: boolStringify
    };
    falseTag = {
      identify: (value2) => value2 === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar(false),
      stringify: boolStringify
    };
    floatNaN = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber
    };
    floatExp = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2.replace(/_/g, "")),
      stringify(node3) {
        const num = Number(node3.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node3);
      }
    };
    float = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str2) {
        const node3 = new Scalar(parseFloat(str2.replace(/_/g, "")));
        const dot = str2.indexOf(".");
        if (dot !== -1) {
          const f15 = str2.substring(dot + 1).replace(/_/g, "");
          if (f15[f15.length - 1] === "0")
            node3.minFractionDigits = f15.length;
        }
        return node3;
      },
      stringify: stringifyNumber
    };
    intIdentify = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
    intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 2, opt),
      stringify: (node3) => intStringify(node3, 2, "0b")
    };
    intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 1, 8, opt),
      stringify: (node3) => intStringify(node3, 8, "0")
    };
    int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 0, 10, opt),
      stringify: stringifyNumber
    };
    intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 16, opt),
      stringify: (node3) => intStringify(node3, 16, "0x")
    };
    YAMLSet = class _YAMLSet extends YAMLMap {
      constructor(schema2) {
        super(schema2);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair(key.key, null);
        else
          pair = new Pair(key, null);
        const prev = findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = findPair(this.items, key);
        return !keepPair && isPair(pair) ? isScalar$1(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value2) {
        if (typeof value2 !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value2}`);
        const prev = findPair(this.items, key);
        if (prev && !value2) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value2) {
          this.items.push(new Pair(key));
        }
      }
      toJSON(_22, ctx) {
        return super.toJSON(_22, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema2, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema2);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value2 of iterable) {
            if (typeof replacer === "function")
              value2 = replacer.call(iterable, value2, value2);
            set2.items.push(createPair(value2, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    set = {
      collection: "map",
      identify: (value2) => value2 instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema2, iterable, ctx) => YAMLSet.from(schema2, iterable, ctx),
      resolve(map, onError2) {
        if (isMap(map)) {
          if (map.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map);
          else
            onError2("Set items must all have null values");
        } else
          onError2("Expected a mapping for this tag");
        return map;
      }
    };
    intTime = {
      identify: (value2) => typeof value2 === "bigint" || Number.isInteger(value2),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str2, _onError, { intAsBigInt }) => parseSexagesimal(str2, intAsBigInt),
      stringify: stringifySexagesimal
    };
    floatTime = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str2) => parseSexagesimal(str2, false),
      stringify: stringifySexagesimal
    };
    timestamp = {
      identify: (value2) => value2 instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str2) {
        const match2 = str2.match(timestamp.test);
        if (!match2)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match2.map(Number);
        const millisec = match2[7] ? Number((match2[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match2[8];
        if (tz && tz !== "Z") {
          let d20 = parseSexagesimal(tz, false);
          if (Math.abs(d20) < 30)
            d20 *= 60;
          date -= 6e4 * d20;
        }
        return new Date(date);
      },
      stringify: ({ value: value2 }) => value2.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    schema = [
      map$1,
      seq,
      string3,
      nullTag,
      trueTag,
      falseTag,
      intBin,
      intOct,
      int,
      intHex,
      floatNaN,
      floatExp,
      float,
      binary,
      omap,
      pairs,
      set,
      intTime,
      floatTime,
      timestamp
    ];
    schemas = /* @__PURE__ */ new Map([
      ["core", schema$2],
      ["failsafe", [map$1, seq, string3]],
      ["json", schema$1],
      ["yaml11", schema],
      ["yaml-1.1", schema]
    ]);
    tagsByName = {
      binary,
      bool: boolTag,
      float: float$1,
      floatExp: floatExp$1,
      floatNaN: floatNaN$1,
      floatTime,
      int: int$1,
      intHex: intHex$1,
      intOct: intOct$1,
      intTime,
      map: map$1,
      null: nullTag,
      omap,
      pairs,
      seq,
      set,
      timestamp
    };
    coreKnownTags = {
      "tag:yaml.org,2002:binary": binary,
      "tag:yaml.org,2002:omap": omap,
      "tag:yaml.org,2002:pairs": pairs,
      "tag:yaml.org,2002:set": set,
      "tag:yaml.org,2002:timestamp": timestamp
    };
    sortMapEntriesByKey = (a20, b18) => a20.key < b18.key ? -1 : a20.key > b18.key ? 1 : 0;
    Schema = class _Schema {
      constructor({ compat, customTags, merge: merge3, resolveKnownTags, schema: schema2, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
        this.merge = !!merge3;
        this.name = typeof schema2 === "string" && schema2 || "core";
        this.knownTags = resolveKnownTags ? coreKnownTags : {};
        this.tags = getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, MAP, { value: map$1 });
        Object.defineProperty(this, SCALAR$1, { value: string3 });
        Object.defineProperty(this, SEQ, { value: seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    Document = class _Document {
      constructor(value2, replacer, options2) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, NODE_TYPE, { value: DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options2 === void 0 && replacer) {
          options2 = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          uniqueKeys: true,
          version: "1.2"
        }, options2);
        this.options = opt;
        let { version: version3 } = opt;
        if (options2?._directives) {
          this.directives = options2._directives.atDocument();
          if (this.directives.yaml.explicit)
            version3 = this.directives.yaml.version;
        } else
          this.directives = new Directives({ version: version3 });
        this.setSchema(version3, options2);
        this.contents = value2 === void 0 ? null : this.createNode(value2, _replacer, options2);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [NODE_TYPE]: { value: DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = isNode$1(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value2) {
        if (assertCollection(this.contents))
          this.contents.add(value2);
      }
      /** Adds a value to the document. */
      addIn(path7, value2) {
        if (assertCollection(this.contents))
          this.contents.addIn(path7, value2);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node3, name2) {
        if (!node3.anchor) {
          const prev = anchorNames(this);
          node3.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name2 || prev.has(name2) ? findNewAnchor(name2 || "a", prev) : name2;
        }
        return new Alias(node3.anchor);
      }
      createNode(value2, replacer, options2) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value2 = replacer.call({ "": value2 }, "", value2);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v15) => typeof v15 === "number" || v15 instanceof String || v15 instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options2 === void 0 && replacer) {
          options2 = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag: tag3 } = options2 ?? {};
        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node3 = createNode(value2, tag3, ctx);
        if (flow && isCollection$1(node3))
          node3.flow = true;
        setAnchors();
        return node3;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value2, options2 = {}) {
        const k13 = this.createNode(key, null, options2);
        const v15 = this.createNode(value2, null, options2);
        return new Pair(k13, v15);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path7) {
        if (isEmptyPath(path7)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path7) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return isCollection$1(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path7, keepScalar) {
        if (isEmptyPath(path7))
          return !keepScalar && isScalar$1(this.contents) ? this.contents.value : this.contents;
        return isCollection$1(this.contents) ? this.contents.getIn(path7, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return isCollection$1(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path7) {
        if (isEmptyPath(path7))
          return this.contents !== void 0;
        return isCollection$1(this.contents) ? this.contents.hasIn(path7) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value2) {
        if (this.contents == null) {
          this.contents = collectionFromPath(this.schema, [key], value2);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value2);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path7, value2) {
        if (isEmptyPath(path7)) {
          this.contents = value2;
        } else if (this.contents == null) {
          this.contents = collectionFromPath(this.schema, Array.from(path7), value2);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path7, value2);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version3, options2 = {}) {
        if (typeof version3 === "number")
          version3 = String(version3);
        let opt;
        switch (version3) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new Directives({ version: "1.1" });
            opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version3;
            else
              this.directives = new Directives({ version: version3 });
            opt = { merge: false, resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version3);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options2.schema instanceof Object)
          this.schema = options2.schema;
        else if (opt)
          this.schema = new Schema(Object.assign(opt, options2));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options2 = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options2 && (!Number.isInteger(options2.indent) || Number(options2.indent) <= 0)) {
          const s12 = JSON.stringify(options2.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s12}`);
        }
        return stringifyDocument(this, options2);
      }
    };
    YAMLError = class extends Error {
      constructor(name2, pos, code, message) {
        super();
        this.name = name2;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    prettifyError = (src3, lc) => (error2) => {
      if (error2.pos[0] === -1)
        return;
      error2.linePos = error2.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error2.linePos[0];
      error2.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src3.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "…" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "…";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src3.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "…\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error2.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error2.message += `:

${lineStr}
${pointer}
`;
      }
    };
    startColMsg = "All mapping items must start at the same column";
    blockMsg = "Block collections are not allowed within flow collections";
    isBlock$1 = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "",
      // Unicode next line
      _: " ",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    CN = { composeNode, composeEmptyNode };
    Composer = class {
      constructor(options2 = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new YAMLWarning(pos, code, message));
          else
            this.errors.push(new YAMLParseError(pos, code, message));
        };
        this.directives = new Directives({ version: options2.version || "1.2" });
        this.options = options2;
      }
      decorate(doc, afterDoc) {
        const { comment: comment3, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment3) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment3}` : comment3;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment3;
          } else if (isCollection$1(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment3}
${cb}` : comment3;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment3}
${cb}` : comment3;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error2 = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error2);
            else
              this.doc.errors.push(error2);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    stringify$12 = (cst2) => "type" in cst2 ? stringifyToken(cst2) : stringifyItem(cst2);
    BREAK = Symbol("break visit");
    SKIP = Symbol("skip children");
    REMOVE = Symbol("remove item");
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst2, path7) => {
      let item = cst2;
      for (const [field, index3] of path7) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index3];
        } else
          return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst2, path7) => {
      const parent = visit.itemAtPath(cst2, path7.slice(0, -1));
      const field = path7[path7.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    BOM = "\uFEFF";
    DOCUMENT = "";
    FLOW_END = "";
    SCALAR = "";
    isCollection = (token) => !!token && "items" in token;
    isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    cst = {
      __proto__: null,
      BOM,
      DOCUMENT,
      FLOW_END,
      SCALAR,
      createScalarToken,
      isCollection,
      isScalar,
      prettyToken,
      resolveAsScalar,
      setScalarValue,
      stringify: stringify$12,
      tokenType,
      visit
    };
    hexDigits = new Set("0123456789ABCDEFabcdef");
    tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    flowIndicatorChars = new Set(",[]{}");
    invalidAnchorChars = new Set(" ,[]{}\n\r	");
    isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          if (typeof source !== "string")
            throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i14 = this.pos;
        let ch = this.buffer[i14];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i14];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i14 + 1] === "\n";
        return false;
      }
      charAt(n14) {
        return this.buffer[this.pos + n14];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n14) {
        return this.pos + n14 <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n14) {
        return this.buffer.substr(this.pos, n14);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          let cs = line.indexOf("#");
          while (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n14 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n14);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s12 = this.peek(3);
          if ((s12 === "---" || s12 === "...") && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s12 === "---" ? "doc" : "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n14 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n14;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n14 = yield* this.pushIndicators();
        switch (line[n14]) {
          case "#":
            yield* this.pushCount(line.length - n14);
          // fallthrough
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n14 += yield* this.parseBlockScalarHeader();
            n14 += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n14);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n14 = 0;
        while (line[n14] === ",") {
          n14 += yield* this.pushCount(1);
          n14 += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n14 += yield* this.pushIndicators();
        switch (line[n14]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n14);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          // fallthrough
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote3 = this.charAt(0);
        let end = this.buffer.indexOf(quote3, this.pos + 1);
        if (quote3 === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n14 = 0;
            while (this.buffer[end - 1 - n14] === "\\")
              n14 += 1;
            if (n14 % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i14 = this.pos;
        while (true) {
          const ch = this.buffer[++i14];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop: for (let i15 = this.pos; ch = this.buffer[i15]; ++i15) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case "\n":
              nl = i15;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i15 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === "\n")
                break;
            }
            // fallthrough
            default:
              break loop;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i14 = nl + 1;
        ch = this.buffer[i14];
        while (ch === " ")
          ch = this.buffer[++i14];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
            ch = this.buffer[++i14];
          nl = i14 - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i15 = nl - 1;
            let ch2 = this.buffer[i15];
            if (ch2 === "\r")
              ch2 = this.buffer[--i15];
            const lastChar = i15;
            while (ch2 === " ")
              ch2 = this.buffer[--i15];
            if (ch2 === "\n" && i15 >= this.pos && i15 + 1 + indent > lastChar)
              nl = i15;
            else
              break;
          } while (true);
        }
        yield SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i14 = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i14]) {
          if (ch === ":") {
            const next = this.buffer[i14 + 1];
            if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
              break;
            end = i14;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i14 + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i14 += 1;
                ch = "\n";
                next = this.buffer[i14 + 1];
              } else
                end = i14;
            }
            if (next === "#" || inFlow && flowIndicatorChars.has(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i14 + 1);
              if (cs === -1)
                break;
              i14 = Math.max(i14, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch))
              break;
            end = i14;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n14) {
        if (n14 > 0) {
          yield this.buffer.substr(this.pos, n14);
          this.pos += n14;
          return n14;
        }
        return 0;
      }
      *pushToIndex(i14, allowEmpty) {
        const s12 = this.buffer.slice(this.pos, i14);
        if (s12) {
          yield s12;
          this.pos += s12.length;
          return s12.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          // this is an error
          case "?":
          // this is an error outside flow collections
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i14 = this.pos + 2;
          let ch = this.buffer[i14];
          while (!isEmpty(ch) && ch !== ">")
            ch = this.buffer[++i14];
          return yield* this.pushToIndex(ch === ">" ? i14 + 1 : i14, false);
        } else {
          let i14 = this.pos + 1;
          let ch = this.buffer[i14];
          while (ch) {
            if (tagChars.has(ch))
              ch = this.buffer[++i14];
            else if (ch === "%" && hexDigits.has(this.buffer[i14 + 1]) && hexDigits.has(this.buffer[i14 + 2])) {
              ch = this.buffer[i14 += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i14, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i14 = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i14];
        } while (ch === " " || allowTabs && ch === "	");
        const n14 = i14 - this.pos;
        if (n14 > 0) {
          yield this.buffer.substr(this.pos, n14);
          this.pos = i14;
        }
        return n14;
      }
      *pushUntil(test) {
        let i14 = this.pos;
        let ch = this.buffer[i14];
        while (!test(ch))
          ch = this.buffer[++i14];
        return yield* this.pushToIndex(i14, false);
      }
    };
    LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start2 = this.lineStarts[low - 1];
          return { line: low, col: offset - start2 + 1 };
        };
      }
    };
    Parser2 = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n14) {
        return this.stack[this.stack.length - n14];
      }
      *pop(error2) {
        const token = error2 ?? this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            /* istanbul ignore next should not happen */
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start2 = getFirstKeyStartProps(prev);
          let sep2;
          if (scalar.end) {
            sep2 = scalar.end;
            sep2.push(this.sourceToken);
            delete scalar.end;
          } else
            sep2 = [this.sourceToken];
          const map = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start: start2, key: scalar, sep: sep2 }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          /* istanbul ignore next should not happen */
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map) {
        const it = map.items[map.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map.indent)) {
                const prev = map.items[map.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
          let start2 = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i14 = 0; i14 < it.sep.length; ++i14) {
              const st = it.sep[i14];
              switch (st.type) {
                case "newline":
                  nl.push(i14);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start2 = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start2.push(this.sourceToken);
                map.items.push({ start: start2 });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start2.push(this.sourceToken);
                map.items.push({ start: start2, explicitKey: true });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start3 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start3, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start3 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep2 = it.sep;
                  sep2.push(this.sourceToken);
                  delete it.key, delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start3, key, sep: sep2 }]
                  });
                } else if (start2.length > 0) {
                  it.sep = it.sep.concat(start2, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map.items.push({ start: start2, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs5 = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map.items.push({ start: start2, key: fs5, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs5);
              } else {
                Object.assign(it, { key: fs5, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map);
              if (bv) {
                if (atMapIndent && bv.type !== "block-seq") {
                  map.items.push({ start: start2 });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq2) {
        const it = seq2.items[seq2.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                seq2.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq2.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq2.indent)) {
                const prev = seq2.items[seq2.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq2.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq2.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq2.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq2.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq2.indent) {
          const bv = this.startBlockValue(seq2);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs5 = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs5, sep: [] });
              else if (it.sep)
                this.stack.push(fs5);
              else
                Object.assign(it, { key: fs5, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start2 = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep2 = fc.end.splice(1, fc.end.length);
            sep2.push(this.sourceToken);
            const map = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start: start2, key: fc, sep: sep2 }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start2 = getFirstKeyStartProps(prev);
            start2.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: start2, explicitKey: true }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start2 = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: start2, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start2, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start2.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          // fallthrough
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    YAML = {
      __proto__: null,
      Alias,
      CST: cst,
      Composer,
      Document,
      Lexer,
      LineCounter,
      Pair,
      Parser: Parser2,
      Scalar,
      Schema,
      YAMLError,
      YAMLMap,
      YAMLParseError,
      YAMLSeq,
      YAMLWarning,
      isAlias,
      isCollection: isCollection$1,
      isDocument,
      isMap,
      isNode: isNode$1,
      isPair,
      isScalar: isScalar$1,
      isSeq,
      parse: parse$a,
      parseAllDocuments,
      parseDocument,
      stringify: stringify3,
      visit: visit$1,
      visitAsync
    };
    browser$2 = {
      __proto__: null,
      Alias,
      CST: cst,
      Composer,
      Document,
      Lexer,
      LineCounter,
      Pair,
      Parser: Parser2,
      Scalar,
      Schema,
      YAMLError,
      YAMLMap,
      YAMLParseError,
      YAMLSeq,
      YAMLWarning,
      default: YAML,
      isAlias,
      isCollection: isCollection$1,
      isDocument,
      isMap,
      isNode: isNode$1,
      isPair,
      isScalar: isScalar$1,
      isSeq,
      parse: parse$a,
      parseAllDocuments,
      parseDocument,
      stringify: stringify3,
      visit: visit$1,
      visitAsync
    };
    require$$32 = /* @__PURE__ */ getAugmentedNamespace(browser$2);
    ({ createRequire, createRequireFromPath } = require$$0$8);
    req_1 = req$2;
    req$1 = req_1;
    options = (config2, file) => {
      if (config2.parser && typeof config2.parser === "string") {
        try {
          config2.parser = req$1(config2.parser, file);
        } catch (err) {
          throw new Error(`Loading PostCSS Parser failed: ${err.message}

(@${file})`);
        }
      }
      if (config2.syntax && typeof config2.syntax === "string") {
        try {
          config2.syntax = req$1(config2.syntax, file);
        } catch (err) {
          throw new Error(`Loading PostCSS Syntax failed: ${err.message}

(@${file})`);
        }
      }
      if (config2.stringifier && typeof config2.stringifier === "string") {
        try {
          config2.stringifier = req$1(config2.stringifier, file);
        } catch (err) {
          throw new Error(`Loading PostCSS Stringifier failed: ${err.message}

(@${file})`);
        }
      }
      if (config2.plugins) {
        delete config2.plugins;
      }
      return config2;
    };
    options_1 = options;
    req = req_1;
    load = (plugin2, options2, file) => {
      try {
        if (options2 === null || options2 === void 0 || Object.keys(options2).length === 0) {
          return req(plugin2, file);
        } else {
          return req(plugin2, file)(options2);
        }
      } catch (err) {
        throw new Error(`Loading PostCSS Plugin failed: ${err.message}

(@${file})`);
      }
    };
    plugins = (config2, file) => {
      let plugins2 = [];
      if (Array.isArray(config2.plugins)) {
        plugins2 = config2.plugins.filter(Boolean);
      } else {
        plugins2 = Object.keys(config2.plugins).filter((plugin2) => {
          return config2.plugins[plugin2] !== false ? plugin2 : "";
        }).map((plugin2) => {
          return load(plugin2, config2.plugins[plugin2], file);
        });
      }
      if (plugins2.length && plugins2.length > 0) {
        plugins2.forEach((plugin2, i14) => {
          if (plugin2.default) {
            plugin2 = plugin2.default;
          }
          if (plugin2.postcss === true) {
            plugin2 = plugin2();
          } else if (plugin2.postcss) {
            plugin2 = plugin2.postcss;
          }
          if (
            // eslint-disable-next-line
            !(typeof plugin2 === "object" && Array.isArray(plugin2.plugins) || typeof plugin2 === "object" && plugin2.postcssPlugin || typeof plugin2 === "function")
          ) {
            throw new TypeError(`Invalid PostCSS Plugin found at: plugins[${i14}]

(@${file})`);
          }
        });
      }
      return plugins2;
    };
    plugins_1 = plugins;
    resolve4 = require$$0$4.resolve;
    url$4 = require$$0$9;
    config$1 = src$22;
    yaml = require$$32;
    loadOptions = options_1;
    loadPlugins = plugins_1;
    interopRequireDefault = (obj) => obj && obj.__esModule ? obj : { default: obj };
    processResult = (ctx, result) => {
      const file = result.filepath || "";
      let config2 = interopRequireDefault(result.config).default || {};
      if (typeof config2 === "function") {
        config2 = config2(ctx);
      } else {
        config2 = Object.assign({}, config2, ctx);
      }
      if (!config2.plugins) {
        config2.plugins = [];
      }
      return {
        plugins: loadPlugins(config2, file),
        options: loadOptions(config2, file),
        file
      };
    };
    createContext = (ctx) => {
      ctx = Object.assign({
        cwd: process.cwd(),
        env: "development"
      }, ctx);
      if (!ctx.env) {
        process.env.NODE_ENV = "development";
      }
      return ctx;
    };
    importDefault = async (filepath) => {
      const module3 = await import(url$4.pathToFileURL(filepath).href);
      return module3.default;
    };
    addTypeScriptLoader = (options2 = {}, loader) => {
      const moduleName = "postcss";
      return {
        ...options2,
        searchPlaces: [
          ...options2.searchPlaces || [],
          "package.json",
          `.${moduleName}rc`,
          `.${moduleName}rc.json`,
          `.${moduleName}rc.yaml`,
          `.${moduleName}rc.yml`,
          `.${moduleName}rc.ts`,
          `.${moduleName}rc.cts`,
          `.${moduleName}rc.js`,
          `.${moduleName}rc.cjs`,
          `.${moduleName}rc.mjs`,
          `${moduleName}.config.ts`,
          `${moduleName}.config.cts`,
          `${moduleName}.config.js`,
          `${moduleName}.config.cjs`,
          `${moduleName}.config.mjs`
        ],
        loaders: {
          ...options2.loaders,
          ".yaml": (filepath, content) => yaml.parse(content),
          ".yml": (filepath, content) => yaml.parse(content),
          ".js": importDefault,
          ".cjs": importDefault,
          ".mjs": importDefault,
          ".ts": loader,
          ".cts": loader
        }
      };
    };
    withTypeScriptLoader = (rcFunc) => {
      return (ctx, path7, options2) => {
        return rcFunc(ctx, path7, addTypeScriptLoader(options2, (configFile) => {
          let registerer = { enabled() {
          } };
          try {
            registerer = __require2("ts-node").register({
              // transpile to cjs even if compilerOptions.module in tsconfig is not Node16/NodeNext.
              moduleTypes: { "**/*.cts": "cjs" }
            });
            return __require2(configFile);
          } catch (err) {
            if (err.code === "MODULE_NOT_FOUND") {
              throw new Error(
                `'ts-node' is required for the TypeScript configuration files. Make sure it is installed
Error: ${err.message}`
              );
            }
            throw err;
          } finally {
            registerer.enabled(false);
          }
        }));
      };
    };
    rc = withTypeScriptLoader((ctx, path7, options2) => {
      ctx = createContext(ctx);
      path7 = path7 ? resolve4(path7) : process.cwd();
      return config$1.lilconfig("postcss", options2).search(path7).then((result) => {
        if (!result) {
          throw new Error(`No PostCSS Config found in: ${path7}`);
        }
        return processResult(ctx, result);
      });
    });
    RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:[^\]\\\n\r\u2028\u2029]+|\\.)*\]|[^\/\\\n\r\u2028\u2029]+|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu;
    Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
    Identifier2 = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]+|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu;
    StringLiteral = /(['"])(?:[^'"\\\n\r]+|(?!\1)['"]|\\(?:\r\n|[^]))*(\1)?/y;
    NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
    Template = /[`}](?:[^`\\$]+|\\[^]|\$(?!\{))*(`|\$\{)?/y;
    WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/yu;
    LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y;
    MultiLineComment = /\/\*(?:[^*]+|\*(?!\/))*(\*\/)?/y;
    SingleLineComment = /\/\/.*/y;
    HashbangComment = /^#!.*/;
    JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y;
    JSXIdentifier = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu;
    JSXString = /(['"])(?:[^'"]+|(?!\1)['"])*(\1)?/y;
    JSXText = /[^<>{}]+/y;
    TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
    TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
    KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
    KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
    Newline = RegExp(LineTerminatorSequence.source);
    main$1 = { exports: {} };
    name = "dotenv";
    version$1 = "16.4.5";
    description = "Loads environment variables from .env file";
    main = "lib/main.js";
    types2 = "lib/main.d.ts";
    exports3 = {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        "default": "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    };
    scripts = {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      "lint-readme": "standard-markdown",
      pretest: "npm run lint && npm run dts-check",
      test: "tap tests/*.js --100 -Rspec",
      "test:coverage": "tap --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version"
    };
    repository = {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    };
    funding = "https://dotenvx.com";
    keywords = [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ];
    readmeFilename = "README.md";
    license = "BSD-2-Clause";
    devDependencies = {
      "@definitelytyped/dtslint": "^0.0.133",
      "@types/node": "^18.11.3",
      decache: "^4.6.1",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-markdown": "^7.1.0",
      "standard-version": "^9.5.0",
      tap: "^16.3.0",
      tar: "^6.1.11",
      typescript: "^4.8.4"
    };
    engines = {
      node: ">=12"
    };
    browser$1 = {
      fs: false
    };
    require$$4 = {
      name,
      version: version$1,
      description,
      main,
      types: types2,
      exports: exports3,
      scripts,
      repository,
      funding,
      keywords,
      readmeFilename,
      license,
      devDependencies,
      engines,
      browser: browser$1
    };
    fs$9 = require$$0__default3;
    path$9 = require$$0$4;
    os$2 = require$$2;
    crypto$1 = require$$3$1;
    packageJson = require$$4;
    version2 = packageJson.version;
    LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config,
      decrypt,
      parse: parse$9,
      populate
    };
    main$1.exports.configDotenv = DotenvModule.configDotenv;
    main$1.exports._configVault = DotenvModule._configVault;
    main$1.exports._parseVault = DotenvModule._parseVault;
    main$1.exports.config = DotenvModule.config;
    main$1.exports.decrypt = DotenvModule.decrypt;
    parse_1$1 = main$1.exports.parse = DotenvModule.parse;
    main$1.exports.populate = DotenvModule.populate;
    main$1.exports = DotenvModule;
    modulePreloadPolyfillId = "vite/modulepreload-polyfill";
    resolvedModulePreloadPolyfillId = "\0" + modulePreloadPolyfillId + ".js";
    moduleScriptRE = /[ \t]*<script[^>]*type\s*=\s*(?:"module"|'module'|module)[^>]*>/i;
    modulePreloadLinkRE = /[ \t]*<link[^>]*rel\s*=\s*(?:"modulepreload"|'modulepreload'|modulepreload)[\s\S]*?\/>/i;
    importMapAppendRE = new RegExp(
      [moduleScriptRE, modulePreloadLinkRE].map((r9) => r9.source).join("|"),
      "i"
    );
    decoder = new TextDecoder();
    cssModuleRE = new RegExp(`\\.module${CSS_LANGS_RE.source}`);
    functionCallRE = /^[A-Z_][\w-]*\(/i;
    nonEscapedDoubleQuoteRe = /(?<!\\)"/g;
    importPostcssImport = createCachedImport(() => Promise.resolve().then(() => (init_dep_GkhNNjoY(), dep_GkhNNjoY_exports)).then(function(n14) {
      return n14.i;
    }));
    importPostcssModules = createCachedImport(() => Promise.resolve().then(() => (init_dep_BASfdaBA(), dep_BASfdaBA_exports)).then(function(n14) {
      return n14.i;
    }));
    importPostcss = createCachedImport(() => Promise.resolve().then(() => (init_postcss_8_4(), postcss_8_4_exports)));
    cssUrlRE = /(?<=^|[^\w\-\u0080-\uffff])url\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/;
    cssImageSetRE = /(?<=image-set\()((?:[\w\-]{1,256}\([^)]*\)|[^)])*)(?=\))/;
    UrlRewritePostcssPlugin = (opts) => {
      if (!opts) {
        throw new Error("base or replace is required");
      }
      return {
        postcssPlugin: "vite-url-rewrite",
        Once(root3) {
          const promises2 = [];
          root3.walkDecls((declaration) => {
            const importer = declaration.source?.input.file;
            if (!importer) {
              opts.logger.warnOnce(
                "\nA PostCSS plugin did not pass the `from` option to `postcss.parse`. This may cause imported assets to be incorrectly transformed. If you've recently added a PostCSS plugin that raised this warning, please contact the package author to fix the issue."
              );
            }
            const isCssUrl = cssUrlRE.test(declaration.value);
            const isCssImageSet = cssImageSetRE.test(declaration.value);
            if (isCssUrl || isCssImageSet) {
              const replacerForDeclaration = (rawUrl) => {
                return opts.replacer(rawUrl, importer);
              };
              const rewriterToUse = isCssImageSet ? rewriteCssImageSet : rewriteCssUrls;
              promises2.push(
                rewriterToUse(declaration.value, replacerForDeclaration).then(
                  (url2) => {
                    declaration.value = url2;
                  }
                )
              );
            }
          });
          if (promises2.length) {
            return Promise.all(promises2);
          }
        }
      };
    };
    UrlRewritePostcssPlugin.postcss = true;
    cssNotProcessedRE = /(?:gradient|element|cross-fade|image)\(/;
    importLightningCSS = createCachedImport(() => import(`https://esm.sh/lightningcss@1.27.0#${Math.random()}`));
    new Set(builtinModules);
    own$1 = {}.hasOwnProperty;
    classRegExp = /^([A-Z][a-z\d]*)+$/;
    kTypes = /* @__PURE__ */ new Set([
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ]);
    messages = /* @__PURE__ */ new Map();
    nodeInternalPrefix = "__node_internal_";
    createError2(
      "ERR_INVALID_ARG_TYPE",
      /**
       * @param {string} name
       * @param {Array<string> | string} expected
       * @param {unknown} actual
       */
      (name2, expected, actual) => {
        assert$1(typeof name2 === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let message = "The ";
        if (name2.endsWith(" argument")) {
          message += `${name2} `;
        } else {
          const type = name2.includes(".") ? "property" : "argument";
          message += `"${name2}" ${type} `;
        }
        message += "must be ";
        const types3 = [];
        const instances = [];
        const other = [];
        for (const value2 of expected) {
          assert$1(
            typeof value2 === "string",
            "All expected entries have to be of type string"
          );
          if (kTypes.has(value2)) {
            types3.push(value2.toLowerCase());
          } else if (classRegExp.exec(value2) === null) {
            assert$1(
              value2 !== "object",
              'The value "object" should be written as "Object"'
            );
            other.push(value2);
          } else {
            instances.push(value2);
          }
        }
        if (instances.length > 0) {
          const pos = types3.indexOf("object");
          if (pos !== -1) {
            types3.slice(pos, 1);
            instances.push("Object");
          }
        }
        if (types3.length > 0) {
          message += `${types3.length > 1 ? "one of type" : "of type"} ${formatList(
            types3,
            "or"
          )}`;
          if (instances.length > 0 || other.length > 0) message += " or ";
        }
        if (instances.length > 0) {
          message += `an instance of ${formatList(instances, "or")}`;
          if (other.length > 0) message += " or ";
        }
        if (other.length > 0) {
          if (other.length > 1) {
            message += `one of ${formatList(other, "or")}`;
          } else {
            if (other[0].toLowerCase() !== other[0]) message += "an ";
            message += `${other[0]}`;
          }
        }
        message += `. Received ${determineSpecificType(actual)}`;
        return message;
      },
      TypeError
    );
    createError2(
      "ERR_INVALID_MODULE_SPECIFIER",
      /**
       * @param {string} request
       * @param {string} reason
       * @param {string} [base]
       */
      (request, reason, base = void 0) => {
        return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
      },
      TypeError
    );
    createError2(
      "ERR_INVALID_PACKAGE_CONFIG",
      /**
       * @param {string} path
       * @param {string} [base]
       * @param {string} [message]
       */
      (path7, base, message) => {
        return `Invalid package config ${path7}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
      },
      Error
    );
    createError2(
      "ERR_INVALID_PACKAGE_TARGET",
      /**
       * @param {string} packagePath
       * @param {string} key
       * @param {unknown} target
       * @param {boolean} [isImport=false]
       * @param {string} [base]
       */
      (packagePath, key, target, isImport = false, base = void 0) => {
        const relatedError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
        if (key === ".") {
          assert$1(isImport === false);
          return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
        }
        return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
          target
        )} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
      },
      Error
    );
    createError2(
      "ERR_MODULE_NOT_FOUND",
      /**
       * @param {string} path
       * @param {string} base
       * @param {boolean} [exactUrl]
       */
      (path7, base, exactUrl = false) => {
        return `Cannot find ${exactUrl ? "module" : "package"} '${path7}' imported from ${base}`;
      },
      Error
    );
    createError2(
      "ERR_NETWORK_IMPORT_DISALLOWED",
      "import of '%s' by %s is not supported: %s",
      Error
    );
    createError2(
      "ERR_PACKAGE_IMPORT_NOT_DEFINED",
      /**
       * @param {string} specifier
       * @param {string} packagePath
       * @param {string} base
       */
      (specifier, packagePath, base) => {
        return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
      },
      TypeError
    );
    createError2(
      "ERR_PACKAGE_PATH_NOT_EXPORTED",
      /**
       * @param {string} packagePath
       * @param {string} subpath
       * @param {string} [base]
       */
      (packagePath, subpath, base = void 0) => {
        if (subpath === ".")
          return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
        return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
      },
      Error
    );
    createError2(
      "ERR_UNSUPPORTED_DIR_IMPORT",
      "Directory import '%s' is not supported resolving ES modules imported from %s",
      Error
    );
    createError2(
      "ERR_UNSUPPORTED_RESOLVE_REQUEST",
      'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',
      TypeError
    );
    createError2(
      "ERR_UNKNOWN_FILE_EXTENSION",
      /**
       * @param {string} extension
       * @param {string} path
       */
      (extension2, path7) => {
        return `Unknown file extension "${extension2}" for ${path7}`;
      },
      TypeError
    );
    createError2(
      "ERR_INVALID_ARG_VALUE",
      /**
       * @param {string} name
       * @param {unknown} value
       * @param {string} [reason='is invalid']
       */
      (name2, value2, reason = "is invalid") => {
        let inspected = inspect(value2);
        if (inspected.length > 128) {
          inspected = `${inspected.slice(0, 128)}...`;
        }
        const type = name2.includes(".") ? "property" : "argument";
        return `The ${type} '${name2}' ${reason}. Received ${inspected}`;
      },
      TypeError
      // Note: extra classes have been shaken out.
      // , RangeError
    );
    captureLargerStackTrace = hideStackFrames(
      /**
       * @param {Error} error
       * @returns {Error}
       */
      // @ts-expect-error: fine
      function(error2) {
        const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
        if (stackTraceLimitIsWritable) {
          userStackTraceLimit = Error.stackTraceLimit;
          Error.stackTraceLimit = Number.POSITIVE_INFINITY;
        }
        Error.captureStackTrace(error2);
        if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
        return error2;
      }
    );
    ({ isMatch: isMatch$1, scan } = micromatch$2);
    ({ basename: basename2, dirname: dirname2, relative: relative2, join } = posix$1);
    src2 = { exports: {} };
    browser = { exports: {} };
    debug$f = { exports: {} };
    node2 = { exports: {} };
    if (typeof process !== "undefined" && process.type === "renderer") {
      src2.exports = requireBrowser();
    } else {
      src2.exports = requireNode();
    }
    srcExports2 = src2.exports;
    encodeurl = encodeUrl$1;
    ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
    UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
    UNMATCHED_SURROGATE_PAIR_REPLACE = "$1�$2";
    matchHtmlRegExp = /["'&<>]/;
    escapeHtml_1 = escapeHtml$1;
    onFinished$2 = { exports: {} };
    eeFirst = first$1;
    onFinished$2.exports = onFinished$1;
    onFinished$2.exports.isFinished = isFinished$1;
    first = eeFirst;
    defer$2 = typeof setImmediate === "function" ? setImmediate : function(fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    onFinishedExports = onFinished$2.exports;
    parseurl$1 = { exports: {} };
    url$3 = require$$0$9;
    parse$8 = url$3.parse;
    Url = url$3.Url;
    parseurl$1.exports = parseurl;
    parseurl$1.exports.original = originalurl;
    parseurlExports = parseurl$1.exports;
    require$$0$12 = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "306": "(Unused)",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Unordered Collection",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    codes = require$$0$12;
    statuses$1 = status;
    status.STATUS_CODES = codes;
    status.codes = populateStatusesMap(status, codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    unpipe_1 = unpipe$1;
    debug$e = srcExports2("finalhandler");
    encodeUrl = encodeurl;
    escapeHtml = escapeHtml_1;
    onFinished = onFinishedExports;
    parseUrl$2 = parseurlExports;
    statuses = statuses$1;
    unpipe = unpipe_1;
    DOUBLE_SPACE_REGEXP = /\x20{2}/g;
    NEWLINE_REGEXP = /\n/g;
    defer$1 = typeof setImmediate === "function" ? setImmediate : function(fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    isFinished = onFinished.isFinished;
    finalhandler_1 = finalhandler$1;
    utilsMerge = { exports: {} };
    (function(module3, exports4) {
      module3.exports = function(a20, b18) {
        if (a20 && b18) {
          for (var key in b18) {
            a20[key] = b18[key];
          }
        }
        return a20;
      };
    })(utilsMerge);
    utilsMergeExports = utilsMerge.exports;
    debug$d = srcExports2("connect:dispatcher");
    EventEmitter$3 = require$$0$7.EventEmitter;
    finalhandler = finalhandler_1;
    http$4 = require$$1;
    parseUrl$1 = parseurlExports;
    env = "development";
    proto = {};
    defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    proto.use = function use(route, fn) {
      var handle2 = fn;
      var path7 = route;
      if (typeof route !== "string") {
        handle2 = route;
        path7 = "/";
      }
      if (typeof handle2.handle === "function") {
        var server = handle2;
        server.route = path7;
        handle2 = function(req2, res, next) {
          server.handle(req2, res, next);
        };
      }
      if (handle2 instanceof http$4.Server) {
        handle2 = handle2.listeners("request")[0];
      }
      if (path7[path7.length - 1] === "/") {
        path7 = path7.slice(0, -1);
      }
      debug$d("use %s %s", path7 || "/", handle2.name || "anonymous");
      this.stack.push({ route: path7, handle: handle2 });
      return this;
    };
    proto.handle = function handle(req2, res, out) {
      var index3 = 0;
      var protohost = getProtohost(req2.url) || "";
      var removed = "";
      var slashAdded = false;
      var stack = this.stack;
      var done = out || finalhandler(req2, res, {
        env,
        onerror: logerror
      });
      req2.originalUrl = req2.originalUrl || req2.url;
      function next(err) {
        if (slashAdded) {
          req2.url = req2.url.substr(1);
          slashAdded = false;
        }
        if (removed.length !== 0) {
          req2.url = protohost + removed + req2.url.substr(protohost.length);
          removed = "";
        }
        var layer = stack[index3++];
        if (!layer) {
          defer(done, err);
          return;
        }
        var path7 = parseUrl$1(req2).pathname || "/";
        var route = layer.route;
        if (path7.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {
          return next(err);
        }
        var c16 = path7.length > route.length && path7[route.length];
        if (c16 && c16 !== "/" && c16 !== ".") {
          return next(err);
        }
        if (route.length !== 0 && route !== "/") {
          removed = route;
          req2.url = protohost + req2.url.substr(protohost.length + removed.length);
          if (!protohost && req2.url[0] !== "/") {
            req2.url = "/" + req2.url;
            slashAdded = true;
          }
        }
        call(layer.handle, route, err, req2, res, next);
      }
      next();
    };
    proto.listen = function listen() {
      var server = http$4.createServer(this);
      return server.listen.apply(server, arguments);
    };
    lib2 = { exports: {} };
    getOwnPropertySymbols = Object.getOwnPropertySymbols;
    hasOwnProperty2 = Object.prototype.hasOwnProperty;
    propIsEnumerable = Object.prototype.propertyIsEnumerable;
    objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s12 = 1; s12 < arguments.length; s12++) {
        from = Object(arguments[s12]);
        for (var key in from) {
          if (hasOwnProperty2.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i14 = 0; i14 < symbols.length; i14++) {
            if (propIsEnumerable.call(from, symbols[i14])) {
              to[symbols[i14]] = from[symbols[i14]];
            }
          }
        }
      }
      return to;
    };
    vary$1 = { exports: {} };
    vary$1.exports = vary;
    vary$1.exports.append = append;
    FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
    varyExports = vary$1.exports;
    (function() {
      var assign = objectAssign;
      var vary2 = varyExports;
      var defaults2 = {
        origin: "*",
        methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
        preflightContinue: false,
        optionsSuccessStatus: 204
      };
      function isString3(s12) {
        return typeof s12 === "string" || s12 instanceof String;
      }
      function isOriginAllowed(origin, allowedOrigin) {
        if (Array.isArray(allowedOrigin)) {
          for (var i14 = 0; i14 < allowedOrigin.length; ++i14) {
            if (isOriginAllowed(origin, allowedOrigin[i14])) {
              return true;
            }
          }
          return false;
        } else if (isString3(allowedOrigin)) {
          return origin === allowedOrigin;
        } else if (allowedOrigin instanceof RegExp) {
          return allowedOrigin.test(origin);
        } else {
          return !!allowedOrigin;
        }
      }
      function configureOrigin(options2, req2) {
        var requestOrigin = req2.headers.origin, headers = [], isAllowed;
        if (!options2.origin || options2.origin === "*") {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: "*"
          }]);
        } else if (isString3(options2.origin)) {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: options2.origin
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        } else {
          isAllowed = isOriginAllowed(requestOrigin, options2.origin);
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: isAllowed ? requestOrigin : false
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        }
        return headers;
      }
      function configureMethods(options2) {
        var methods = options2.methods;
        if (methods.join) {
          methods = options2.methods.join(",");
        }
        return {
          key: "Access-Control-Allow-Methods",
          value: methods
        };
      }
      function configureCredentials(options2) {
        if (options2.credentials === true) {
          return {
            key: "Access-Control-Allow-Credentials",
            value: "true"
          };
        }
        return null;
      }
      function configureAllowedHeaders(options2, req2) {
        var allowedHeaders = options2.allowedHeaders || options2.headers;
        var headers = [];
        if (!allowedHeaders) {
          allowedHeaders = req2.headers["access-control-request-headers"];
          headers.push([{
            key: "Vary",
            value: "Access-Control-Request-Headers"
          }]);
        } else if (allowedHeaders.join) {
          allowedHeaders = allowedHeaders.join(",");
        }
        if (allowedHeaders && allowedHeaders.length) {
          headers.push([{
            key: "Access-Control-Allow-Headers",
            value: allowedHeaders
          }]);
        }
        return headers;
      }
      function configureExposedHeaders(options2) {
        var headers = options2.exposedHeaders;
        if (!headers) {
          return null;
        } else if (headers.join) {
          headers = headers.join(",");
        }
        if (headers && headers.length) {
          return {
            key: "Access-Control-Expose-Headers",
            value: headers
          };
        }
        return null;
      }
      function configureMaxAge(options2) {
        var maxAge = (typeof options2.maxAge === "number" || options2.maxAge) && options2.maxAge.toString();
        if (maxAge && maxAge.length) {
          return {
            key: "Access-Control-Max-Age",
            value: maxAge
          };
        }
        return null;
      }
      function applyHeaders(headers, res) {
        for (var i14 = 0, n14 = headers.length; i14 < n14; i14++) {
          var header = headers[i14];
          if (header) {
            if (Array.isArray(header)) {
              applyHeaders(header, res);
            } else if (header.key === "Vary" && header.value) {
              vary2(res, header.value);
            } else if (header.value) {
              res.setHeader(header.key, header.value);
            }
          }
        }
      }
      function cors(options2, req2, res, next) {
        var headers = [], method = req2.method && req2.method.toUpperCase && req2.method.toUpperCase();
        if (method === "OPTIONS") {
          headers.push(configureOrigin(options2, req2));
          headers.push(configureCredentials(options2));
          headers.push(configureMethods(options2));
          headers.push(configureAllowedHeaders(options2, req2));
          headers.push(configureMaxAge(options2));
          headers.push(configureExposedHeaders(options2));
          applyHeaders(headers, res);
          if (options2.preflightContinue) {
            next();
          } else {
            res.statusCode = options2.optionsSuccessStatus;
            res.setHeader("Content-Length", "0");
            res.end();
          }
        } else {
          headers.push(configureOrigin(options2, req2));
          headers.push(configureCredentials(options2));
          headers.push(configureExposedHeaders(options2));
          applyHeaders(headers, res);
          next();
        }
      }
      function middlewareWrapper(o10) {
        var optionsCallback = null;
        if (typeof o10 === "function") {
          optionsCallback = o10;
        } else {
          optionsCallback = function(req2, cb) {
            cb(null, o10);
          };
        }
        return function corsMiddleware(req2, res, next) {
          optionsCallback(req2, function(err, options2) {
            if (err) {
              next(err);
            } else {
              var corsOptions = assign({}, defaults2, options2);
              var originCallback = null;
              if (corsOptions.origin && typeof corsOptions.origin === "function") {
                originCallback = corsOptions.origin;
              } else if (corsOptions.origin) {
                originCallback = function(origin, cb) {
                  cb(null, corsOptions.origin);
                };
              }
              if (originCallback) {
                originCallback(req2.headers.origin, function(err2, origin) {
                  if (err2 || !origin) {
                    next(err2);
                  } else {
                    corsOptions.origin = origin;
                    cors(corsOptions, req2, res, next);
                  }
                });
              } else {
                next();
              }
            }
          });
        };
      }
      lib2.exports = middlewareWrapper;
    })();
    libExports = lib2.exports;
    chokidar = {};
    fs$8 = require$$0__default3;
    ({ Readable } = require$$0$6);
    sysPath$3 = require$$0$4;
    ({ promisify: promisify$3 } = require$$0$5);
    picomatch$1 = picomatch$3;
    readdir$1 = promisify$3(fs$8.readdir);
    stat$3 = promisify$3(fs$8.stat);
    lstat$2 = promisify$3(fs$8.lstat);
    realpath$1 = promisify$3(fs$8.realpath);
    BANG$2 = "!";
    RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
    NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
    FILE_TYPE = "files";
    DIR_TYPE = "directories";
    FILE_DIR_TYPE = "files_directories";
    EVERYTHING_TYPE = "all";
    ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
    isNormalFlowError = (error2) => NORMAL_FLOW_ERRORS.has(error2.code);
    [maj, min] = process.versions.node.split(".").slice(0, 2).map((n14) => Number.parseInt(n14, 10));
    wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
    normalizeFilter = (filter2) => {
      if (filter2 === void 0) return;
      if (typeof filter2 === "function") return filter2;
      if (typeof filter2 === "string") {
        const glob = picomatch$1(filter2.trim());
        return (entry2) => glob(entry2.basename);
      }
      if (Array.isArray(filter2)) {
        const positive = [];
        const negative = [];
        for (const item of filter2) {
          const trimmed = item.trim();
          if (trimmed.charAt(0) === BANG$2) {
            negative.push(picomatch$1(trimmed.slice(1)));
          } else {
            positive.push(picomatch$1(trimmed));
          }
        }
        if (negative.length > 0) {
          if (positive.length > 0) {
            return (entry2) => positive.some((f15) => f15(entry2.basename)) && !negative.some((f15) => f15(entry2.basename));
          }
          return (entry2) => !negative.some((f15) => f15(entry2.basename));
        }
        return (entry2) => positive.some((f15) => f15(entry2.basename));
      }
    };
    ReaddirpStream = class _ReaddirpStream extends Readable {
      static get defaultOptions() {
        return {
          root: ".",
          /* eslint-disable no-unused-vars */
          fileFilter: (path7) => true,
          directoryFilter: (path7) => true,
          /* eslint-enable no-unused-vars */
          type: FILE_TYPE,
          lstat: false,
          depth: 2147483648,
          alwaysStat: false
        };
      }
      constructor(options2 = {}) {
        super({
          objectMode: true,
          autoDestroy: true,
          highWaterMark: options2.highWaterMark || 4096
        });
        const opts = { ..._ReaddirpStream.defaultOptions, ...options2 };
        const { root: root3, type } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? lstat$2 : stat$3;
        if (wantBigintFsStats) {
          this._stat = (path7) => statMethod(path7, { bigint: true });
        } else {
          this._stat = statMethod;
        }
        this._maxDepth = opts.depth;
        this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsEverything = type === EVERYTHING_TYPE;
        this._root = sysPath$3.resolve(root3);
        this._isDirent = "Dirent" in fs$8 && !opts.alwaysStat;
        this._statsProp = this._isDirent ? "dirent" : "stats";
        this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
        this.parents = [this._exploreDir(root3, 1)];
        this.reading = false;
        this.parent = void 0;
      }
      async _read(batch) {
        if (this.reading) return;
        this.reading = true;
        try {
          while (!this.destroyed && batch > 0) {
            const { path: path7, depth: depth2, files = [] } = this.parent || {};
            if (files.length > 0) {
              const slice2 = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path7));
              for (const entry2 of await Promise.all(slice2)) {
                if (this.destroyed) return;
                const entryType = await this._getEntryType(entry2);
                if (entryType === "directory" && this._directoryFilter(entry2)) {
                  if (depth2 <= this._maxDepth) {
                    this.parents.push(this._exploreDir(entry2.fullPath, depth2 + 1));
                  }
                  if (this._wantsDir) {
                    this.push(entry2);
                    batch--;
                  }
                } else if ((entryType === "file" || this._includeAsFile(entry2)) && this._fileFilter(entry2)) {
                  if (this._wantsFile) {
                    this.push(entry2);
                    batch--;
                  }
                }
              }
            } else {
              const parent = this.parents.pop();
              if (!parent) {
                this.push(null);
                break;
              }
              this.parent = await parent;
              if (this.destroyed) return;
            }
          }
        } catch (error2) {
          this.destroy(error2);
        } finally {
          this.reading = false;
        }
      }
      async _exploreDir(path7, depth2) {
        let files;
        try {
          files = await readdir$1(path7, this._rdOptions);
        } catch (error2) {
          this._onError(error2);
        }
        return { files, depth: depth2, path: path7 };
      }
      async _formatEntry(dirent, path7) {
        let entry2;
        try {
          const basename3 = this._isDirent ? dirent.name : dirent;
          const fullPath = sysPath$3.resolve(sysPath$3.join(path7, basename3));
          entry2 = { path: sysPath$3.relative(this._root, fullPath), fullPath, basename: basename3 };
          entry2[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        } catch (err) {
          this._onError(err);
        }
        return entry2;
      }
      _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
          this.emit("warn", err);
        } else {
          this.destroy(err);
        }
      }
      async _getEntryType(entry2) {
        const stats = entry2 && entry2[this._statsProp];
        if (!stats) {
          return;
        }
        if (stats.isFile()) {
          return "file";
        }
        if (stats.isDirectory()) {
          return "directory";
        }
        if (stats && stats.isSymbolicLink()) {
          const full = entry2.fullPath;
          try {
            const entryRealPath = await realpath$1(full);
            const entryRealPathStats = await lstat$2(entryRealPath);
            if (entryRealPathStats.isFile()) {
              return "file";
            }
            if (entryRealPathStats.isDirectory()) {
              const len = entryRealPath.length;
              if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {
                const recursiveError = new Error(
                  `Circular symlink detected: "${full}" points to "${entryRealPath}"`
                );
                recursiveError.code = RECURSIVE_ERROR_CODE;
                return this._onError(recursiveError);
              }
              return "directory";
            }
          } catch (error2) {
            this._onError(error2);
          }
        }
      }
      _includeAsFile(entry2) {
        const stats = entry2 && entry2[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
      }
    };
    readdirp$1 = (root3, options2 = {}) => {
      let type = options2.entryType || options2.type;
      if (type === "both") type = FILE_DIR_TYPE;
      if (type) options2.type = type;
      if (!root3) {
        throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
      } else if (typeof root3 !== "string") {
        throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
      } else if (type && !ALL_TYPES.includes(type)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
      }
      options2.root = root3;
      return new ReaddirpStream(options2);
    };
    readdirpPromise = (root3, options2 = {}) => {
      return new Promise((resolve5, reject) => {
        const files = [];
        readdirp$1(root3, options2).on("data", (entry2) => files.push(entry2)).on("end", () => resolve5(files)).on("error", (error2) => reject(error2));
      });
    };
    readdirp$1.promise = readdirpPromise;
    readdirp$1.ReaddirpStream = ReaddirpStream;
    readdirp$1.default = readdirp$1;
    readdirp_1 = readdirp$1;
    anymatch$2 = { exports: {} };
    normalizePath$2 = function(path7, stripTrailing) {
      if (typeof path7 !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path7 === "\\" || path7 === "/") return "/";
      var len = path7.length;
      if (len <= 1) return path7;
      var prefix = "";
      if (len > 4 && path7[3] === "\\") {
        var ch = path7[2];
        if ((ch === "?" || ch === ".") && path7.slice(0, 2) === "\\\\") {
          path7 = path7.slice(2);
          prefix = "//";
        }
      }
      var segs = path7.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
    anymatch_1 = anymatch$2.exports;
    Object.defineProperty(anymatch_1, "__esModule", { value: true });
    picomatch = picomatch$3;
    normalizePath$1 = normalizePath$2;
    BANG$1 = "!";
    DEFAULT_OPTIONS = { returnIndex: false };
    arrify$1 = (item) => Array.isArray(item) ? item : [item];
    createPattern = (matcher2, options2) => {
      if (typeof matcher2 === "function") {
        return matcher2;
      }
      if (typeof matcher2 === "string") {
        const glob = picomatch(matcher2, options2);
        return (string4) => matcher2 === string4 || glob(string4);
      }
      if (matcher2 instanceof RegExp) {
        return (string4) => matcher2.test(string4);
      }
      return (string4) => false;
    };
    matchPatterns = (patterns, negPatterns, args, returnIndex) => {
      const isList = Array.isArray(args);
      const _path2 = isList ? args[0] : args;
      if (!isList && typeof _path2 !== "string") {
        throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path2));
      }
      const path7 = normalizePath$1(_path2);
      for (let index3 = 0; index3 < negPatterns.length; index3++) {
        const nglob = negPatterns[index3];
        if (nglob(path7)) {
          return returnIndex ? -1 : false;
        }
      }
      const applied = isList && [path7].concat(args.slice(1));
      for (let index3 = 0; index3 < patterns.length; index3++) {
        const pattern2 = patterns[index3];
        if (isList ? pattern2(...applied) : pattern2(path7)) {
          return returnIndex ? index3 : true;
        }
      }
      return returnIndex ? -1 : false;
    };
    anymatch$1 = (matchers, testString, options2 = DEFAULT_OPTIONS) => {
      if (matchers == null) {
        throw new TypeError("anymatch: specify first argument");
      }
      const opts = typeof options2 === "boolean" ? { returnIndex: options2 } : options2;
      const returnIndex = opts.returnIndex || false;
      const mtchers = arrify$1(matchers);
      const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG$1).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
      const patterns = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG$1).map((matcher2) => createPattern(matcher2, opts));
      if (testString == null) {
        return (testString2, ri = false) => {
          const returnIndex2 = typeof ri === "boolean" ? ri : false;
          return matchPatterns(patterns, negatedGlobs, testString2, returnIndex2);
        };
      }
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    };
    anymatch$1.default = anymatch$1;
    anymatch$2.exports = anymatch$1;
    anymatchExports = anymatch$2.exports;
    require$$02 = [
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "appimage",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "flatpak",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "odp",
      "ods",
      "odt",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "ott",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rpm",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "snap",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ];
    binaryExtensions$1 = require$$02;
    path$8 = require$$0$4;
    binaryExtensions = binaryExtensions$1;
    extensions = new Set(binaryExtensions);
    isBinaryPath$1 = (filePath) => extensions.has(path$8.extname(filePath).slice(1).toLowerCase());
    constants$1 = {};
    (function(exports4) {
      const { sep: sep2 } = require$$0$4;
      const { platform: platform2 } = process;
      const os2 = require$$2;
      exports4.EV_ALL = "all";
      exports4.EV_READY = "ready";
      exports4.EV_ADD = "add";
      exports4.EV_CHANGE = "change";
      exports4.EV_ADD_DIR = "addDir";
      exports4.EV_UNLINK = "unlink";
      exports4.EV_UNLINK_DIR = "unlinkDir";
      exports4.EV_RAW = "raw";
      exports4.EV_ERROR = "error";
      exports4.STR_DATA = "data";
      exports4.STR_END = "end";
      exports4.STR_CLOSE = "close";
      exports4.FSEVENT_CREATED = "created";
      exports4.FSEVENT_MODIFIED = "modified";
      exports4.FSEVENT_DELETED = "deleted";
      exports4.FSEVENT_MOVED = "moved";
      exports4.FSEVENT_CLONED = "cloned";
      exports4.FSEVENT_UNKNOWN = "unknown";
      exports4.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;
      exports4.FSEVENT_TYPE_FILE = "file";
      exports4.FSEVENT_TYPE_DIRECTORY = "directory";
      exports4.FSEVENT_TYPE_SYMLINK = "symlink";
      exports4.KEY_LISTENERS = "listeners";
      exports4.KEY_ERR = "errHandlers";
      exports4.KEY_RAW = "rawEmitters";
      exports4.HANDLER_KEYS = [exports4.KEY_LISTENERS, exports4.KEY_ERR, exports4.KEY_RAW];
      exports4.DOT_SLASH = `.${sep2}`;
      exports4.BACK_SLASH_RE = /\\/g;
      exports4.DOUBLE_SLASH_RE = /\/\//;
      exports4.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
      exports4.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
      exports4.REPLACER_RE = /^\.[/\\]/;
      exports4.SLASH = "/";
      exports4.SLASH_SLASH = "//";
      exports4.BRACE_START = "{";
      exports4.BANG = "!";
      exports4.ONE_DOT = ".";
      exports4.TWO_DOTS = "..";
      exports4.STAR = "*";
      exports4.GLOBSTAR = "**";
      exports4.ROOT_GLOBSTAR = "/**/*";
      exports4.SLASH_GLOBSTAR = "/**";
      exports4.DIR_SUFFIX = "Dir";
      exports4.ANYMATCH_OPTS = { dot: true };
      exports4.STRING_TYPE = "string";
      exports4.FUNCTION_TYPE = "function";
      exports4.EMPTY_STR = "";
      exports4.EMPTY_FN = () => {
      };
      exports4.IDENTITY_FN = (val) => val;
      exports4.isWindows = platform2 === "win32";
      exports4.isMacos = platform2 === "darwin";
      exports4.isLinux = platform2 === "linux";
      exports4.isIBMi = os2.type() === "OS400";
    })(constants$1);
    fs$7 = require$$0__default3;
    sysPath$2 = require$$0$4;
    ({ promisify: promisify$2 } = require$$0$5);
    isBinaryPath = isBinaryPath$1;
    ({
      isWindows: isWindows$2,
      isLinux,
      EMPTY_FN: EMPTY_FN$2,
      EMPTY_STR: EMPTY_STR$1,
      KEY_LISTENERS,
      KEY_ERR,
      KEY_RAW,
      HANDLER_KEYS,
      EV_CHANGE: EV_CHANGE$2,
      EV_ADD: EV_ADD$2,
      EV_ADD_DIR: EV_ADD_DIR$2,
      EV_ERROR: EV_ERROR$2,
      STR_DATA: STR_DATA$1,
      STR_END: STR_END$2,
      BRACE_START: BRACE_START$1,
      STAR
    } = constants$1);
    THROTTLE_MODE_WATCH = "watch";
    open$2 = promisify$2(fs$7.open);
    stat$2 = promisify$2(fs$7.stat);
    lstat$1 = promisify$2(fs$7.lstat);
    close = promisify$2(fs$7.close);
    fsrealpath = promisify$2(fs$7.realpath);
    statMethods$1 = { lstat: lstat$1, stat: stat$2 };
    foreach = (val, fn) => {
      if (val instanceof Set) {
        val.forEach(fn);
      } else {
        fn(val);
      }
    };
    addAndConvert = (main2, prop, item) => {
      let container2 = main2[prop];
      if (!(container2 instanceof Set)) {
        main2[prop] = container2 = /* @__PURE__ */ new Set([container2]);
      }
      container2.add(item);
    };
    clearItem = (cont) => (key) => {
      const set2 = cont[key];
      if (set2 instanceof Set) {
        set2.clear();
      } else {
        delete cont[key];
      }
    };
    delFromSet = (main2, prop, item) => {
      const container2 = main2[prop];
      if (container2 instanceof Set) {
        container2.delete(item);
      } else if (container2 === item) {
        delete main2[prop];
      }
    };
    isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
    FsWatchInstances = /* @__PURE__ */ new Map();
    fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
      const cont = FsWatchInstances.get(fullPath);
      if (!cont) return;
      foreach(cont[type], (listener2) => {
        listener2(val1, val2, val3);
      });
    };
    setFsWatchListener = (path7, fullPath, options2, handlers) => {
      const { listener: listener2, errHandler, rawEmitter } = handlers;
      let cont = FsWatchInstances.get(fullPath);
      let watcher;
      if (!options2.persistent) {
        watcher = createFsWatchInstance(
          path7,
          options2,
          listener2,
          errHandler,
          rawEmitter
        );
        return watcher.close.bind(watcher);
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener2);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        watcher = createFsWatchInstance(
          path7,
          options2,
          fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
          errHandler,
          // no need to use broadcast here
          fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
        );
        if (!watcher) return;
        watcher.on(EV_ERROR$2, async (error2) => {
          const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
          cont.watcherUnusable = true;
          if (isWindows$2 && error2.code === "EPERM") {
            try {
              const fd = await open$2(path7, "r");
              await close(fd);
              broadcastErr(error2);
            } catch (err) {
            }
          } else {
            broadcastErr(error2);
          }
        });
        cont = {
          listeners: listener2,
          errHandlers: errHandler,
          rawEmitters: rawEmitter,
          watcher
        };
        FsWatchInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener2);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          cont.watcher.close();
          FsWatchInstances.delete(fullPath);
          HANDLER_KEYS.forEach(clearItem(cont));
          cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    FsWatchFileInstances = /* @__PURE__ */ new Map();
    setFsWatchFileListener = (path7, fullPath, options2, handlers) => {
      const { listener: listener2, rawEmitter } = handlers;
      let cont = FsWatchFileInstances.get(fullPath);
      const copts = cont && cont.options;
      if (copts && (copts.persistent < options2.persistent || copts.interval > options2.interval)) {
        fs$7.unwatchFile(fullPath);
        cont = void 0;
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener2);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        cont = {
          listeners: listener2,
          rawEmitters: rawEmitter,
          options: options2,
          watcher: fs$7.watchFile(fullPath, options2, (curr, prev) => {
            foreach(cont.rawEmitters, (rawEmitter2) => {
              rawEmitter2(EV_CHANGE$2, fullPath, { curr, prev });
            });
            const currmtime = curr.mtimeMs;
            if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
              foreach(cont.listeners, (listener3) => listener3(path7, curr));
            }
          })
        };
        FsWatchFileInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener2);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          FsWatchFileInstances.delete(fullPath);
          fs$7.unwatchFile(fullPath);
          cont.options = cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    NodeFsHandler$1 = class NodeFsHandler {
      /**
       * @param {import("../index").FSWatcher} fsW
       */
      constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error2) => fsW._handleError(error2);
      }
      /**
       * Watch file for changes with fs_watchFile or fs_watch.
       * @param {String} path to file or dir
       * @param {Function} listener on fs change
       * @returns {Function} closer for the watcher instance
       */
      _watchWithNodeFs(path7, listener2) {
        const opts = this.fsw.options;
        const directory = sysPath$2.dirname(path7);
        const basename3 = sysPath$2.basename(path7);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename3);
        const absolutePath = sysPath$2.resolve(path7);
        const options2 = { persistent: opts.persistent };
        if (!listener2) listener2 = EMPTY_FN$2;
        let closer;
        if (opts.usePolling) {
          options2.interval = opts.enableBinaryInterval && isBinaryPath(basename3) ? opts.binaryInterval : opts.interval;
          closer = setFsWatchFileListener(path7, absolutePath, options2, {
            listener: listener2,
            rawEmitter: this.fsw._emitRaw
          });
        } else {
          closer = setFsWatchListener(path7, absolutePath, options2, {
            listener: listener2,
            errHandler: this._boundHandleError,
            rawEmitter: this.fsw._emitRaw
          });
        }
        return closer;
      }
      /**
       * Watch a file and emit add event if warranted.
       * @param {Path} file Path
       * @param {fs.Stats} stats result of fs_stat
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @returns {Function} closer for the watcher instance
       */
      _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
          return;
        }
        const dirname3 = sysPath$2.dirname(file);
        const basename3 = sysPath$2.basename(file);
        const parent = this.fsw._getWatchedDir(dirname3);
        let prevStats = stats;
        if (parent.has(basename3)) return;
        const listener2 = async (path7, newStats) => {
          if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;
          if (!newStats || newStats.mtimeMs === 0) {
            try {
              const newStats2 = await stat$2(file);
              if (this.fsw.closed) return;
              const at2 = newStats2.atimeMs;
              const mt = newStats2.mtimeMs;
              if (!at2 || at2 <= mt || mt !== prevStats.mtimeMs) {
                this.fsw._emit(EV_CHANGE$2, file, newStats2);
              }
              if (isLinux && prevStats.ino !== newStats2.ino) {
                this.fsw._closeFile(path7);
                prevStats = newStats2;
                this.fsw._addPathCloser(path7, this._watchWithNodeFs(file, listener2));
              } else {
                prevStats = newStats2;
              }
            } catch (error2) {
              this.fsw._remove(dirname3, basename3);
            }
          } else if (parent.has(basename3)) {
            const at2 = newStats.atimeMs;
            const mt = newStats.mtimeMs;
            if (!at2 || at2 <= mt || mt !== prevStats.mtimeMs) {
              this.fsw._emit(EV_CHANGE$2, file, newStats);
            }
            prevStats = newStats;
          }
        };
        const closer = this._watchWithNodeFs(file, listener2);
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
          if (!this.fsw._throttle(EV_ADD$2, file, 0)) return;
          this.fsw._emit(EV_ADD$2, file, stats);
        }
        return closer;
      }
      /**
       * Handle symlinks encountered while reading a dir.
       * @param {Object} entry returned by readdirp
       * @param {String} directory path of dir being read
       * @param {String} path of this item
       * @param {String} item basename of this item
       * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
       */
      async _handleSymlink(entry2, directory, path7, item) {
        if (this.fsw.closed) {
          return;
        }
        const full = entry2.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
          this.fsw._incrReadyCount();
          let linkPath;
          try {
            linkPath = await fsrealpath(path7);
          } catch (e2) {
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw.closed) return;
          if (dir.has(item)) {
            if (this.fsw._symlinkPaths.get(full) !== linkPath) {
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV_CHANGE$2, path7, entry2.stats);
            }
          } else {
            dir.add(item);
            this.fsw._symlinkPaths.set(full, linkPath);
            this.fsw._emit(EV_ADD$2, path7, entry2.stats);
          }
          this.fsw._emitReady();
          return true;
        }
        if (this.fsw._symlinkPaths.has(full)) {
          return true;
        }
        this.fsw._symlinkPaths.set(full, true);
      }
      _handleRead(directory, initialAdd, wh, target, dir, depth2, throttler) {
        directory = sysPath$2.join(directory, EMPTY_STR$1);
        if (!wh.hasGlob) {
          throttler = this.fsw._throttle("readdir", directory, 1e3);
          if (!throttler) return;
        }
        const previous = this.fsw._getWatchedDir(wh.path);
        const current = /* @__PURE__ */ new Set();
        let stream4 = this.fsw._readdirp(directory, {
          fileFilter: (entry2) => wh.filterPath(entry2),
          directoryFilter: (entry2) => wh.filterDir(entry2),
          depth: 0
        }).on(STR_DATA$1, async (entry2) => {
          if (this.fsw.closed) {
            stream4 = void 0;
            return;
          }
          const item = entry2.path;
          let path7 = sysPath$2.join(directory, item);
          current.add(item);
          if (entry2.stats.isSymbolicLink() && await this._handleSymlink(entry2, directory, path7, item)) {
            return;
          }
          if (this.fsw.closed) {
            stream4 = void 0;
            return;
          }
          if (item === target || !target && !previous.has(item)) {
            this.fsw._incrReadyCount();
            path7 = sysPath$2.join(dir, sysPath$2.relative(dir, path7));
            this._addToNodeFs(path7, initialAdd, wh, depth2 + 1);
          }
        }).on(EV_ERROR$2, this._boundHandleError);
        return new Promise(
          (resolve5) => stream4.once(STR_END$2, () => {
            if (this.fsw.closed) {
              stream4 = void 0;
              return;
            }
            const wasThrottled = throttler ? throttler.clear() : false;
            resolve5();
            previous.getChildren().filter((item) => {
              return item !== directory && !current.has(item) && // in case of intersecting globs;
              // a path may have been filtered out of this readdir, but
              // shouldn't be removed because it matches a different glob
              (!wh.hasGlob || wh.filterPath({
                fullPath: sysPath$2.resolve(directory, item)
              }));
            }).forEach((item) => {
              this.fsw._remove(directory, item);
            });
            stream4 = void 0;
            if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth2, throttler);
          })
        );
      }
      /**
       * Read directory to add / remove files from `@watched` list and re-read it on change.
       * @param {String} dir fs path
       * @param {fs.Stats} stats
       * @param {Boolean} initialAdd
       * @param {Number} depth relative to user-supplied path
       * @param {String} target child path targeted for watch
       * @param {Object} wh Common watch helpers for this path
       * @param {String} realpath
       * @returns {Promise<Function>} closer for the watcher instance.
       */
      async _handleDir(dir, stats, initialAdd, depth2, target, wh, realpath2) {
        const parentDir2 = this.fsw._getWatchedDir(sysPath$2.dirname(dir));
        const tracked = parentDir2.has(sysPath$2.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
          if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR$2, dir, stats);
        }
        parentDir2.add(sysPath$2.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth2 <= oDepth) && !this.fsw._symlinkPaths.has(realpath2)) {
          if (!target) {
            await this._handleRead(dir, initialAdd, wh, target, dir, depth2, throttler);
            if (this.fsw.closed) return;
          }
          closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
            if (stats2 && stats2.mtimeMs === 0) return;
            this._handleRead(dirPath, false, wh, target, dir, depth2, throttler);
          });
        }
        return closer;
      }
      /**
       * Handle added file, directory, or glob pattern.
       * Delegates call to _handleFile / _handleDir after checks.
       * @param {String} path to file or ir
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @param {Object} priorWh depth relative to user-supplied path
       * @param {Number} depth Child path actually targeted for watch
       * @param {String=} target Child path actually targeted for watch
       * @returns {Promise}
       */
      async _addToNodeFs(path7, initialAdd, priorWh, depth2, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path7) || this.fsw.closed) {
          ready();
          return false;
        }
        const wh = this.fsw._getWatchHelpers(path7, depth2);
        if (!wh.hasGlob && priorWh) {
          wh.hasGlob = priorWh.hasGlob;
          wh.globFilter = priorWh.globFilter;
          wh.filterPath = (entry2) => priorWh.filterPath(entry2);
          wh.filterDir = (entry2) => priorWh.filterDir(entry2);
        }
        try {
          const stats = await statMethods$1[wh.statMethod](wh.watchPath);
          if (this.fsw.closed) return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            ready();
            return false;
          }
          const follow = this.fsw.options.followSymlinks && !path7.includes(STAR) && !path7.includes(BRACE_START$1);
          let closer;
          if (stats.isDirectory()) {
            const absPath = sysPath$2.resolve(path7);
            const targetPath = follow ? await fsrealpath(path7) : path7;
            if (this.fsw.closed) return;
            closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth2, target, wh, targetPath);
            if (this.fsw.closed) return;
            if (absPath !== targetPath && targetPath !== void 0) {
              this.fsw._symlinkPaths.set(absPath, targetPath);
            }
          } else if (stats.isSymbolicLink()) {
            const targetPath = follow ? await fsrealpath(path7) : path7;
            if (this.fsw.closed) return;
            const parent = sysPath$2.dirname(wh.watchPath);
            this.fsw._getWatchedDir(parent).add(wh.watchPath);
            this.fsw._emit(EV_ADD$2, wh.watchPath, stats);
            closer = await this._handleDir(parent, stats, initialAdd, depth2, path7, wh, targetPath);
            if (this.fsw.closed) return;
            if (targetPath !== void 0) {
              this.fsw._symlinkPaths.set(sysPath$2.resolve(path7), targetPath);
            }
          } else {
            closer = this._handleFile(wh.watchPath, stats, initialAdd);
          }
          ready();
          this.fsw._addPathCloser(path7, closer);
          return false;
        } catch (error2) {
          if (this.fsw._handleError(error2)) {
            ready();
            return path7;
          }
        }
      }
    };
    nodefsHandler = NodeFsHandler$1;
    fseventsHandler = { exports: {} };
    fs$6 = require$$0__default3;
    sysPath$1 = require$$0$4;
    ({ promisify: promisify$1 } = require$$0$5);
    try {
      fsevents = __require2("fsevents");
    } catch (error2) {
      if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error2);
    }
    if (fsevents) {
      const mtch = process.version.match(/v(\d+)\.(\d+)/);
      if (mtch && mtch[1] && mtch[2]) {
        const maj2 = Number.parseInt(mtch[1], 10);
        const min2 = Number.parseInt(mtch[2], 10);
        if (maj2 === 8 && min2 < 16) {
          fsevents = void 0;
        }
      }
    }
    ({
      EV_ADD: EV_ADD$1,
      EV_CHANGE: EV_CHANGE$1,
      EV_ADD_DIR: EV_ADD_DIR$1,
      EV_UNLINK: EV_UNLINK$1,
      EV_ERROR: EV_ERROR$1,
      STR_DATA,
      STR_END: STR_END$1,
      FSEVENT_CREATED,
      FSEVENT_MODIFIED,
      FSEVENT_DELETED,
      FSEVENT_MOVED,
      FSEVENT_UNKNOWN: (
        // FSEVENT_CLONED,
        FSEVENT_UNKNOWN
      ),
      FSEVENT_FLAG_MUST_SCAN_SUBDIRS,
      FSEVENT_TYPE_FILE,
      FSEVENT_TYPE_DIRECTORY,
      FSEVENT_TYPE_SYMLINK,
      ROOT_GLOBSTAR,
      DIR_SUFFIX,
      DOT_SLASH,
      FUNCTION_TYPE: FUNCTION_TYPE$1,
      EMPTY_FN: EMPTY_FN$1,
      IDENTITY_FN
    } = constants$1);
    Depth = (value2) => isNaN(value2) ? {} : { depth: value2 };
    stat$1 = promisify$1(fs$6.stat);
    lstat = promisify$1(fs$6.lstat);
    realpath = promisify$1(fs$6.realpath);
    statMethods = { stat: stat$1, lstat };
    FSEventsWatchers = /* @__PURE__ */ new Map();
    consolidateThreshhold = 10;
    wrongEventFlags = /* @__PURE__ */ new Set([
      69888,
      70400,
      71424,
      72704,
      73472,
      131328,
      131840,
      262912
    ]);
    createFSEventsInstance = (path7, callback) => {
      const stop = fsevents.watch(path7, callback);
      return { stop };
    };
    couldConsolidate = (path7) => {
      let count = 0;
      for (const watchPath of FSEventsWatchers.keys()) {
        if (watchPath.indexOf(path7) === 0) {
          count++;
          if (count >= consolidateThreshhold) {
            return true;
          }
        }
      }
      return false;
    };
    canUse = () => fsevents && FSEventsWatchers.size < 128;
    calcDepth = (path7, root3) => {
      let i14 = 0;
      while (!path7.indexOf(root3) && (path7 = sysPath$1.dirname(path7)) !== root3) i14++;
      return i14;
    };
    sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
    FsEventsHandler$1 = class FsEventsHandler {
      /**
       * @param {import('../index').FSWatcher} fsw
       */
      constructor(fsw) {
        this.fsw = fsw;
      }
      checkIgnored(path7, stats) {
        const ipaths = this.fsw._ignoredPaths;
        if (this.fsw._isIgnored(path7, stats)) {
          ipaths.add(path7);
          if (stats && stats.isDirectory()) {
            ipaths.add(path7 + ROOT_GLOBSTAR);
          }
          return true;
        }
        ipaths.delete(path7);
        ipaths.delete(path7 + ROOT_GLOBSTAR);
      }
      addOrChange(path7, fullPath, realPath, parent, watchedDir, item, info, opts) {
        const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;
        this.handleEvent(event, path7, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
      async checkExists(path7, fullPath, realPath, parent, watchedDir, item, info, opts) {
        try {
          const stats = await stat$1(path7);
          if (this.fsw.closed) return;
          if (sameTypes(info, stats)) {
            this.addOrChange(path7, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK$1, path7, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        } catch (error2) {
          if (error2.code === "EACCES") {
            this.addOrChange(path7, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK$1, path7, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        }
      }
      handleEvent(event, path7, fullPath, realPath, parent, watchedDir, item, info, opts) {
        if (this.fsw.closed || this.checkIgnored(path7)) return;
        if (event === EV_UNLINK$1) {
          const isDirectory2 = info.type === FSEVENT_TYPE_DIRECTORY;
          if (isDirectory2 || watchedDir.has(item)) {
            this.fsw._remove(parent, item, isDirectory2);
          }
        } else {
          if (event === EV_ADD$1) {
            if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path7);
            if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
              const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
              return this._addToFsEvents(path7, false, true, curDepth);
            }
            this.fsw._getWatchedDir(parent).add(item);
          }
          const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
          this.fsw._emit(eventName, path7);
          if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path7, false, true);
        }
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} watchPath  - file/dir path to be watched with fsevents
       * @param {String} realPath   - real path (in case of symlinks)
       * @param {Function} transform  - path transformer
       * @param {Function} globFilter - path filter in case a glob pattern was provided
       * @returns {Function} closer for the watcher instance
      */
      _watchWithFsEvents(watchPath, realPath, transform2, globFilter) {
        if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;
        const opts = this.fsw.options;
        const watchCallback = async (fullPath, flags, info) => {
          if (this.fsw.closed || this.fsw._isIgnored(fullPath)) return;
          if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth) return;
          const path7 = transform2(sysPath$1.join(
            watchPath,
            sysPath$1.relative(watchPath, fullPath)
          ));
          if (globFilter && !globFilter(path7)) return;
          const parent = sysPath$1.dirname(path7);
          const item = sysPath$1.basename(path7);
          const watchedDir = this.fsw._getWatchedDir(
            info.type === FSEVENT_TYPE_DIRECTORY ? path7 : parent
          );
          if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
            if (typeof opts.ignored === FUNCTION_TYPE$1) {
              let stats;
              try {
                stats = await stat$1(path7);
              } catch (error2) {
              }
              if (this.fsw.closed) return;
              if (this.checkIgnored(path7, stats)) return;
              if (sameTypes(info, stats)) {
                this.addOrChange(path7, fullPath, realPath, parent, watchedDir, item, info, opts);
              } else {
                this.handleEvent(EV_UNLINK$1, path7, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            } else {
              this.checkExists(path7, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          } else {
            switch (info.event) {
              case FSEVENT_CREATED:
              case FSEVENT_MODIFIED:
                return this.addOrChange(path7, fullPath, realPath, parent, watchedDir, item, info, opts);
              case FSEVENT_DELETED:
              case FSEVENT_MOVED:
                return this.checkExists(path7, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          }
        };
        const closer = setFSEventsListener(
          watchPath,
          realPath,
          watchCallback,
          this.fsw._emitRaw
        );
        this.fsw._emitReady();
        return closer;
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} linkPath path to symlink
       * @param {String} fullPath absolute path to the symlink
       * @param {Function} transform pre-existing path transformer
       * @param {Number} curDepth level of subdirectories traversed to where symlink is
       * @returns {Promise<void>}
       */
      async _handleFsEventsSymlink(linkPath, fullPath, transform2, curDepth) {
        if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;
        this.fsw._symlinkPaths.set(fullPath, true);
        this.fsw._incrReadyCount();
        try {
          const linkTarget = await realpath(linkPath);
          if (this.fsw.closed) return;
          if (this.fsw._isIgnored(linkTarget)) {
            return this.fsw._emitReady();
          }
          this.fsw._incrReadyCount();
          this._addToFsEvents(linkTarget || linkPath, (path7) => {
            let aliasedPath = linkPath;
            if (linkTarget && linkTarget !== DOT_SLASH) {
              aliasedPath = path7.replace(linkTarget, linkPath);
            } else if (path7 !== DOT_SLASH) {
              aliasedPath = sysPath$1.join(linkPath, path7);
            }
            return transform2(aliasedPath);
          }, false, curDepth);
        } catch (error2) {
          if (this.fsw._handleError(error2)) {
            return this.fsw._emitReady();
          }
        }
      }
      /**
       *
       * @param {Path} newPath
       * @param {fs.Stats} stats
       */
      emitAdd(newPath, stats, processPath, opts, forceAdd) {
        const pp = processPath(newPath);
        const isDir = stats.isDirectory();
        const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));
        const base = sysPath$1.basename(pp);
        if (isDir) this.fsw._getWatchedDir(pp);
        if (dirObj.has(base)) return;
        dirObj.add(base);
        if (!opts.ignoreInitial || forceAdd === true) {
          this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);
        }
      }
      initWatch(realPath, path7, wh, processPath) {
        if (this.fsw.closed) return;
        const closer = this._watchWithFsEvents(
          wh.watchPath,
          sysPath$1.resolve(realPath || wh.watchPath),
          processPath,
          wh.globFilter
        );
        this.fsw._addPathCloser(path7, closer);
      }
      /**
       * Handle added path with fsevents
       * @param {String} path file/dir path or glob pattern
       * @param {Function|Boolean=} transform converts working path to what the user expects
       * @param {Boolean=} forceAdd ensure add is emitted
       * @param {Number=} priorDepth Level of subdirectories already traversed.
       * @returns {Promise<void>}
       */
      async _addToFsEvents(path7, transform2, forceAdd, priorDepth) {
        if (this.fsw.closed) {
          return;
        }
        const opts = this.fsw.options;
        const processPath = typeof transform2 === FUNCTION_TYPE$1 ? transform2 : IDENTITY_FN;
        const wh = this.fsw._getWatchHelpers(path7);
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed) return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            throw null;
          }
          if (stats.isDirectory()) {
            if (!wh.globFilter) this.emitAdd(processPath(path7), stats, processPath, opts, forceAdd);
            if (priorDepth && priorDepth > opts.depth) return;
            this.fsw._readdirp(wh.watchPath, {
              fileFilter: (entry2) => wh.filterPath(entry2),
              directoryFilter: (entry2) => wh.filterDir(entry2),
              ...Depth(opts.depth - (priorDepth || 0))
            }).on(STR_DATA, (entry2) => {
              if (this.fsw.closed) {
                return;
              }
              if (entry2.stats.isDirectory() && !wh.filterPath(entry2)) return;
              const joinedPath = sysPath$1.join(wh.watchPath, entry2.path);
              const { fullPath } = entry2;
              if (wh.followSymlinks && entry2.stats.isSymbolicLink()) {
                const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;
                this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
              } else {
                this.emitAdd(joinedPath, entry2.stats, processPath, opts, forceAdd);
              }
            }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {
              this.fsw._emitReady();
            });
          } else {
            this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
            this.fsw._emitReady();
          }
        } catch (error2) {
          if (!error2 || this.fsw._handleError(error2)) {
            this.fsw._emitReady();
            this.fsw._emitReady();
          }
        }
        if (opts.persistent && forceAdd !== true) {
          if (typeof transform2 === FUNCTION_TYPE$1) {
            this.initWatch(void 0, path7, wh, processPath);
          } else {
            let realPath;
            try {
              realPath = await realpath(wh.watchPath);
            } catch (e2) {
            }
            this.initWatch(realPath, path7, wh, processPath);
          }
        }
      }
    };
    fseventsHandler.exports = FsEventsHandler$1;
    fseventsHandler.exports.canUse = canUse;
    fseventsHandlerExports = fseventsHandler.exports;
    ({ EventEmitter: EventEmitter$2 } = require$$0$7);
    fs$5 = require$$0__default3;
    sysPath = require$$0$4;
    ({ promisify } = require$$0$5);
    readdirp = readdirp_1;
    anymatch = anymatchExports.default;
    globParent2 = globParent$2;
    isGlob2 = isGlob$2;
    braces = braces_1;
    normalizePath = normalizePath$2;
    NodeFsHandler2 = nodefsHandler;
    FsEventsHandler2 = fseventsHandlerExports;
    ({
      EV_ALL,
      EV_READY,
      EV_ADD,
      EV_CHANGE,
      EV_UNLINK,
      EV_ADD_DIR,
      EV_UNLINK_DIR,
      EV_RAW,
      EV_ERROR,
      STR_CLOSE,
      STR_END,
      BACK_SLASH_RE,
      DOUBLE_SLASH_RE,
      SLASH_OR_BACK_SLASH_RE,
      DOT_RE,
      REPLACER_RE,
      SLASH,
      SLASH_SLASH,
      BRACE_START,
      BANG,
      ONE_DOT,
      TWO_DOTS,
      GLOBSTAR,
      SLASH_GLOBSTAR,
      ANYMATCH_OPTS,
      STRING_TYPE,
      FUNCTION_TYPE,
      EMPTY_STR,
      EMPTY_FN,
      isWindows: isWindows$1,
      isMacos,
      isIBMi
    } = constants$1);
    stat2 = promisify(fs$5.stat);
    readdir = promisify(fs$5.readdir);
    arrify = (value2 = []) => Array.isArray(value2) ? value2 : [value2];
    flatten = (list, result = []) => {
      list.forEach((item) => {
        if (Array.isArray(item)) {
          flatten(item, result);
        } else {
          result.push(item);
        }
      });
      return result;
    };
    unifyPaths = (paths_) => {
      const paths = flatten(arrify(paths_));
      if (!paths.every((p20) => typeof p20 === STRING_TYPE)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
      }
      return paths.map(normalizePathToUnix);
    };
    toUnix = (string4) => {
      let str2 = string4.replace(BACK_SLASH_RE, SLASH);
      let prepend = false;
      if (str2.startsWith(SLASH_SLASH)) {
        prepend = true;
      }
      while (str2.match(DOUBLE_SLASH_RE)) {
        str2 = str2.replace(DOUBLE_SLASH_RE, SLASH);
      }
      if (prepend) {
        str2 = SLASH + str2;
      }
      return str2;
    };
    normalizePathToUnix = (path7) => toUnix(sysPath.normalize(toUnix(path7)));
    normalizeIgnored = (cwd = EMPTY_STR) => (path7) => {
      if (typeof path7 !== STRING_TYPE) return path7;
      return normalizePathToUnix(sysPath.isAbsolute(path7) ? path7 : sysPath.join(cwd, path7));
    };
    getAbsolutePath = (path7, cwd) => {
      if (sysPath.isAbsolute(path7)) {
        return path7;
      }
      if (path7.startsWith(BANG)) {
        return BANG + sysPath.join(cwd, path7.slice(1));
      }
      return sysPath.join(cwd, path7);
    };
    undef = (opts, key) => opts[key] === void 0;
    DirEntry = class {
      /**
       * @param {Path} dir
       * @param {Function} removeWatcher
       */
      constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = /* @__PURE__ */ new Set();
      }
      add(item) {
        const { items } = this;
        if (!items) return;
        if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
      }
      async remove(item) {
        const { items } = this;
        if (!items) return;
        items.delete(item);
        if (items.size > 0) return;
        const dir = this.path;
        try {
          await readdir(dir);
        } catch (err) {
          if (this._removeWatcher) {
            this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
          }
        }
      }
      has(item) {
        const { items } = this;
        if (!items) return;
        return items.has(item);
      }
      /**
       * @returns {Array<String>}
       */
      getChildren() {
        const { items } = this;
        if (!items) return;
        return [...items.values()];
      }
      dispose() {
        this.items.clear();
        delete this.path;
        delete this._removeWatcher;
        delete this.items;
        Object.freeze(this);
      }
    };
    STAT_METHOD_F = "stat";
    STAT_METHOD_L = "lstat";
    WatchHelper = class {
      constructor(path7, watchPath, follow, fsw) {
        this.fsw = fsw;
        this.path = path7 = path7.replace(REPLACER_RE, EMPTY_STR);
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.hasGlob = watchPath !== path7;
        if (path7 === EMPTY_STR) this.hasGlob = false;
        this.globSymlink = this.hasGlob && follow ? void 0 : false;
        this.globFilter = this.hasGlob ? anymatch(path7, void 0, ANYMATCH_OPTS) : false;
        this.dirParts = this.getDirParts(path7);
        this.dirParts.forEach((parts) => {
          if (parts.length > 1) parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
      }
      checkGlobSymlink(entry2) {
        if (this.globSymlink === void 0) {
          this.globSymlink = entry2.fullParentDir === this.fullWatchPath ? false : { realPath: entry2.fullParentDir, linkPath: this.fullWatchPath };
        }
        if (this.globSymlink) {
          return entry2.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
        }
        return entry2.fullPath;
      }
      entryPath(entry2) {
        return sysPath.join(
          this.watchPath,
          sysPath.relative(this.watchPath, this.checkGlobSymlink(entry2))
        );
      }
      filterPath(entry2) {
        const { stats } = entry2;
        if (stats && stats.isSymbolicLink()) return this.filterDir(entry2);
        const resolvedPath = this.entryPath(entry2);
        const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
        return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
      }
      getDirParts(path7) {
        if (!this.hasGlob) return [];
        const parts = [];
        const expandedPath = path7.includes(BRACE_START) ? braces.expand(path7) : [path7];
        expandedPath.forEach((path8) => {
          parts.push(sysPath.relative(this.watchPath, path8).split(SLASH_OR_BACK_SLASH_RE));
        });
        return parts;
      }
      filterDir(entry2) {
        if (this.hasGlob) {
          const entryParts = this.getDirParts(this.checkGlobSymlink(entry2));
          let globstar = false;
          this.unmatchedGlob = !this.dirParts.some((parts) => {
            return parts.every((part, i14) => {
              if (part === GLOBSTAR) globstar = true;
              return globstar || !entryParts[0][i14] || anymatch(part, entryParts[0][i14], ANYMATCH_OPTS);
            });
          });
        }
        return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry2), entry2.stats);
      }
    };
    FSWatcher = class extends EventEmitter$2 {
      // Not indenting methods for history sake; for now.
      constructor(_opts) {
        super();
        const opts = {};
        if (_opts) Object.assign(opts, _opts);
        this._watched = /* @__PURE__ */ new Map();
        this._closers = /* @__PURE__ */ new Map();
        this._ignoredPaths = /* @__PURE__ */ new Set();
        this._throttled = /* @__PURE__ */ new Map();
        this._symlinkPaths = /* @__PURE__ */ new Map();
        this._streams = /* @__PURE__ */ new Set();
        this.closed = false;
        if (undef(opts, "persistent")) opts.persistent = true;
        if (undef(opts, "ignoreInitial")) opts.ignoreInitial = false;
        if (undef(opts, "ignorePermissionErrors")) opts.ignorePermissionErrors = false;
        if (undef(opts, "interval")) opts.interval = 100;
        if (undef(opts, "binaryInterval")) opts.binaryInterval = 300;
        if (undef(opts, "disableGlobbing")) opts.disableGlobbing = false;
        opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
        if (undef(opts, "useFsEvents")) opts.useFsEvents = !opts.usePolling;
        const canUseFsEvents = FsEventsHandler2.canUse();
        if (!canUseFsEvents) opts.useFsEvents = false;
        if (undef(opts, "usePolling") && !opts.useFsEvents) {
          opts.usePolling = isMacos;
        }
        if (isIBMi) {
          opts.usePolling = true;
        }
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== void 0) {
          const envLower = envPoll.toLowerCase();
          if (envLower === "false" || envLower === "0") {
            opts.usePolling = false;
          } else if (envLower === "true" || envLower === "1") {
            opts.usePolling = true;
          } else {
            opts.usePolling = !!envLower;
          }
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval) {
          opts.interval = Number.parseInt(envInterval, 10);
        }
        if (undef(opts, "atomic")) opts.atomic = !opts.usePolling && !opts.useFsEvents;
        if (opts.atomic) this._pendingUnlinks = /* @__PURE__ */ new Map();
        if (undef(opts, "followSymlinks")) opts.followSymlinks = true;
        if (undef(opts, "awaitWriteFinish")) opts.awaitWriteFinish = false;
        if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
        const awf = opts.awaitWriteFinish;
        if (awf) {
          if (!awf.stabilityThreshold) awf.stabilityThreshold = 2e3;
          if (!awf.pollInterval) awf.pollInterval = 100;
          this._pendingWrites = /* @__PURE__ */ new Map();
        }
        if (opts.ignored) opts.ignored = arrify(opts.ignored);
        let readyCalls = 0;
        this._emitReady = () => {
          readyCalls++;
          if (readyCalls >= this._readyCount) {
            this._emitReady = EMPTY_FN;
            this._readyEmitted = true;
            process.nextTick(() => this.emit(EV_READY));
          }
        };
        this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
        this._readyEmitted = false;
        this.options = opts;
        if (opts.useFsEvents) {
          this._fsEventsHandler = new FsEventsHandler2(this);
        } else {
          this._nodeFsHandler = new NodeFsHandler2(this);
        }
        Object.freeze(opts);
      }
      // Public methods
      /**
       * Adds paths to be watched on an existing FSWatcher instance
       * @param {Path|Array<Path>} paths_
       * @param {String=} _origAdd private; for handling non-existent paths to be watched
       * @param {Boolean=} _internal private; indicates a non-user add
       * @returns {FSWatcher} for chaining
       */
      add(paths_, _origAdd, _internal) {
        const { cwd, disableGlobbing } = this.options;
        this.closed = false;
        let paths = unifyPaths(paths_);
        if (cwd) {
          paths = paths.map((path7) => {
            const absPath = getAbsolutePath(path7, cwd);
            if (disableGlobbing || !isGlob2(path7)) {
              return absPath;
            }
            return normalizePath(absPath);
          });
        }
        paths = paths.filter((path7) => {
          if (path7.startsWith(BANG)) {
            this._ignoredPaths.add(path7.slice(1));
            return false;
          }
          this._ignoredPaths.delete(path7);
          this._ignoredPaths.delete(path7 + SLASH_GLOBSTAR);
          this._userIgnored = void 0;
          return true;
        });
        if (this.options.useFsEvents && this._fsEventsHandler) {
          if (!this._readyCount) this._readyCount = paths.length;
          if (this.options.persistent) this._readyCount += paths.length;
          paths.forEach((path7) => this._fsEventsHandler._addToFsEvents(path7));
        } else {
          if (!this._readyCount) this._readyCount = 0;
          this._readyCount += paths.length;
          Promise.all(
            paths.map(async (path7) => {
              const res = await this._nodeFsHandler._addToNodeFs(path7, !_internal, 0, 0, _origAdd);
              if (res) this._emitReady();
              return res;
            })
          ).then((results) => {
            if (this.closed) return;
            results.filter((item) => item).forEach((item) => {
              this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
            });
          });
        }
        return this;
      }
      /**
       * Close watchers or start ignoring events from specified paths.
       * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
       * @returns {FSWatcher} for chaining
      */
      unwatch(paths_) {
        if (this.closed) return this;
        const paths = unifyPaths(paths_);
        const { cwd } = this.options;
        paths.forEach((path7) => {
          if (!sysPath.isAbsolute(path7) && !this._closers.has(path7)) {
            if (cwd) path7 = sysPath.join(cwd, path7);
            path7 = sysPath.resolve(path7);
          }
          this._closePath(path7);
          this._ignoredPaths.add(path7);
          if (this._watched.has(path7)) {
            this._ignoredPaths.add(path7 + SLASH_GLOBSTAR);
          }
          this._userIgnored = void 0;
        });
        return this;
      }
      /**
       * Close watchers and remove all listeners from watched paths.
       * @returns {Promise<void>}.
      */
      close() {
        if (this.closed) return this._closePromise;
        this.closed = true;
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
          const promise2 = closer();
          if (promise2 instanceof Promise) closers.push(promise2);
        }));
        this._streams.forEach((stream4) => stream4.destroy());
        this._userIgnored = void 0;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
          this[`_${key}`].clear();
        });
        this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
        return this._closePromise;
      }
      /**
       * Expose list of watched paths
       * @returns {Object} for chaining
      */
      getWatched() {
        const watchList = {};
        this._watched.forEach((entry2, dir) => {
          const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
          watchList[key || ONE_DOT] = entry2.getChildren().sort();
        });
        return watchList;
      }
      emitWithAll(event, args) {
        this.emit(...args);
        if (event !== EV_ERROR) this.emit(EV_ALL, ...args);
      }
      // Common helpers
      // --------------
      /**
       * Normalize and emit events.
       * Calling _emit DOES NOT MEAN emit() would be called!
       * @param {EventName} event Type of event
       * @param {Path} path File or directory path
       * @param {*=} val1 arguments to be passed with event
       * @param {*=} val2
       * @param {*=} val3
       * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      async _emit(event, path7, val1, val2, val3) {
        if (this.closed) return;
        const opts = this.options;
        if (isWindows$1) path7 = sysPath.normalize(path7);
        if (opts.cwd) path7 = sysPath.relative(opts.cwd, path7);
        const args = [event, path7];
        if (val3 !== void 0) args.push(val1, val2, val3);
        else if (val2 !== void 0) args.push(val1, val2);
        else if (val1 !== void 0) args.push(val1);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path7))) {
          pw.lastChange = /* @__PURE__ */ new Date();
          return this;
        }
        if (opts.atomic) {
          if (event === EV_UNLINK) {
            this._pendingUnlinks.set(path7, args);
            setTimeout(() => {
              this._pendingUnlinks.forEach((entry2, path8) => {
                this.emit(...entry2);
                this.emit(EV_ALL, ...entry2);
                this._pendingUnlinks.delete(path8);
              });
            }, typeof opts.atomic === "number" ? opts.atomic : 100);
            return this;
          }
          if (event === EV_ADD && this._pendingUnlinks.has(path7)) {
            event = args[0] = EV_CHANGE;
            this._pendingUnlinks.delete(path7);
          }
        }
        if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
          const awfEmit = (err, stats) => {
            if (err) {
              event = args[0] = EV_ERROR;
              args[1] = err;
              this.emitWithAll(event, args);
            } else if (stats) {
              if (args.length > 2) {
                args[2] = stats;
              } else {
                args.push(stats);
              }
              this.emitWithAll(event, args);
            }
          };
          this._awaitWriteFinish(path7, awf.stabilityThreshold, event, awfEmit);
          return this;
        }
        if (event === EV_CHANGE) {
          const isThrottled = !this._throttle(EV_CHANGE, path7, 50);
          if (isThrottled) return this;
        }
        if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
          const fullPath = opts.cwd ? sysPath.join(opts.cwd, path7) : path7;
          let stats;
          try {
            stats = await stat2(fullPath);
          } catch (err) {
          }
          if (!stats || this.closed) return;
          args.push(stats);
        }
        this.emitWithAll(event, args);
        return this;
      }
      /**
       * Common handler for errors
       * @param {Error} error
       * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      _handleError(error2) {
        const code = error2 && error2.code;
        if (error2 && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
          this.emit(EV_ERROR, error2);
        }
        return error2 || this.closed;
      }
      /**
       * Helper utility for throttling
       * @param {ThrottleType} actionType type being throttled
       * @param {Path} path being acted upon
       * @param {Number} timeout duration of time to suppress duplicate actions
       * @returns {Object|false} tracking object or false if action should be suppressed
       */
      _throttle(actionType, path7, timeout2) {
        if (!this._throttled.has(actionType)) {
          this._throttled.set(actionType, /* @__PURE__ */ new Map());
        }
        const action = this._throttled.get(actionType);
        const actionPath = action.get(path7);
        if (actionPath) {
          actionPath.count++;
          return false;
        }
        let timeoutObject;
        const clear = () => {
          const item = action.get(path7);
          const count = item ? item.count : 0;
          action.delete(path7);
          clearTimeout(timeoutObject);
          if (item) clearTimeout(item.timeoutObject);
          return count;
        };
        timeoutObject = setTimeout(clear, timeout2);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path7, thr);
        return thr;
      }
      _incrReadyCount() {
        return this._readyCount++;
      }
      /**
       * Awaits write operation to finish.
       * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
       * @param {Path} path being acted upon
       * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
       * @param {EventName} event
       * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
       */
      _awaitWriteFinish(path7, threshold, event, awfEmit) {
        let timeoutHandler;
        let fullPath = path7;
        if (this.options.cwd && !sysPath.isAbsolute(path7)) {
          fullPath = sysPath.join(this.options.cwd, path7);
        }
        const now = /* @__PURE__ */ new Date();
        const awaitWriteFinish = (prevStat) => {
          fs$5.stat(fullPath, (err, curStat) => {
            if (err || !this._pendingWrites.has(path7)) {
              if (err && err.code !== "ENOENT") awfEmit(err);
              return;
            }
            const now2 = Number(/* @__PURE__ */ new Date());
            if (prevStat && curStat.size !== prevStat.size) {
              this._pendingWrites.get(path7).lastChange = now2;
            }
            const pw = this._pendingWrites.get(path7);
            const df = now2 - pw.lastChange;
            if (df >= threshold) {
              this._pendingWrites.delete(path7);
              awfEmit(void 0, curStat);
            } else {
              timeoutHandler = setTimeout(
                awaitWriteFinish,
                this.options.awaitWriteFinish.pollInterval,
                curStat
              );
            }
          });
        };
        if (!this._pendingWrites.has(path7)) {
          this._pendingWrites.set(path7, {
            lastChange: now,
            cancelWait: () => {
              this._pendingWrites.delete(path7);
              clearTimeout(timeoutHandler);
              return event;
            }
          });
          timeoutHandler = setTimeout(
            awaitWriteFinish,
            this.options.awaitWriteFinish.pollInterval
          );
        }
      }
      _getGlobIgnored() {
        return [...this._ignoredPaths.values()];
      }
      /**
       * Determines whether user has asked to ignore this path.
       * @param {Path} path filepath or dir
       * @param {fs.Stats=} stats result of fs.stat
       * @returns {Boolean}
       */
      _isIgnored(path7, stats) {
        if (this.options.atomic && DOT_RE.test(path7)) return true;
        if (!this._userIgnored) {
          const { cwd } = this.options;
          const ign = this.options.ignored;
          const ignored = ign && ign.map(normalizeIgnored(cwd));
          const paths = arrify(ignored).filter((path8) => typeof path8 === STRING_TYPE && !isGlob2(path8)).map((path8) => path8 + SLASH_GLOBSTAR);
          const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
          this._userIgnored = anymatch(list, void 0, ANYMATCH_OPTS);
        }
        return this._userIgnored([path7, stats]);
      }
      _isntIgnored(path7, stat3) {
        return !this._isIgnored(path7, stat3);
      }
      /**
       * Provides a set of common helpers and properties relating to symlink and glob handling.
       * @param {Path} path file, directory, or glob pattern being watched
       * @param {Number=} depth at any depth > 0, this isn't a glob
       * @returns {WatchHelper} object containing helpers for this path
       */
      _getWatchHelpers(path7, depth2) {
        const watchPath = depth2 || this.options.disableGlobbing || !isGlob2(path7) ? path7 : globParent2(path7);
        const follow = this.options.followSymlinks;
        return new WatchHelper(path7, watchPath, follow, this);
      }
      // Directory helpers
      // -----------------
      /**
       * Provides directory tracking objects
       * @param {String} directory path of the directory
       * @returns {DirEntry} the directory's tracking object
       */
      _getWatchedDir(directory) {
        if (!this._boundRemove) this._boundRemove = this._remove.bind(this);
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
      }
      // File helpers
      // ------------
      /**
       * Check for read permissions.
       * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
       * @param {fs.Stats} stats - object, result of fs_stat
       * @returns {Boolean} indicates whether the file can be read
      */
      _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors) return true;
        const md = stats && Number.parseInt(stats.mode, 10);
        const st = md & 511;
        const it = Number.parseInt(st.toString(8)[0], 10);
        return Boolean(4 & it);
      }
      /**
       * Handles emitting unlink events for
       * files and directories, and via recursion, for
       * files and directories within directories that are unlinked
       * @param {String} directory within which the following item is located
       * @param {String} item      base path of item/directory
       * @returns {void}
      */
      _remove(directory, item, isDirectory2) {
        const path7 = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path7);
        isDirectory2 = isDirectory2 != null ? isDirectory2 : this._watched.has(path7) || this._watched.has(fullPath);
        if (!this._throttle("remove", path7, 100)) return;
        if (!isDirectory2 && !this.options.useFsEvents && this._watched.size === 1) {
          this.add(directory, item, true);
        }
        const wp = this._getWatchedDir(path7);
        const nestedDirectoryChildren = wp.getChildren();
        nestedDirectoryChildren.forEach((nested) => this._remove(path7, nested));
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        if (this._symlinkPaths.has(fullPath)) {
          this._symlinkPaths.delete(fullPath);
        }
        let relPath = path7;
        if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path7);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
          const event = this._pendingWrites.get(relPath).cancelWait();
          if (event === EV_ADD) return;
        }
        this._watched.delete(path7);
        this._watched.delete(fullPath);
        const eventName = isDirectory2 ? EV_UNLINK_DIR : EV_UNLINK;
        if (wasTracked && !this._isIgnored(path7)) this._emit(eventName, path7);
        if (!this.options.useFsEvents) {
          this._closePath(path7);
        }
      }
      /**
       * Closes all watchers for a path
       * @param {Path} path
       */
      _closePath(path7) {
        this._closeFile(path7);
        const dir = sysPath.dirname(path7);
        this._getWatchedDir(dir).remove(sysPath.basename(path7));
      }
      /**
       * Closes only file-specific watchers
       * @param {Path} path
       */
      _closeFile(path7) {
        const closers = this._closers.get(path7);
        if (!closers) return;
        closers.forEach((closer) => closer());
        this._closers.delete(path7);
      }
      /**
       *
       * @param {Path} path
       * @param {Function} closer
       */
      _addPathCloser(path7, closer) {
        if (!closer) return;
        let list = this._closers.get(path7);
        if (!list) {
          list = [];
          this._closers.set(path7, list);
        }
        list.push(closer);
      }
      _readdirp(root3, opts) {
        if (this.closed) return;
        const options2 = { type: EV_ALL, alwaysStat: true, lstat: true, ...opts };
        let stream4 = readdirp(root3, options2);
        this._streams.add(stream4);
        stream4.once(STR_CLOSE, () => {
          stream4 = void 0;
        });
        stream4.once(STR_END, () => {
          if (stream4) {
            this._streams.delete(stream4);
            stream4 = void 0;
          }
        });
        return stream4;
      }
    };
    chokidar.FSWatcher = FSWatcher;
    watch = (paths, options2) => {
      const watcher = new FSWatcher(options2);
      watcher.add(paths);
      return watcher;
    };
    chokidar.watch = watch;
    shellQuote$1 = {};
    quote = function quote2(xs) {
      return xs.map(function(s12) {
        if (s12 && typeof s12 === "object") {
          return s12.op.replace(/(.)/g, "\\$1");
        }
        if (/["\s]/.test(s12) && !/'/.test(s12)) {
          return "'" + s12.replace(/(['\\])/g, "\\$1") + "'";
        }
        if (/["'\s]/.test(s12)) {
          return '"' + s12.replace(/(["\\$`!])/g, "\\$1") + '"';
        }
        return String(s12).replace(/([A-Za-z]:)?([#!"$&'()*,:;<=>?@[\\\]^`{|}])/g, "$1\\$2");
      }).join(" ");
    };
    CONTROL = "(?:" + [
      "\\|\\|",
      "\\&\\&",
      ";;",
      "\\|\\&",
      "\\<\\(",
      "\\<\\<\\<",
      ">>",
      ">\\&",
      "<\\&",
      "[&;()|<>]"
    ].join("|") + ")";
    controlRE = new RegExp("^" + CONTROL + "$");
    META = "|&;()<> \\t";
    SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
    DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
    hash2 = /^#$/;
    SQ = "'";
    DQ = '"';
    DS = "$";
    TOKEN = "";
    mult = 4294967296;
    for (i14 = 0; i14 < 4; i14++) {
      TOKEN += (mult * Math.random()).toString(16);
    }
    startsWithToken = new RegExp("^" + TOKEN);
    parse$6 = function parse4(s12, env2, opts) {
      var mapped = parseInternal(s12, env2, opts);
      if (typeof env2 !== "function") {
        return mapped;
      }
      return mapped.reduce(function(acc, s13) {
        if (typeof s13 === "object") {
          return acc.concat(s13);
        }
        var xs = s13.split(RegExp("(" + TOKEN + ".*?" + TOKEN + ")", "g"));
        if (xs.length === 1) {
          return acc.concat(xs[0]);
        }
        return acc.concat(xs.filter(Boolean).map(function(x22) {
          if (startsWithToken.test(x22)) {
            return JSON.parse(x22.split(TOKEN)[1]);
          }
          return x22;
        }));
      }, []);
    };
    shellQuote$1.quote = quote;
    shellQuote$1.parse = parse$6;
    commonFsUtils = {
      existsSync: fs__default.existsSync,
      isDirectory,
      tryResolveRealFile,
      tryResolveRealFileWithExtensions,
      tryResolveRealFileOrType
    };
    Stats = require$$0__default3.Stats;
    normalizedClientEntry$1 = normalizePath$3(CLIENT_ENTRY);
    normalizedEnvEntry$1 = normalizePath$3(ENV_ENTRY);
    debug$c = createDebugger("vite:resolve-details", {
      onlyWhenFocused: true
    });
    externalTypes = [
      "css",
      // supported pre-processor types
      "less",
      "sass",
      "scss",
      "styl",
      "stylus",
      "pcss",
      "postcss",
      // wasm
      "wasm",
      // known SFC types
      "vue",
      "svelte",
      "marko",
      "astro",
      "imba",
      // JSX/TSX may be configured to be compiled differently from how esbuild
      // handles it by default, so exclude them as well
      "jsx",
      "tsx",
      ...KNOWN_ASSET_TYPES
    ];
    debug$b = createDebugger("vite:ssr-external");
    jsonLangs = `\\.(?:json|json5)(?:$|\\?)`;
    jsonLangRE = new RegExp(jsonLangs);
    debug$a = createDebugger("vite:optimize-deps");
    normalizedClientEntry = normalizePath$3(CLIENT_ENTRY);
    normalizedEnvEntry = normalizePath$3(ENV_ENTRY);
    wasmHelper = async (opts = {}, url2) => {
      let result;
      if (url2.startsWith("data:")) {
        const urlContent = url2.replace(/^data:.*?base64,/, "");
        let bytes2;
        if (typeof Buffer === "function" && typeof Buffer.from === "function") {
          bytes2 = Buffer.from(urlContent, "base64");
        } else if (typeof atob === "function") {
          const binaryString = atob(urlContent);
          bytes2 = new Uint8Array(binaryString.length);
          for (let i14 = 0; i14 < binaryString.length; i14++) {
            bytes2[i14] = binaryString.charCodeAt(i14);
          }
        } else {
          throw new Error(
            "Failed to decode base64-encoded data URL, Buffer and atob are not supported"
          );
        }
        result = await WebAssembly.instantiate(bytes2, opts);
      } else {
        const response = await fetch(url2);
        const contentType = response.headers.get("Content-Type") || "";
        if ("instantiateStreaming" in WebAssembly && contentType.startsWith("application/wasm")) {
          result = await WebAssembly.instantiateStreaming(response, opts);
        } else {
          const buffer = await response.arrayBuffer();
          result = await WebAssembly.instantiate(buffer, opts);
        }
      }
      return result.instance;
    };
    wasmHelperCode = wasmHelper.toString();
    if (!String.prototype.repeat) {
      throw new Error(
        "String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation"
      );
    }
    if (!String.prototype.endsWith) {
      throw new Error(
        "String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation"
      );
    }
    regex = ansiRegex();
    EMPTY_OBJECT2 = Object.freeze({});
    debugSourcemapCombineFilter = process.env.DEBUG_VITE_SOURCEMAP_COMBINE_FILTER;
    debugSourcemapCombine = createDebugger("vite:sourcemap-combine", {
      onlyWhenFocused: true
    });
    debugResolve = createDebugger("vite:resolve");
    debugPluginResolve = createDebugger("vite:plugin-resolve", {
      onlyWhenFocused: "vite:plugin"
    });
    debugPluginTransform = createDebugger("vite:plugin-transform", {
      onlyWhenFocused: "vite:plugin"
    });
    debug$9 = createDebugger("vite:deps");
    debug$8 = createDebugger("vite:deps");
    debug$7 = createDebugger("vite:deps");
    lockfileFormats = [
      { name: "package-lock.json", checkPatches: true, manager: "npm" },
      { name: "yarn.lock", checkPatches: true, manager: "yarn" },
      // Included in lockfile for v2+
      { name: "pnpm-lock.yaml", checkPatches: false, manager: "pnpm" },
      // Included in lockfile
      { name: "bun.lockb", checkPatches: true, manager: "bun" }
    ].sort((_22, { manager }) => {
      return process.env.npm_config_user_agent?.startsWith(manager) ? 1 : -1;
    });
    lockfileNames = lockfileFormats.map((l10) => l10.name);
    MAX_TEMP_DIR_AGE_MS = 24 * 60 * 60 * 1e3;
    GRACEFUL_RENAME_TIMEOUT = 5e3;
    safeRename = promisify$4(function gracefulRename(from, to, cb) {
      const start2 = Date.now();
      let backoff = 0;
      fs__default.rename(from, to, function CB(er) {
        if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start2 < GRACEFUL_RENAME_TIMEOUT) {
          setTimeout(function() {
            fs__default.stat(to, function(stater, st) {
              if (stater && stater.code === "ENOENT") fs__default.rename(from, to, CB);
              else CB(er);
            });
          }, backoff);
          if (backoff < 100) backoff += 10;
          return;
        }
        if (cb) cb(er);
      });
    });
    debugLoad = createDebugger("vite:load");
    debugTransform = createDebugger("vite:transform");
    debugCache$1 = createDebugger("vite:cache");
    isWsl$2 = { exports: {} };
    fs$3 = require$$0__default3;
    isDocker_1 = () => {
      if (isDocker$2 === void 0) {
        isDocker$2 = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker$2;
    };
    os = require$$2;
    fs$2 = require$$0__default3;
    isDocker$1 = isDocker_1;
    isWsl$1 = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os.release().toLowerCase().includes("microsoft")) {
        if (isDocker$1()) {
          return false;
        }
        return true;
      }
      try {
        return fs$2.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker$1() : false;
      } catch (_22) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      isWsl$2.exports = isWsl$1;
    } else {
      isWsl$2.exports = isWsl$1();
    }
    isWslExports = isWsl$2.exports;
    defineLazyProp = (object2, propertyName, fn) => {
      const define = (value2) => Object.defineProperty(object2, propertyName, { value: value2, enumerable: true, writable: true });
      Object.defineProperty(object2, propertyName, {
        configurable: true,
        enumerable: true,
        get() {
          const result = fn();
          define(result);
          return result;
        },
        set(value2) {
          define(value2);
        }
      });
      return object2;
    };
    path$32 = require$$0$4;
    childProcess = require$$2$1;
    ({ promises: fs$1, constants: fsConstants } = require$$0__default3);
    isWsl = isWslExports;
    isDocker = isDocker_1;
    defineLazyProperty = defineLazyProp;
    localXdgOpenPath = path$32.join(__dirname4, "xdg-open");
    ({ platform, arch } = process);
    hasContainerEnv = () => {
      try {
        fs$1.statSync("/run/.containerenv");
        return true;
      } catch {
        return false;
      }
    };
    getWslDrivesMountPoint = /* @__PURE__ */ (() => {
      const defaultMountPoint = "/mnt/";
      let mountPoint;
      return async function() {
        if (mountPoint) {
          return mountPoint;
        }
        const configFilePath = "/etc/wsl.conf";
        let isConfigFileExists = false;
        try {
          await fs$1.access(configFilePath, fsConstants.F_OK);
          isConfigFileExists = true;
        } catch {
        }
        if (!isConfigFileExists) {
          return defaultMountPoint;
        }
        const configContent = await fs$1.readFile(configFilePath, { encoding: "utf8" });
        const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
        if (!configMountPoint) {
          return defaultMountPoint;
        }
        mountPoint = configMountPoint.groups.mountPoint.trim();
        mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
        return mountPoint;
      };
    })();
    pTryEach = async (array2, mapper) => {
      let latestError;
      for (const item of array2) {
        try {
          return await mapper(item);
        } catch (error2) {
          latestError = error2;
        }
      }
      throw latestError;
    };
    baseOpen = async (options2) => {
      options2 = {
        wait: false,
        background: false,
        newInstance: false,
        allowNonzeroExitCode: false,
        ...options2
      };
      if (Array.isArray(options2.app)) {
        return pTryEach(options2.app, (singleApp) => baseOpen({
          ...options2,
          app: singleApp
        }));
      }
      let { name: app, arguments: appArguments = [] } = options2.app || {};
      appArguments = [...appArguments];
      if (Array.isArray(app)) {
        return pTryEach(app, (appName) => baseOpen({
          ...options2,
          app: {
            name: appName,
            arguments: appArguments
          }
        }));
      }
      let command;
      const cliArguments = [];
      const childProcessOptions = {};
      if (platform === "darwin") {
        command = "open";
        if (options2.wait) {
          cliArguments.push("--wait-apps");
        }
        if (options2.background) {
          cliArguments.push("--background");
        }
        if (options2.newInstance) {
          cliArguments.push("--new");
        }
        if (app) {
          cliArguments.push("-a", app);
        }
      } else if (platform === "win32" || isWsl && !isInsideContainer() && !app) {
        const mountPoint = await getWslDrivesMountPoint();
        command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
        cliArguments.push(
          "-NoProfile",
          "-NonInteractive",
          "–ExecutionPolicy",
          "Bypass",
          "-EncodedCommand"
        );
        if (!isWsl) {
          childProcessOptions.windowsVerbatimArguments = true;
        }
        const encodedArguments = ["Start"];
        if (options2.wait) {
          encodedArguments.push("-Wait");
        }
        if (app) {
          encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
          if (options2.target) {
            appArguments.unshift(options2.target);
          }
        } else if (options2.target) {
          encodedArguments.push(`"${options2.target}"`);
        }
        if (appArguments.length > 0) {
          appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
          encodedArguments.push(appArguments.join(","));
        }
        options2.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app) {
          command = app;
        } else {
          const isBundled = !__dirname4 || __dirname4 === "/";
          let exeLocalXdgOpen = false;
          try {
            await fs$1.access(localXdgOpenPath, fsConstants.X_OK);
            exeLocalXdgOpen = true;
          } catch {
          }
          const useSystemXdgOpen = process.versions.electron || platform === "android" || isBundled || !exeLocalXdgOpen;
          command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        if (appArguments.length > 0) {
          cliArguments.push(...appArguments);
        }
        if (!options2.wait) {
          childProcessOptions.stdio = "ignore";
          childProcessOptions.detached = true;
        }
      }
      if (options2.target) {
        cliArguments.push(options2.target);
      }
      if (platform === "darwin" && appArguments.length > 0) {
        cliArguments.push("--args", ...appArguments);
      }
      const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
      if (options2.wait) {
        return new Promise((resolve5, reject) => {
          subprocess.once("error", reject);
          subprocess.once("close", (exitCode) => {
            if (!options2.allowNonzeroExitCode && exitCode > 0) {
              reject(new Error(`Exited with code ${exitCode}`));
              return;
            }
            resolve5(subprocess);
          });
        });
      }
      subprocess.unref();
      return subprocess;
    };
    open = (target, options2) => {
      if (typeof target !== "string") {
        throw new TypeError("Expected a `target`");
      }
      return baseOpen({
        ...options2,
        target
      });
    };
    openApp = (name2, options2) => {
      if (typeof name2 !== "string") {
        throw new TypeError("Expected a `name`");
      }
      const { arguments: appArguments = [] } = options2 || {};
      if (appArguments !== void 0 && appArguments !== null && !Array.isArray(appArguments)) {
        throw new TypeError("Expected `appArguments` as Array type");
      }
      return baseOpen({
        ...options2,
        app: {
          name: name2,
          arguments: appArguments
        }
      });
    };
    apps = {};
    defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
      darwin: "google chrome",
      win32: "chrome",
      linux: ["google-chrome", "google-chrome-stable", "chromium"]
    }, {
      wsl: {
        ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
        x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
      }
    }));
    defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
      darwin: "firefox",
      win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
      linux: "firefox"
    }, {
      wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
    }));
    defineLazyProperty(apps, "edge", () => detectPlatformBinary({
      darwin: "microsoft edge",
      win32: "msedge",
      linux: ["microsoft-edge", "microsoft-edge-dev"]
    }, {
      wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
    }));
    open.apps = apps;
    open.openApp = openApp;
    crossSpawn = { exports: {} };
    if (process.platform === "win32" || commonjsGlobal.TESTING_WINDOWS) {
      core = requireWindows();
    } else {
      core = requireMode();
    }
    isexe_1 = isexe$1;
    isexe$1.sync = sync;
    isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    path$22 = require$$0$4;
    COLON = isWindows ? ";" : ":";
    isexe = isexe_1;
    getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    getPathInfo = (cmd, opt) => {
      const colon3 = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon3)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon3) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    which$1 = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i14) => new Promise((resolve5, reject) => {
        if (i14 === pathEnv.length)
          return opt.all && found.length ? resolve5(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i14];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path$22.join(pathPart, cmd);
        const p20 = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve5(subStep(p20, i14, 0));
      });
      const subStep = (p20, i14, ii) => new Promise((resolve5, reject) => {
        if (ii === pathExt.length)
          return resolve5(step(i14 + 1));
        const ext2 = pathExt[ii];
        isexe(p20 + ext2, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p20 + ext2);
            else
              return resolve5(p20 + ext2);
          }
          return resolve5(subStep(p20, i14, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i14 = 0; i14 < pathEnv.length; i14++) {
        const ppRaw = pathEnv[i14];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path$22.join(pathPart, cmd);
        const p20 = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j16 = 0; j16 < pathExt.length; j16++) {
          const cur = p20 + pathExt[j16];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    which_1 = which$1;
    which$1.sync = whichSync;
    pathKey$1 = { exports: {} };
    pathKey = (options2 = {}) => {
      const environment = options2.env || process.env;
      const platform2 = options2.platform || process.platform;
      if (platform2 !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    pathKey$1.exports = pathKey;
    pathKey$1.exports.default = pathKey;
    pathKeyExports = pathKey$1.exports;
    path$13 = require$$0$4;
    which = which_1;
    getPathKey = pathKeyExports;
    resolveCommand_1 = resolveCommand$1;
    _escape = {};
    metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    _escape.command = escapeCommand;
    _escape.argument = escapeArgument;
    shebangRegex$1 = /^#!(.*)/;
    shebangRegex = shebangRegex$1;
    shebangCommand$1 = (string4 = "") => {
      const match2 = string4.match(shebangRegex);
      if (!match2) {
        return null;
      }
      const [path7, argument] = match2[0].replace(/#! ?/, "").split(" ");
      const binary2 = path7.split("/").pop();
      if (binary2 === "env") {
        return argument;
      }
      return argument ? `${binary2} ${argument}` : binary2;
    };
    fs4 = require$$0__default3;
    shebangCommand = shebangCommand$1;
    readShebang_1 = readShebang$1;
    path5 = require$$0$4;
    resolveCommand = resolveCommand_1;
    escape$1 = _escape;
    readShebang = readShebang_1;
    isWin$1 = process.platform === "win32";
    isExecutableRegExp = /\.(?:com|exe)$/i;
    isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    parse_1 = parse$4;
    isWin = process.platform === "win32";
    enoent$1 = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
    cp = require$$2$1;
    parse$3 = parse_1;
    enoent = enoent$1;
    crossSpawn.exports = spawn;
    crossSpawn.exports.spawn = spawn;
    crossSpawn.exports.sync = spawnSync;
    crossSpawn.exports._parse = parse$3;
    crossSpawn.exports._enoent = enoent;
    crossSpawnExports = crossSpawn.exports;
    OTHER_SOURCE_MAP_REGEXP = new RegExp(
      `//# ${SOURCEMAPPING_URL}=data:application/json[^,]+base64,([A-Za-z0-9+/=]+)$`,
      "gm"
    );
    bufferUtil$1 = { exports: {} };
    BINARY_TYPES$2 = ["nodebuffer", "arraybuffer", "fragments"];
    hasBlob$1 = typeof Blob !== "undefined";
    if (hasBlob$1) BINARY_TYPES$2.push("blob");
    constants = {
      BINARY_TYPES: BINARY_TYPES$2,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      hasBlob: hasBlob$1,
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
    ({ EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants);
    FastBuffer$2 = Buffer[Symbol.species];
    bufferUtil$1.exports = {
      concat: concat$1,
      mask: _mask,
      toArrayBuffer: toArrayBuffer$1,
      toBuffer: toBuffer$2,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil2 = require27("bufferutil");
        bufferUtil$1.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48) _mask(source, mask, output, offset, length);
          else bufferUtil2.mask(source, mask, output, offset, length);
        };
        bufferUtil$1.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil2.unmask(buffer, mask);
        };
      } catch (e2) {
      }
    }
    bufferUtilExports = bufferUtil$1.exports;
    kDone = Symbol("kDone");
    kRun = Symbol("kRun");
    Limiter$1 = class Limiter {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    limiter = Limiter$1;
    zlib = zlib$1;
    bufferUtil = bufferUtilExports;
    Limiter2 = limiter;
    ({ kStatusCode: kStatusCode$2 } = constants);
    FastBuffer$1 = Buffer[Symbol.species];
    TRAILER = Buffer.from([0, 0, 255, 255]);
    kPerMessageDeflate = Symbol("permessage-deflate");
    kTotalLength = Symbol("total-length");
    kCallback = Symbol("callback");
    kBuffers = Symbol("buffers");
    kError$1 = Symbol("error");
    PerMessageDeflate$4 = class PerMessageDeflate {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options2, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options2 || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter2(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value2 = params[key];
            if (value2.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value2 = value2[0];
            if (key === "client_max_window_bits") {
              if (value2 !== true) {
                const num = +value2;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value2}`
                  );
                }
                value2 = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value2}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value2;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value2}`
                );
              }
              value2 = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value2 !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value2}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value2;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError$1];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer$1(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    permessageDeflate = PerMessageDeflate$4;
    validation = { exports: {} };
    ({ isUtf8 } = require$$0$a);
    ({ hasBlob } = constants);
    tokenChars$2 = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    validation.exports = {
      isBlob: isBlob$2,
      isValidStatusCode: isValidStatusCode$2,
      isValidUTF8: _isValidUTF8,
      tokenChars: tokenChars$2
    };
    if (isUtf8) {
      validation.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF82 = require27("utf-8-validate");
        validation.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF82(buf);
        };
      } catch (e2) {
      }
    }
    validationExports = validation.exports;
    ({ Writable: Writable$1 } = require$$0$6);
    PerMessageDeflate$3 = permessageDeflate;
    ({
      BINARY_TYPES: BINARY_TYPES$1,
      EMPTY_BUFFER: EMPTY_BUFFER$2,
      kStatusCode: kStatusCode$1,
      kWebSocket: kWebSocket$3
    } = constants);
    ({ concat, toArrayBuffer, unmask } = bufferUtilExports);
    ({ isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validationExports);
    FastBuffer = Buffer[Symbol.species];
    GET_INFO = 0;
    GET_PAYLOAD_LENGTH_16 = 1;
    GET_PAYLOAD_LENGTH_64 = 2;
    GET_MASK = 3;
    GET_DATA = 4;
    INFLATING = 5;
    DEFER_EVENT = 6;
    Receiver$1 = class Receiver extends Writable$1 {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options2 = {}) {
        super();
        this._allowSynchronousEvents = options2.allowSynchronousEvents !== void 0 ? options2.allowSynchronousEvents : true;
        this._binaryType = options2.binaryType || BINARY_TYPES$1[0];
        this._extensions = options2.extensions || {};
        this._isServer = !!options2.isServer;
        this._maxPayload = options2.maxPayload | 0;
        this._skipUTF8Validation = !!options2.skipUTF8Validation;
        this[kWebSocket$3] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n14) {
        this._bufferedBytes -= n14;
        if (n14 === this._buffers[0].length) return this._buffers.shift();
        if (n14 < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n14,
            buf.length - n14
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n14);
        }
        const dst = Buffer.allocUnsafe(n14);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n14;
          if (n14 >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n14), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n14,
              buf.length - n14
            );
          }
          n14 -= buf.length;
        } while (n14 > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored) cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error2 = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error2);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
          const error2 = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error2);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error2 = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error2);
            return;
          }
          if (!this._fragmented) {
            const error2 = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error2);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error2 = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error2);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error2 = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error2);
            return;
          }
          if (compressed) {
            const error2 = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error2);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error2 = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error2);
            return;
          }
        } else {
          const error2 = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error2);
          return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error2 = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error2);
            return;
          }
        } else if (this._masked) {
          const error2 = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error2);
          return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error2 = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error2);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error2 = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error2);
            return;
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER$2;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error2 = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error2);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO) this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else if (this._binaryType === "blob") {
            data = new Blob(fragments);
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error2 = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error2);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER$2);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode$1(code)) {
              const error2 = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error2);
              return;
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error2 = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error2);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode$1] = statusCode;
        return err;
      }
    };
    receiver = Receiver$1;
    ({ randomFillSync } = require$$3$1);
    PerMessageDeflate$2 = permessageDeflate;
    ({ EMPTY_BUFFER: EMPTY_BUFFER$1, kWebSocket: kWebSocket$2, NOOP: NOOP$2 } = constants);
    ({ isBlob: isBlob$1, isValidStatusCode } = validationExports);
    ({ mask: applyMask, toBuffer: toBuffer$1 } = bufferUtilExports);
    kByteLength = Symbol("kByteLength");
    maskBuffer = Buffer.alloc(4);
    RANDOM_POOL_SIZE = 8 * 1024;
    randomPoolPointer = RANDOM_POOL_SIZE;
    DEFAULT = 0;
    DEFLATING = 1;
    GET_BLOB_DATA = 2;
    Sender$1 = class Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions2, generateMask) {
        this._extensions = extensions2 || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP$2;
        this[kWebSocket$2] = void 0;
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options2) {
        let mask;
        let merge3 = false;
        let offset = 2;
        let skipMasking = false;
        if (options2.mask) {
          mask = options2.maskBuffer || maskBuffer;
          if (options2.generateMask) {
            options2.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options2.mask || skipMasking) && options2[kByteLength] !== void 0) {
            dataLength = options2[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge3 = options2.mask && options2.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge3 ? dataLength + offset : offset);
        target[0] = options2.fin ? options2.opcode | 128 : options2.opcode;
        if (options2.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options2.mask) return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [target, data];
        if (merge3) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER$1;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options2 = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf, false, options2, cb]);
        } else {
          this.sendFrame(Sender.frame(buf, options2), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob$1(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer$1(data);
          byteLength = data.length;
          readOnly = toBuffer$1.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options2 = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (isBlob$1(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options2, cb]);
          } else {
            this.getBlobData(data, false, options2, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options2, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options2), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob$1(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer$1(data);
          byteLength = data.length;
          readOnly = toBuffer$1.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options2 = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (isBlob$1(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options2, cb]);
          } else {
            this.getBlobData(data, false, options2, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options2, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options2), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options2, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
        let opcode = options2.binary ? 2 : 1;
        let rsv1 = options2.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob$1(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer$1(data);
          byteLength = data.length;
          readOnly = toBuffer$1.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options2.fin) this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options2.fin,
          generateMask: this._generateMask,
          mask: options2.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (isBlob$1(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      /**
       * Gets the contents of a blob as binary data.
       *
       * @param {Blob} blob The blob
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     the data
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      getBlobData(blob, compress, options2, cb) {
        this._bufferedBytes += options2[kByteLength];
        this._state = GET_BLOB_DATA;
        blob.arrayBuffer().then((arrayBuffer) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while the blob was being read"
            );
            process.nextTick(callCallbacks, this, err, cb);
            return;
          }
          this._bufferedBytes -= options2[kByteLength];
          const data = toBuffer$1(arrayBuffer);
          if (!compress) {
            this._state = DEFAULT;
            this.sendFrame(Sender.frame(data, options2), cb);
            this.dequeue();
          } else {
            this.dispatch(data, compress, options2, cb);
          }
        }).catch((err) => {
          process.nextTick(onError, this, err, cb);
        });
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options2, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options2), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
        this._bufferedBytes += options2[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options2.fin, (_22, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options2[kByteLength];
          this._state = DEFAULT;
          options2.readOnly = false;
          this.sendFrame(Sender.frame(buf, options2), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    sender = Sender$1;
    ({ kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants);
    kCode = Symbol("kCode");
    kData = Symbol("kData");
    kError = Symbol("kError");
    kMessage = Symbol("kMessage");
    kReason = Symbol("kReason");
    kTarget = Symbol("kTarget");
    kType = Symbol("kType");
    kWasClean = Symbol("kWasClean");
    Event$1 = class Event2 {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event$1.prototype, "target", { enumerable: true });
    Object.defineProperty(Event$1.prototype, "type", { enumerable: true });
    CloseEvent = class extends Event$1 {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options2 = {}) {
        super(type);
        this[kCode] = options2.code === void 0 ? 0 : options2.code;
        this[kReason] = options2.reason === void 0 ? "" : options2.reason;
        this[kWasClean] = options2.wasClean === void 0 ? false : options2.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    ErrorEvent = class extends Event$1 {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options2 = {}) {
        super(type);
        this[kError] = options2.error === void 0 ? null : options2.error;
        this[kMessage] = options2.message === void 0 ? "" : options2.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    MessageEvent = class extends Event$1 {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options2 = {}) {
        super(type);
        this[kData] = options2.data === void 0 ? null : options2.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options2 = {}) {
        for (const listener2 of this.listeners(type)) {
          if (!options2[kForOnEventAttribute$1] && listener2[kListener$1] === handler && !listener2[kForOnEventAttribute$1]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError2(error2) {
            const event = new ErrorEvent("error", {
              error: error2,
              message: error2.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event$1("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute$1] = !!options2[kForOnEventAttribute$1];
        wrapper[kListener$1] = handler;
        if (options2.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener2 of this.listeners(type)) {
          if (listener2[kListener$1] === handler && !listener2[kForOnEventAttribute$1]) {
            this.removeListener(type, listener2);
            break;
          }
        }
      }
    };
    eventTarget = {
      CloseEvent,
      ErrorEvent,
      Event: Event$1,
      EventTarget,
      MessageEvent
    };
    ({ tokenChars: tokenChars$1 } = validationExports);
    extension$1 = { format: format$1, parse: parse$2 };
    EventEmitter$1 = require$$0$7;
    https$2 = require$$1$1;
    http$3 = require$$1;
    net = require$$4$1;
    tls = require$$4$2;
    ({ randomBytes, createHash: createHash$1 } = require$$3$1);
    ({ URL: URL$2 } = require$$0$9);
    PerMessageDeflate$1 = permessageDeflate;
    Receiver2 = receiver;
    Sender2 = sender;
    ({ isBlob } = validationExports);
    ({
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID: GUID$1,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket: kWebSocket$1,
      NOOP: NOOP$1
    } = constants);
    ({
      EventTarget: { addEventListener, removeEventListener }
    } = eventTarget);
    ({ format, parse: parse$12 } = extension$1);
    ({ toBuffer } = bufferUtilExports);
    closeTimeout = 30 * 1e3;
    kAborted = Symbol("kAborted");
    protocolVersions = [8, 13];
    readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    WebSocket$1 = class WebSocket extends EventEmitter$1 {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options2) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options2 = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options2);
        } else {
          this._autoPong = options2.autoPong;
          this._isServer = true;
        }
      }
      /**
       * For historical reasons, the custom "nodebuffer" type is used by the default
       * instead of "blob".
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options2) {
        const receiver2 = new Receiver2({
          allowSynchronousEvents: options2.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options2.maxPayload,
          skipUTF8Validation: options2.skipUTF8Validation
        });
        const sender2 = new Sender2(socket, this._extensions, options2.generateMask);
        this._receiver = receiver2;
        this._sender = sender2;
        this._socket = socket;
        receiver2[kWebSocket$1] = this;
        sender2[kWebSocket$1] = this;
        socket[kWebSocket$1] = this;
        receiver2.on("conclude", receiverOnConclude);
        receiver2.on("drain", receiverOnDrain);
        receiver2.on("error", receiverOnError);
        receiver2.on("message", receiverOnMessage);
        receiver2.on("ping", receiverOnPing);
        receiver2.on("pong", receiverOnPong);
        sender2.onerror = senderOnError;
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError$1);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate$1.extensionName]) {
          this._extensions[PerMessageDeflate$1.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED) return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake$1(this, this._req, msg);
          return;
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options2, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options2 === "function") {
          cb = options2;
          options2 = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options2
        };
        if (!this._extensions[PerMessageDeflate$1.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === WebSocket.CLOSED) return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake$1(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket$1, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket$1.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket$1, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket$1.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket$1, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket$1.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket$1, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket$1.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property2) => {
      Object.defineProperty(WebSocket$1.prototype, property2, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket$1.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener2 of this.listeners(method)) {
            if (listener2[kForOnEventAttribute]) return listener2[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener2 of this.listeners(method)) {
            if (listener2[kForOnEventAttribute]) {
              this.removeListener(method, listener2);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket$1.prototype.addEventListener = addEventListener;
    WebSocket$1.prototype.removeEventListener = removeEventListener;
    websocket = WebSocket$1;
    ({ tokenChars } = validationExports);
    subprotocol$1 = { parse: parse5 };
    EventEmitter = require$$0$7;
    http$2 = require$$1;
    ({ createHash } = require$$3$1);
    extension = extension$1;
    PerMessageDeflate2 = permessageDeflate;
    subprotocol = subprotocol$1;
    WebSocket2 = websocket;
    ({ GUID, kWebSocket } = constants);
    keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    RUNNING = 0;
    CLOSING = 1;
    CLOSED = 2;
    WebSocketServer = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options2, callback) {
        super();
        options2 = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options2
        };
        if (options2.port == null && !options2.server && !options2.noServer || options2.port != null && (options2.server || options2.noServer) || options2.server && options2.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options2.port != null) {
          this._server = http$2.createServer((req2, res) => {
            const body = http$2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options2.port,
            options2.host,
            options2.backlog,
            callback
          );
        } else if (options2.server) {
          this._server = options2.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req2, socket, head) => {
              this.handleUpgrade(req2, socket, head, emitConnection);
            }
          });
        }
        if (options2.perMessageDeflate === true) options2.perMessageDeflate = {};
        if (options2.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options2;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req2) {
        if (this.options.path) {
          const index3 = req2.url.indexOf("?");
          const pathname = index3 !== -1 ? req2.url.slice(0, index3) : req2.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req2, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req2.headers["sec-websocket-key"];
        const upgrade = req2.headers.upgrade;
        const version3 = +req2.headers["sec-websocket-version"];
        if (req2.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req2, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
          return;
        }
        if (version3 !== 8 && version3 !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req2)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req2.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req2.headers["sec-websocket-extensions"];
        const extensions2 = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate2(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate2.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate2.extensionName]);
              extensions2[PerMessageDeflate2.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req2.headers[`${version3 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req2.socket.authorized || req2.socket.encrypted),
            req: req2
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions2,
                key,
                protocols,
                req2,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions2, key, protocols, req2, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions2, key, protocols, req2, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req2) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions2[PerMessageDeflate2.extensionName]) {
          const params = extensions2[PerMessageDeflate2.extensionName].params;
          const value2 = extension.format({
            [PerMessageDeflate2.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value2}`);
          ws._extensions = extensions2;
        }
        this.emit("headers", headers, req2);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req2);
      }
    };
    websocketServer = WebSocketServer;
    WebSocketServerRaw_ = /* @__PURE__ */ getDefaultExportFromCjs(websocketServer);
    WebSocketServerRaw = process.versions.bun ? (
      // @ts-expect-error: Bun defines `import.meta.require`
      import.meta.require("ws").WebSocketServer
    ) : WebSocketServerRaw_;
    httpProxy$3 = { exports: {} };
    eventemitter3 = { exports: {} };
    (function(module3) {
      var has = Object.prototype.hasOwnProperty, prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener2 = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener2, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener2);
        else emitter._events[evt] = [emitter._events[evt], listener2];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter3() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter3.prototype.eventNames = function eventNames() {
        var names = [], events2, name2;
        if (this._eventsCount === 0) return names;
        for (name2 in events2 = this._events) {
          if (has.call(events2, name2)) names.push(prefix ? name2.slice(1) : name2);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events2));
        }
        return names;
      };
      EventEmitter3.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i14 = 0, l10 = handlers.length, ee3 = new Array(l10); i14 < l10; i14++) {
          ee3[i14] = handlers[i14].fn;
        }
        return ee3;
      };
      EventEmitter3.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter3.prototype.emit = function emit(event, a1, a22, a32, a42, a52) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i14;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a22), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a22, a32), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a22, a32, a42), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a22, a32, a42, a52), true;
          }
          for (i14 = 1, args = new Array(len - 1); i14 < len; i14++) {
            args[i14 - 1] = arguments[i14];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j16;
          for (i14 = 0; i14 < length; i14++) {
            if (listeners[i14].once) this.removeListener(event, listeners[i14].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i14].fn.call(listeners[i14].context);
                break;
              case 2:
                listeners[i14].fn.call(listeners[i14].context, a1);
                break;
              case 3:
                listeners[i14].fn.call(listeners[i14].context, a1, a22);
                break;
              case 4:
                listeners[i14].fn.call(listeners[i14].context, a1, a22, a32);
                break;
              default:
                if (!args) for (j16 = 1, args = new Array(len - 1); j16 < len; j16++) {
                  args[j16 - 1] = arguments[j16];
                }
                listeners[i14].fn.apply(listeners[i14].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter3.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter3.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i14 = 0, events2 = [], length = listeners.length; i14 < length; i14++) {
            if (listeners[i14].fn !== fn || once && !listeners[i14].once || context && listeners[i14].context !== context) {
              events2.push(listeners[i14]);
            }
          }
          if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
      EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
      EventEmitter3.prefixed = prefix;
      EventEmitter3.EventEmitter = EventEmitter3;
      {
        module3.exports = EventEmitter3;
      }
    })(eventemitter3);
    eventemitter3Exports = eventemitter3.exports;
    common$3 = {};
    requiresPort = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port) return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
    (function(exports4) {
      var common2 = exports4, url2 = require$$0$9, required2 = requiresPort;
      var upgradeHeader = /(^|,)\s*upgrade\s*($|,)/i, isSSL = /^https|wss/;
      common2.isSSL = isSSL;
      common2.setupOutgoing = function(outgoing, options2, req2, forward) {
        outgoing.port = options2[forward || "target"].port || (isSSL.test(options2[forward || "target"].protocol) ? 443 : 80);
        [
          "host",
          "hostname",
          "socketPath",
          "pfx",
          "key",
          "passphrase",
          "cert",
          "ca",
          "ciphers",
          "secureProtocol"
        ].forEach(
          function(e2) {
            outgoing[e2] = options2[forward || "target"][e2];
          }
        );
        outgoing.method = options2.method || req2.method;
        outgoing.headers = Object.assign({}, req2.headers);
        if (options2.headers) {
          Object.assign(outgoing.headers, options2.headers);
        }
        if (options2.auth) {
          outgoing.auth = options2.auth;
        }
        if (options2.ca) {
          outgoing.ca = options2.ca;
        }
        if (isSSL.test(options2[forward || "target"].protocol)) {
          outgoing.rejectUnauthorized = typeof options2.secure === "undefined" ? true : options2.secure;
        }
        outgoing.agent = options2.agent || false;
        outgoing.localAddress = options2.localAddress;
        if (!outgoing.agent) {
          outgoing.headers = outgoing.headers || {};
          if (typeof outgoing.headers.connection !== "string" || !upgradeHeader.test(outgoing.headers.connection)) {
            outgoing.headers.connection = "close";
          }
        }
        var target = options2[forward || "target"];
        var targetPath = target && options2.prependPath !== false ? target.path || "" : "";
        var outgoingPath = !options2.toProxy ? url2.parse(req2.url).path || "" : req2.url;
        outgoingPath = !options2.ignorePath ? outgoingPath : "";
        outgoing.path = common2.urlJoin(targetPath, outgoingPath);
        if (options2.changeOrigin) {
          outgoing.headers.host = required2(outgoing.port, options2[forward || "target"].protocol) && !hasPort(outgoing.host) ? outgoing.host + ":" + outgoing.port : outgoing.host;
        }
        return outgoing;
      };
      common2.setupSocket = function(socket) {
        socket.setTimeout(0);
        socket.setNoDelay(true);
        socket.setKeepAlive(true, 0);
        return socket;
      };
      common2.getPort = function(req2) {
        var res = req2.headers.host ? req2.headers.host.match(/:(\d+)/) : "";
        return res ? res[1] : common2.hasEncryptedConnection(req2) ? "443" : "80";
      };
      common2.hasEncryptedConnection = function(req2) {
        return Boolean(req2.connection.encrypted || req2.connection.pair);
      };
      common2.urlJoin = function() {
        var args = Array.prototype.slice.call(arguments), lastIndex = args.length - 1, last = args[lastIndex], lastSegs = last.split("?"), retSegs;
        args[lastIndex] = lastSegs.shift();
        retSegs = [
          args.filter(Boolean).join("/").replace(/\/+/g, "/").replace("http:/", "http://").replace("https:/", "https://")
        ];
        retSegs.push.apply(retSegs, lastSegs);
        return retSegs.join("?");
      };
      common2.rewriteCookieProperty = function rewriteCookieProperty(header, config2, property2) {
        if (Array.isArray(header)) {
          return header.map(function(headerElement) {
            return rewriteCookieProperty(headerElement, config2, property2);
          });
        }
        return header.replace(new RegExp("(;\\s*" + property2 + "=)([^;]+)", "i"), function(match2, prefix, previousValue) {
          var newValue;
          if (previousValue in config2) {
            newValue = config2[previousValue];
          } else if ("*" in config2) {
            newValue = config2["*"];
          } else {
            return match2;
          }
          if (newValue) {
            return prefix + newValue;
          } else {
            return "";
          }
        });
      };
      function hasPort(host) {
        return !!~host.indexOf(":");
      }
    })(common$3);
    url$1 = require$$0$9;
    common$2 = common$3;
    redirectRegex = /^201|30(1|2|7|8)$/;
    webOutgoing = {
      // <--
      /**
       * If is a HTTP 1.0 request, remove chunk headers
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {proxyResponse} Res Response object from the proxy request
       *
       * @api private
       */
      removeChunked: function removeChunked(req2, res, proxyRes) {
        if (req2.httpVersion === "1.0") {
          delete proxyRes.headers["transfer-encoding"];
        }
      },
      /**
       * If is a HTTP 1.0 request, set the correct connection header
       * or if connection header not present, then use `keep-alive`
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {proxyResponse} Res Response object from the proxy request
       *
       * @api private
       */
      setConnection: function setConnection(req2, res, proxyRes) {
        if (req2.httpVersion === "1.0") {
          proxyRes.headers.connection = req2.headers.connection || "close";
        } else if (req2.httpVersion !== "2.0" && !proxyRes.headers.connection) {
          proxyRes.headers.connection = req2.headers.connection || "keep-alive";
        }
      },
      setRedirectHostRewrite: function setRedirectHostRewrite(req2, res, proxyRes, options2) {
        if ((options2.hostRewrite || options2.autoRewrite || options2.protocolRewrite) && proxyRes.headers["location"] && redirectRegex.test(proxyRes.statusCode)) {
          var target = url$1.parse(options2.target);
          var u17 = url$1.parse(proxyRes.headers["location"]);
          if (target.host != u17.host) {
            return;
          }
          if (options2.hostRewrite) {
            u17.host = options2.hostRewrite;
          } else if (options2.autoRewrite) {
            u17.host = req2.headers["host"];
          }
          if (options2.protocolRewrite) {
            u17.protocol = options2.protocolRewrite;
          }
          proxyRes.headers["location"] = u17.format();
        }
      },
      /**
       * Copy headers from proxyResponse to response
       * set each header in response object.
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {proxyResponse} Res Response object from the proxy request
       * @param {Object} Options options.cookieDomainRewrite: Config to rewrite cookie domain
       *
       * @api private
       */
      writeHeaders: function writeHeaders(req2, res, proxyRes, options2) {
        var rewriteCookieDomainConfig = options2.cookieDomainRewrite, rewriteCookiePathConfig = options2.cookiePathRewrite, preserveHeaderKeyCase = options2.preserveHeaderKeyCase, rawHeaderKeyMap, setHeader = function(key2, header) {
          if (header == void 0) return;
          if (rewriteCookieDomainConfig && key2.toLowerCase() === "set-cookie") {
            header = common$2.rewriteCookieProperty(header, rewriteCookieDomainConfig, "domain");
          }
          if (rewriteCookiePathConfig && key2.toLowerCase() === "set-cookie") {
            header = common$2.rewriteCookieProperty(header, rewriteCookiePathConfig, "path");
          }
          res.setHeader(String(key2).trim(), header);
        };
        if (typeof rewriteCookieDomainConfig === "string") {
          rewriteCookieDomainConfig = { "*": rewriteCookieDomainConfig };
        }
        if (typeof rewriteCookiePathConfig === "string") {
          rewriteCookiePathConfig = { "*": rewriteCookiePathConfig };
        }
        if (preserveHeaderKeyCase && proxyRes.rawHeaders != void 0) {
          rawHeaderKeyMap = {};
          for (var i14 = 0; i14 < proxyRes.rawHeaders.length; i14 += 2) {
            var key = proxyRes.rawHeaders[i14];
            rawHeaderKeyMap[key.toLowerCase()] = key;
          }
        }
        Object.keys(proxyRes.headers).forEach(function(key2) {
          var header = proxyRes.headers[key2];
          if (preserveHeaderKeyCase && rawHeaderKeyMap) {
            key2 = rawHeaderKeyMap[key2] || key2;
          }
          setHeader(key2, header);
        });
      },
      /**
       * Set the statusCode from the proxyResponse
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {proxyResponse} Res Response object from the proxy request
       *
       * @api private
       */
      writeStatusCode: function writeStatusCode(req2, res, proxyRes) {
        if (proxyRes.statusMessage) {
          res.statusCode = proxyRes.statusCode;
          res.statusMessage = proxyRes.statusMessage;
        } else {
          res.statusCode = proxyRes.statusCode;
        }
      }
    };
    followRedirects$1 = { exports: {} };
    debug_1 = function() {
      if (!debug$6) {
        try {
          debug$6 = srcExports$12("follow-redirects");
        } catch (error2) {
        }
        if (typeof debug$6 !== "function") {
          debug$6 = function() {
          };
        }
      }
      debug$6.apply(null, arguments);
    };
    url = require$$0$9;
    URL$1 = url.URL;
    http$1 = require$$1;
    https$1 = require$$1$1;
    Writable = require$$0$6.Writable;
    assert = require$$4$3;
    debug$5 = debug_1;
    useNativeURL = false;
    try {
      assert(new URL$1());
    } catch (error2) {
      useNativeURL = error2.code === "ERR_INVALID_URL";
    }
    preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    destroy = Writable.prototype.destroy || noop;
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error2) {
      destroyRequest(this._currentRequest, error2);
      destroy.call(this, error2);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString2(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name2, value2) {
      this._options.headers[name2] = value2;
      this._currentRequest.setHeader(name2, value2);
    };
    RedirectableRequest.prototype.removeHeader = function(name2) {
      delete this._options.headers[name2];
      this._currentRequest.removeHeader(name2);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a20, b18) {
        return this._currentRequest[method](a20, b18);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property2) {
      Object.defineProperty(RedirectableRequest.prototype, property2, {
        get: function() {
          return this._currentRequest[property2];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options2) {
      if (!options2.headers) {
        options2.headers = {};
      }
      if (options2.host) {
        if (!options2.hostname) {
          options2.hostname = options2.host;
        }
        delete options2.host;
      }
      if (!options2.pathname && options2.path) {
        var searchPos = options2.path.indexOf("?");
        if (searchPos < 0) {
          options2.pathname = options2.path;
        } else {
          options2.pathname = options2.path.substring(0, searchPos);
          options2.search = options2.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, […]
        // a client MUST send the target URI in absolute-form […].
        this._options.path
      );
      if (this._isRedirect) {
        var i14 = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error2) {
          if (request === self2._currentRequest) {
            if (error2) {
              self2.emit("error", error2);
            } else if (i14 < buffers.length) {
              var buffer = buffers[i14++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location2 = response.headers.location;
      if (!location2 || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location2) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location2, currentUrl);
      debug$5("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    followRedirects$1.exports = wrap({ http: http$1, https: https$1 });
    followRedirects$1.exports.wrap = wrap;
    followRedirectsExports = followRedirects$1.exports;
    httpNative = require$$1;
    httpsNative = require$$1$1;
    web_o = webOutgoing;
    common$1 = common$3;
    followRedirects = followRedirectsExports;
    web_o = Object.keys(web_o).map(function(pass) {
      return web_o[pass];
    });
    nativeAgents = { http: httpNative, https: httpsNative };
    webIncoming = {
      /**
       * Sets `content-length` to '0' if request is of DELETE type.
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      deleteLength: function deleteLength(req2, res, options2) {
        if ((req2.method === "DELETE" || req2.method === "OPTIONS") && !req2.headers["content-length"]) {
          req2.headers["content-length"] = "0";
          delete req2.headers["transfer-encoding"];
        }
      },
      /**
       * Sets timeout in request socket if it was specified in options.
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      timeout: function timeout(req2, res, options2) {
        if (options2.timeout) {
          req2.socket.setTimeout(options2.timeout);
        }
      },
      /**
       * Sets `x-forwarded-*` headers if specified in config.
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      XHeaders: function XHeaders(req2, res, options2) {
        if (!options2.xfwd) return;
        var encrypted = req2.isSpdy || common$1.hasEncryptedConnection(req2);
        var values = {
          for: req2.connection.remoteAddress || req2.socket.remoteAddress,
          port: common$1.getPort(req2),
          proto: encrypted ? "https" : "http"
        };
        ["for", "port", "proto"].forEach(function(header) {
          req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
        });
        req2.headers["x-forwarded-host"] = req2.headers["x-forwarded-host"] || req2.headers["host"] || "";
      },
      /**
       * Does the actual proxying. If `forward` is enabled fires up
       * a ForwardStream, same happens for ProxyStream. The request
       * just dies otherwise.
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      stream: function stream2(req2, res, options2, _22, server, clb) {
        server.emit("start", req2, res, options2.target || options2.forward);
        var agents = options2.followRedirects ? followRedirects : nativeAgents;
        var http2 = agents.http;
        var https2 = agents.https;
        if (options2.forward) {
          var forwardReq = (options2.forward.protocol === "https:" ? https2 : http2).request(
            common$1.setupOutgoing(options2.ssl || {}, options2, req2, "forward")
          );
          var forwardError = createErrorHandler(forwardReq, options2.forward);
          req2.on("error", forwardError);
          forwardReq.on("error", forwardError);
          (options2.buffer || req2).pipe(forwardReq);
          if (!options2.target) {
            return res.end();
          }
        }
        var proxyReq = (options2.target.protocol === "https:" ? https2 : http2).request(
          common$1.setupOutgoing(options2.ssl || {}, options2, req2)
        );
        proxyReq.on("socket", function(socket) {
          if (server && !proxyReq.getHeader("expect")) {
            server.emit("proxyReq", proxyReq, req2, res, options2);
          }
        });
        if (options2.proxyTimeout) {
          proxyReq.setTimeout(options2.proxyTimeout, function() {
            proxyReq.abort();
          });
        }
        req2.on("aborted", function() {
          proxyReq.abort();
        });
        var proxyError = createErrorHandler(proxyReq, options2.target);
        req2.on("error", proxyError);
        proxyReq.on("error", proxyError);
        function createErrorHandler(proxyReq2, url2) {
          return function proxyError2(err) {
            if (req2.socket.destroyed && err.code === "ECONNRESET") {
              server.emit("econnreset", err, req2, res, url2);
              return proxyReq2.abort();
            }
            if (clb) {
              clb(err, req2, res, url2);
            } else {
              server.emit("error", err, req2, res, url2);
            }
          };
        }
        (options2.buffer || req2).pipe(proxyReq);
        proxyReq.on("response", function(proxyRes) {
          if (server) {
            server.emit("proxyRes", proxyRes, req2, res);
          }
          if (!res.headersSent && !options2.selfHandleResponse) {
            for (var i14 = 0; i14 < web_o.length; i14++) {
              if (web_o[i14](req2, res, proxyRes, options2)) {
                break;
              }
            }
          }
          if (!res.finished) {
            proxyRes.on("end", function() {
              if (server) server.emit("end", req2, res, proxyRes);
            });
            if (!options2.selfHandleResponse) proxyRes.pipe(res);
          } else {
            if (server) server.emit("end", req2, res, proxyRes);
          }
        });
      }
    };
    http = require$$1;
    https = require$$1$1;
    common = common$3;
    wsIncoming = {
      /**
       * WebSocket requests must have the `GET` method and
       * the `upgrade:websocket` header
       *
       * @param {ClientRequest} Req Request object
       * @param {Socket} Websocket
       *
       * @api private
       */
      checkMethodAndHeader: function checkMethodAndHeader(req2, socket) {
        if (req2.method !== "GET" || !req2.headers.upgrade) {
          socket.destroy();
          return true;
        }
        if (req2.headers.upgrade.toLowerCase() !== "websocket") {
          socket.destroy();
          return true;
        }
      },
      /**
       * Sets `x-forwarded-*` headers if specified in config.
       *
       * @param {ClientRequest} Req Request object
       * @param {Socket} Websocket
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      XHeaders: function XHeaders2(req2, socket, options2) {
        if (!options2.xfwd) return;
        var values = {
          for: req2.connection.remoteAddress || req2.socket.remoteAddress,
          port: common.getPort(req2),
          proto: common.hasEncryptedConnection(req2) ? "wss" : "ws"
        };
        ["for", "port", "proto"].forEach(function(header) {
          req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
        });
      },
      /**
       * Does the actual proxying. Make the request and upgrade it
       * send the Switching Protocols request and pipe the sockets.
       *
       * @param {ClientRequest} Req Request object
       * @param {Socket} Websocket
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      stream: function stream3(req2, socket, options2, head, server, clb) {
        var createHttpHeader = function(line, headers) {
          return Object.keys(headers).reduce(function(head2, key) {
            var value2 = headers[key];
            if (!Array.isArray(value2)) {
              head2.push(key + ": " + value2);
              return head2;
            }
            for (var i14 = 0; i14 < value2.length; i14++) {
              head2.push(key + ": " + value2[i14]);
            }
            return head2;
          }, [line]).join("\r\n") + "\r\n\r\n";
        };
        common.setupSocket(socket);
        if (head && head.length) socket.unshift(head);
        var proxyReq = (common.isSSL.test(options2.target.protocol) ? https : http).request(
          common.setupOutgoing(options2.ssl || {}, options2, req2)
        );
        if (server) {
          server.emit("proxyReqWs", proxyReq, req2, socket, options2, head);
        }
        proxyReq.on("error", onOutgoingError);
        proxyReq.on("response", function(res) {
          if (!res.upgrade) {
            socket.write(createHttpHeader("HTTP/" + res.httpVersion + " " + res.statusCode + " " + res.statusMessage, res.headers));
            res.pipe(socket);
          }
        });
        proxyReq.on("upgrade", function(proxyRes, proxySocket, proxyHead) {
          proxySocket.on("error", onOutgoingError);
          proxySocket.on("end", function() {
            server.emit("close", proxyRes, proxySocket, proxyHead);
          });
          socket.on("error", function() {
            proxySocket.end();
          });
          common.setupSocket(proxySocket);
          if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);
          socket.write(createHttpHeader("HTTP/1.1 101 Switching Protocols", proxyRes.headers));
          proxySocket.pipe(socket).pipe(proxySocket);
          server.emit("open", proxySocket);
          server.emit("proxySocket", proxySocket);
        });
        return proxyReq.end();
        function onOutgoingError(err) {
          if (clb) {
            clb(err, req2, socket);
          } else {
            server.emit("error", err, req2, socket);
          }
          socket.end();
        }
      }
    };
    (function(module3) {
      var httpProxy = module3.exports, parse_url = require$$0$9.parse, EE3 = eventemitter3Exports, http2 = require$$1, https2 = require$$1$1, web = webIncoming, ws = wsIncoming;
      httpProxy.Server = ProxyServer2;
      function createRightProxy(type) {
        return function(options2) {
          return function(req2, res) {
            var passes = type === "ws" ? this.wsPasses : this.webPasses, args = [].slice.call(arguments), cntr = args.length - 1, head, cbl;
            if (typeof args[cntr] === "function") {
              cbl = args[cntr];
              cntr--;
            }
            var requestOptions = options2;
            if (!(args[cntr] instanceof Buffer) && args[cntr] !== res) {
              requestOptions = Object.assign({}, options2);
              Object.assign(requestOptions, args[cntr]);
              cntr--;
            }
            if (args[cntr] instanceof Buffer) {
              head = args[cntr];
            }
            ["target", "forward"].forEach(function(e2) {
              if (typeof requestOptions[e2] === "string")
                requestOptions[e2] = parse_url(requestOptions[e2]);
            });
            if (!requestOptions.target && !requestOptions.forward) {
              return this.emit("error", new Error("Must provide a proper URL as target"));
            }
            for (var i14 = 0; i14 < passes.length; i14++) {
              if (passes[i14](req2, res, requestOptions, head, this, cbl)) {
                break;
              }
            }
          };
        };
      }
      httpProxy.createRightProxy = createRightProxy;
      function ProxyServer2(options2) {
        EE3.call(this);
        options2 = options2 || {};
        options2.prependPath = options2.prependPath === false ? false : true;
        this.web = this.proxyRequest = createRightProxy("web")(options2);
        this.ws = this.proxyWebsocketRequest = createRightProxy("ws")(options2);
        this.options = options2;
        this.webPasses = Object.keys(web).map(function(pass) {
          return web[pass];
        });
        this.wsPasses = Object.keys(ws).map(function(pass) {
          return ws[pass];
        });
        this.on("error", this.onError, this);
      }
      require$$0$5.inherits(ProxyServer2, EE3);
      ProxyServer2.prototype.onError = function(err) {
        if (this.listeners("error").length === 1) {
          throw err;
        }
      };
      ProxyServer2.prototype.listen = function(port, hostname) {
        var self2 = this, closure = function(req2, res) {
          self2.web(req2, res);
        };
        this._server = this.options.ssl ? https2.createServer(this.options.ssl, closure) : http2.createServer(closure);
        if (this.options.ws) {
          this._server.on("upgrade", function(req2, socket, head) {
            self2.ws(req2, socket, head);
          });
        }
        this._server.listen(port, hostname);
        return this;
      };
      ProxyServer2.prototype.close = function(callback) {
        var self2 = this;
        if (this._server) {
          this._server.close(done);
        }
        function done() {
          self2._server = null;
          if (callback) {
            callback.apply(null, arguments);
          }
        }
      };
      ProxyServer2.prototype.before = function(type, passName, callback) {
        if (type !== "ws" && type !== "web") {
          throw new Error("type must be `web` or `ws`");
        }
        var passes = type === "ws" ? this.wsPasses : this.webPasses, i14 = false;
        passes.forEach(function(v15, idx) {
          if (v15.name === passName) i14 = idx;
        });
        if (i14 === false) throw new Error("No such pass");
        passes.splice(i14, 0, callback);
      };
      ProxyServer2.prototype.after = function(type, passName, callback) {
        if (type !== "ws" && type !== "web") {
          throw new Error("type must be `web` or `ws`");
        }
        var passes = type === "ws" ? this.wsPasses : this.webPasses, i14 = false;
        passes.forEach(function(v15, idx) {
          if (v15.name === passName) i14 = idx;
        });
        if (i14 === false) throw new Error("No such pass");
        passes.splice(i14++, 0, callback);
      };
    })(httpProxy$3);
    httpProxyExports = httpProxy$3.exports;
    ProxyServer = httpProxyExports.Server;
    ProxyServer.createProxyServer = createProxyServer;
    ProxyServer.createServer = createProxyServer;
    ProxyServer.createProxy = createProxyServer;
    debug$4 = createDebugger("vite:proxy");
    debug$3 = createDebugger("vite:html-fallback");
    debug$2 = createDebugger("vite:send", {
      onlyWhenFocused: true
    });
    debugCache = createDebugger("vite:cache");
    logTime = createDebugger("vite:time");
    debugHmr = createDebugger("vite:hmr");
    normalizedClientDir = normalizePath$3(CLIENT_DIR);
    debug$1 = createDebugger("vite:import-analysis");
    clientDir = normalizePath$3(CLIENT_DIR);
    preloadMarker = `__VITE_PRELOAD__`;
    preloadMarkerRE = new RegExp(preloadMarker, "g");
    needsEscapeRegEx = /[\n\r'\\\u2028\u2029]/;
    quoteNewlineRegEx = /([\n\r'\u2028\u2029])/g;
    backSlashRegEx = /\\/g;
    getResolveUrl = (path22, URL2 = "URL") => `new ${URL2}(${path22}).href`;
    getRelativeUrlFromDocument = (relativePath, umd = false) => getResolveUrl(
      `'${escapeId(partialEncodeURIPath(relativePath))}', ${umd ? `typeof document === 'undefined' ? location.href : ` : ""}document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT' && document.currentScript.src || document.baseURI`
    );
    getFileUrlFromFullPath = (path22) => `require('u' + 'rl').pathToFileURL(${path22}).href`;
    getFileUrlFromRelativePath = (path22) => getFileUrlFromFullPath(`__dirname + '/${escapeId(path22)}'`);
    relativeUrlMechanisms = {
      amd: (relativePath) => {
        if (relativePath[0] !== ".") relativePath = "./" + relativePath;
        return getResolveUrl(
          `require.toUrl('${escapeId(relativePath)}'), document.baseURI`
        );
      },
      cjs: (relativePath) => `(typeof document === 'undefined' ? ${getFileUrlFromRelativePath(
        relativePath
      )} : ${getRelativeUrlFromDocument(relativePath)})`,
      es: (relativePath) => getResolveUrl(
        `'${escapeId(partialEncodeURIPath(relativePath))}', import.meta.url`
      ),
      iife: (relativePath) => getRelativeUrlFromDocument(relativePath),
      // NOTE: make sure rollup generate `module` params
      system: (relativePath) => getResolveUrl(
        `'${escapeId(partialEncodeURIPath(relativePath))}', module.meta.url`
      ),
      umd: (relativePath) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getFileUrlFromRelativePath(
        relativePath
      )} : ${getRelativeUrlFromDocument(relativePath, true)})`
    };
    customRelativeUrlMechanisms = {
      ...relativeUrlMechanisms,
      "worker-iife": (relativePath) => getResolveUrl(
        `'${escapeId(partialEncodeURIPath(relativePath))}', self.location.href`
      )
    };
    debug = createDebugger("vite:config");
    promisifiedRealpath = promisify$4(fs__default.realpath);
    _require = createRequire$1(import.meta.url);
    dep_BWSbWtLw_default = module2.exports;
  }
});

// dist/node/cli.js
var cli_exports = {};
import path6 from "node:path";
import fs__default2 from "node:fs";
import { performance as performance2 } from "node:perf_hooks";
import { EventEmitter as EventEmitter2 } from "node:events";
import "node:fs/promises";
import "node:url";
import "node:util";
import "node:module";
import "node:tty";
import "node:path";
import "node:fs";
import "node:events";
import "node:stream";
import "node:string_decoder";
import "node:child_process";
import "node:http";
import "node:https";
import "node:util";
import "node:net";
import "node:url";
import "node:http";
import "node:stream";
import "node:os";
import "node:child_process";
import "node:os";
import "node:crypto";
import "node:dns";
import "node:crypto";
import "node:module";
import "node:assert";
import "node:v8";
import "node:worker_threads";
import "node:buffer";
import "node:querystring";
import "node:readline";
import "node:zlib";
import "node:buffer";
import "node:https";
import "node:tls";
import "node:assert";
import "node:zlib";
var init_cli = __esm({
  "dist/node/cli.js"() {
    init_dep_BWSbWtLw();
    init_constants();
    init_esbuild_0_24();
    init_parseAst2();
  }
});

// bin/vite.js
import { performance as performance3 } from "node:perf_hooks";
import nodeInspector from "node:inspector";
globalThis.__vite_start_time = performance3.now();
var debugIndex = process.argv.findIndex((arg) => /^(?:-d|--debug)$/.test(arg));
var filterIndex = process.argv.findIndex(
  (arg) => /^(?:-f|--filter)$/.test(arg)
);
var profileIndex = process.argv.indexOf("--profile");
if (debugIndex > 0) {
  let value2 = process.argv[debugIndex + 1];
  if (!value2 || value2.startsWith("-")) {
    value2 = "vite:*";
  } else {
    value2 = value2.split(",").map((v15) => `vite:${v15}`).join(",");
  }
  process.env.DEBUG = `${process.env.DEBUG ? process.env.DEBUG + "," : ""}${value2}`;
  if (filterIndex > 0) {
    const filter2 = process.argv[filterIndex + 1];
    if (filter2 && !filter2.startsWith("-")) {
      process.env.VITE_DEBUG_FILTER = filter2;
    }
  }
}
function start() {
  return Promise.resolve().then(() => (init_cli(), cli_exports));
}
if (profileIndex > 0) {
  process.argv.splice(profileIndex, 1);
  const next = process.argv[profileIndex];
  if (next && !next.startsWith("-")) {
    process.argv.splice(profileIndex, 1);
  }
  const inspector = nodeInspector?.default || nodeInspector;
  const session = globalThis.__vite_profile_session = new inspector.Session();
  session.connect();
  session.post("Profiler.enable", () => {
    session.post("Profiler.start", start);
  });
} else {
  start();
}
/*
  @license
	Rollup.js v4.24.3
	Tue, 29 Oct 2024 14:13:34 GMT - commit 69353a84d70294ecfcd5e1ab8e372e21e94c9f8e

	https://github.com/rollup/rollup

	Released under the MIT License.
*/
/*! https://mths.be/cssesc v3.0.0 by @mathias */
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * Autoload Config for PostCSS
 *
 * @author Michael Ciniawsky @michael-ciniawsky <michael.ciniawsky@gmail.com>
 * @license MIT
 *
 * @module postcss-load-config
 * @version 2.1.0
 *
 * @requires comsiconfig
 * @requires ./options
 * @requires ./plugins
 */
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * finalhandler
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * connect
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, res, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */
/*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, socket, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */
/*!
 * Caron dimonio, con occhi di bragia
 * loro accennando, tutte le raccoglie;
 * batte col remo qualunque s’adagia
 *
 * Charon the demon, with the eyes of glede,
 * Beckoning to them, collects them all together,
 * Beats with his oar whoever lags behind
 *
 *          Dante - The Divine Comedy (Canto III)
 */
